<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","build_use_case.rs"],"content":"use crate::domain::{\n    company_settings::repository::ConfigRepository,\n    project_management::AnyProject,\n    resource_management::repository::ResourceRepository,\n    // task_management::repository::TaskRepository,\n};\nuse crate::infrastructure::persistence::{\n    config_repository::FileConfigRepository,\n    project_repository::FileProjectRepository,\n    resource_repository::FileResourceRepository, // task_repository::FileTaskRepository,\n};\nuse crate::interface::assets::{StaticAssets, TemplateAssets};\n\nuse glob::glob;\n\nuse std::error::Error;\nuse std::fs;\nuse std::path::PathBuf;\nuse tera::{Context, Tera};\n\n/// `BuildUseCase` is responsible for orchestrating the static site generation.\npub struct BuildUseCase {\n    base_path: PathBuf,\n    tera: Tera,\n    output_dir: PathBuf,\n}\n\nimpl BuildUseCase {\n    pub fn new(base_path: PathBuf, output_dir: \u0026str) -\u003e Result\u003cSelf, Box\u003cdyn Error\u003e\u003e {\n        let mut tera = Tera::default();\n        for filename in TemplateAssets::iter() {\n            let file = TemplateAssets::get(filename.as_ref()).unwrap();\n            let content = std::str::from_utf8(file.data.as_ref())?;\n            tera.add_raw_template(filename.as_ref(), content)?;\n        }\n\n        Ok(Self {\n            base_path,\n            tera,\n            output_dir: PathBuf::from(output_dir),\n        })\n    }\n\n    /// Executes the build process.\n    pub fn execute(\u0026self) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        // 1. Clean and create the output directory.\n        if self.output_dir.exists() {\n            fs::remove_dir_all(\u0026self.output_dir)?;\n        }\n        fs::create_dir_all(\u0026self.output_dir)?;\n\n        // 2. Copy all embedded static assets to the output directory.\n        for filename in StaticAssets::iter() {\n            let asset = StaticAssets::get(filename.as_ref()).unwrap();\n            let dest_path = self.output_dir.join(filename.as_ref());\n            fs::write(dest_path, asset.data)?;\n        }\n\n        // 3. Load global configuration.\n        let config_repo = FileConfigRepository::with_base_path(self.base_path.clone());\n        let (config, _) = config_repo.load()?;\n\n        // 4. Find all projects and load their data.\n        let mut all_projects_data = Vec::new();\n        let project_manifest_pattern = self.base_path.join(\"**/project.yaml\");\n        for entry in glob(project_manifest_pattern.to_str().unwrap())? {\n            let manifest_path = entry?;\n            let project_path = manifest_path.parent().unwrap().to_path_buf();\n            println!(\"[INFO] Loading project from: {}\", project_path.display());\n\n            let project_repo = FileProjectRepository::with_base_path(project_path.clone());\n            let resource_repo = FileResourceRepository::new(project_path.clone());\n\n            let project = project_repo.load_from_path(\u0026project_path)?;\n            let resources = resource_repo.find_all()?;\n            let tasks: Vec\u003c_\u003e = project.tasks().values().cloned().collect();\n\n            let project = if project.timezone().is_none() {\n                match project {\n                    AnyProject::Planned(mut p) =\u003e {\n                        p.timezone = Some(config.default_timezone.clone());\n                        AnyProject::Planned(p)\n                    }\n                    AnyProject::InProgress(mut p) =\u003e {\n                        p.timezone = Some(config.default_timezone.clone());\n                        AnyProject::InProgress(p)\n                    }\n                    AnyProject::Completed(mut p) =\u003e {\n                        p.timezone = Some(config.default_timezone.clone());\n                        AnyProject::Completed(p)\n                    }\n                    AnyProject::Cancelled(mut p) =\u003e {\n                        p.timezone = Some(config.default_timezone.clone());\n                        AnyProject::Cancelled(p)\n                    }\n                }\n            } else {\n                project\n            };\n\n            all_projects_data.push((project, tasks, resources));\n        }\n\n        // 5. Render the global index page with all projects.\n        println!(\"[INFO] Generating global index page...\");\n        let mut context = Context::new();\n\n        let project_values: Vec\u003c_\u003e = all_projects_data\n            .iter()\n            .map(|(project, tasks, resources)| {\n                let mut map = tera::Map::new();\n                map.insert(\"project\".to_string(), tera::to_value(project).unwrap());\n                map.insert(\"tasks\".to_string(), tera::to_value(tasks).unwrap());\n                map.insert(\"resources\".to_string(), tera::to_value(resources).unwrap());\n                tera::Value::Object(map)\n            })\n            .collect();\n\n        context.insert(\"projects\", \u0026project_values);\n        context.insert(\"relative_path_prefix\", \"\");\n\n        // Create a dummy project for the base template header, which expects a `project` object.\n        let dummy_project: AnyProject =\n            crate::domain::project_management::builder::ProjectBuilder::new(\"Projects Dashboard\".to_string())\n                .code(\"TTR_DASHBOARD\".to_string())\n                .end_date(\"2024-12-31\".to_string())\n                .build()\n                .into();\n        context.insert(\"project\", \u0026dummy_project);\n\n        let index_html = self.tera.render(\"index.html\", \u0026context)?;\n        fs::write(self.output_dir.join(\"index.html\"), index_html)?;\n        println!(\"✅ Global index page generated successfully.\");\n\n        // 6. Render a detail page for each project.\n        let projects_base_dir = self.output_dir.join(\"projects\");\n        fs::create_dir_all(\u0026projects_base_dir)?;\n\n        for (project, tasks, resources) in \u0026all_projects_data {\n            let project_code = project.code();\n            let project_name = project.name();\n            println!(\"[INFO] Generating page for project: {project_name} ({project_code})\");\n\n            let project_output_dir = projects_base_dir.join(project_code);\n            fs::create_dir_all(\u0026project_output_dir)?;\n\n            let mut context = Context::new();\n            context.insert(\"project\", project);\n            context.insert(\"tasks\", tasks);\n            context.insert(\"resources\", resources);\n            context.insert(\"relative_path_prefix\", \"../../\");\n\n            // Render project detail page (e.g., project.html)\n            let project_html = self.tera.render(\"project.html\", \u0026context)?;\n            let project_page_path = project_output_dir.join(\"index.html\");\n            fs::write(project_page_path, project_html)?;\n\n            println!(\"✅ Project '{project_name}' page generated successfully.\");\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::fs::File;\n    use std::io::Write;\n    use tempfile::tempdir;\n\n    fn setup_test_environment() -\u003e PathBuf {\n        let temp_dir = tempdir().unwrap();\n        let root = temp_dir.path().to_path_buf();\n\n        // Create config.yaml\n        let config_content = r#\"\napiVersion: tasktaskrevolution.io/v1alpha1\nkind: Config\nmetadata:\n  createdAt: \"2024-01-01T00:00:00Z\"\nspec:\n  managerName: \"Test Manager\"\n  managerEmail: \"manager@test.com\"\n  defaultTimezone: \"America/Sao_Paulo\"\n\"#;\n        let mut config_file = File::create(root.join(\"config.yaml\")).unwrap();\n        writeln!(config_file, \"{config_content}\").unwrap();\n\n        // Create project subdirectory and project.yaml\n        let project_dir = root.join(\"my-project\");\n        fs::create_dir(\u0026project_dir).unwrap();\n        let project_content = r#\"\napiVersion: tasktaskrevolution.io/v1alpha1\nkind: Project\nmetadata:\n  code: \"proj-1\"\n  name: \"My Test Project\"\n  description: \"A description for the test project.\"\nspec:\n  status: \"InProgress\"\n  startDate: \"2024-08-01\"\n  endDate: \"2024-09-30\"\n\"#;\n        let mut project_file = File::create(project_dir.join(\"project.yaml\")).unwrap();\n        writeln!(project_file, \"{project_content}\").unwrap();\n\n        // Create tasks subdirectory\n        let tasks_dir = project_dir.join(\"tasks\");\n        fs::create_dir(\u0026tasks_dir).unwrap();\n\n        // Create a test task file\n        let task_content = r#\"\napi_version: v1\nkind: Task\nmetadata:\n  id: \"01901dea-3e4b-7698-b323-95232d306587\"\n  code: \"TSK-01\"\n  name: \"Design the API\"\n  description: \"A test task for the build process.\"\nspec:\n  projectCode: \"proj-1\"\n  assignee: \"dev-01\"\n  status: \"Planned\"\n  priority: \"Medium\"\n  estimatedStartDate: \"2024-08-05\"\n  estimatedEndDate: \"2024-08-10\"\n  dependencies: []\n  tags: []\n  effort:\n    estimatedHours: 8.0\n  acceptanceCriteria: []\n  comments: []\n\"#;\n        let mut task_file = File::create(tasks_dir.join(\"task1.yaml\")).unwrap();\n        writeln!(task_file, \"{task_content}\").unwrap();\n\n        // Create resources subdirectory\n        fs::create_dir(project_dir.join(\"resources\")).unwrap();\n\n        // Create a test resource file\n        let resource_content = r#\"\napiVersion: tasktaskrevolution.io/v1alpha1\nkind: Resource\nmetadata:\n  code: \"dev-01\"\n  name: \"Developer One\"\n  resourceType: \"Human\"\nspec:\n  email: \"dev1@example.com\"\n  timeOffBalance: 0\n\"#;\n        let mut resource_file = File::create(project_dir.join(\"resources\").join(\"dev1.yaml\")).unwrap();\n        writeln!(resource_file, \"{resource_content}\").unwrap();\n\n        // Create a second project, this one WITHOUT dates, to replicate the bug.\n        let project_dir_2 = root.join(\"project-no-dates\");\n        fs::create_dir(\u0026project_dir_2).unwrap();\n        let project_content_2 = r#\"\napiVersion: tasktaskrevolution.io/v1alpha1\nkind: Project\nmetadata:\n  code: \"proj-2\"\n  name: \"Project Without Dates\"\nspec:\n  status: \"Planned\"\n\"#;\n        let mut project_file_2 = File::create(project_dir_2.join(\"project.yaml\")).unwrap();\n        writeln!(project_file_2, \"{project_content_2}\").unwrap();\n        fs::create_dir(project_dir_2.join(\"tasks\")).unwrap();\n        fs::create_dir(project_dir_2.join(\"resources\")).unwrap();\n\n        // Persist the temporary directory for inspection after the test.\n        let _ = temp_dir.keep();\n        root\n    }\n\n    #[test]\n    fn test_build_use_case_finds_files_and_builds() {\n        // 1. Setup temporary directory with config and project files.\n        let temp_root = setup_test_environment();\n        let output_dir = temp_root.join(\"public\");\n\n        // 2. Create and execute the use case.\n        let use_case = BuildUseCase::new(temp_root, output_dir.to_str().unwrap()).unwrap();\n        let result = use_case.execute();\n        if let Err(e) = \u0026result {\n            // Provide more context on failure.\n            eprintln!(\"BuildUseCase::execute failed: {e}\");\n        }\n        assert!(result.is_ok());\n\n        // 3. Assert that the global index.html was created correctly.\n        let global_index_path = output_dir.join(\"index.html\");\n        assert!(global_index_path.exists(), \"Global index.html was not created\");\n        let global_index_content = fs::read_to_string(global_index_path).unwrap();\n        // Check the title of the global index page, which is composed by the base template.\n        // This ensures the dummy project context is correctly passed and rendered.\n        let title_content = global_index_content\n            .split_once(\"\u003ctitle\u003e\")\n            .and_then(|(_, after_title_tag)| after_title_tag.split_once(\"\u003c/title\u003e\"))\n            .map(|(content, _)| content)\n            .unwrap_or(\"\")\n            .trim();\n        assert!(\n            title_content.contains(\"Projects Dashboard\"),\n            \"The rendered title content ('{title_content}') did not contain 'Projects Dashboard'.\"\n        );\n        assert!(\n            global_index_content.contains(\"My Test Project\"),\n            \"Global index.html should list the test project\"\n        );\n\n        // 4. Assert that the project-specific detail page was created correctly.\n        let project_page_path = output_dir.join(\"projects\").join(\"proj-1\").join(\"index.html\");\n        assert!(project_page_path.exists(), \"Project detail page was not created\");\n        let project_page_content = fs::read_to_string(project_page_path).unwrap();\n        assert!(\n            project_page_content.contains(\"My Test Project\"),\n            \"Project page should contain project name\"\n        );\n        assert!(\n            project_page_content.contains(\"A description for the test project.\"),\n            \"Project page should contain project description\"\n        );\n        assert!(\n            project_page_content.contains(\"Developer One\"),\n            \"Project page should list the test resource\"\n        );\n        assert!(\n            project_page_content.contains(\"Design the API\"),\n            \"Project page should list the test task\"\n        );\n    }\n}\n","traces":[{"line":29,"address":[902516,901753,901024],"length":1,"stats":{"Line":1}},{"line":30,"address":[901072],"length":1,"stats":{"Line":1}},{"line":31,"address":[901153,901230,901323],"length":1,"stats":{"Line":3}},{"line":32,"address":[901392,901843],"length":1,"stats":{"Line":2}},{"line":33,"address":[901963,902421,901880],"length":1,"stats":{"Line":2}},{"line":34,"address":[902126,902400],"length":1,"stats":{"Line":1}},{"line":37,"address":[901583],"length":1,"stats":{"Line":1}},{"line":38,"address":[901444],"length":1,"stats":{"Line":1}},{"line":39,"address":[901475],"length":1,"stats":{"Line":1}},{"line":40,"address":[901520],"length":1,"stats":{"Line":1}},{"line":45,"address":[902560,908268,912919],"length":1,"stats":{"Line":1}},{"line":47,"address":[902613],"length":1,"stats":{"Line":1}},{"line":48,"address":[902817],"length":1,"stats":{"Line":0}},{"line":50,"address":[902744,902930],"length":1,"stats":{"Line":1}},{"line":53,"address":[903102,902979],"length":1,"stats":{"Line":2}},{"line":54,"address":[903171,913000],"length":1,"stats":{"Line":2}},{"line":55,"address":[913053,913138],"length":1,"stats":{"Line":2}},{"line":56,"address":[913419,913206],"length":1,"stats":{"Line":1}},{"line":60,"address":[903246],"length":1,"stats":{"Line":1}},{"line":61,"address":[912901,903296,903359],"length":1,"stats":{"Line":2}},{"line":64,"address":[903738],"length":1,"stats":{"Line":1}},{"line":65,"address":[903753,903829],"length":1,"stats":{"Line":2}},{"line":66,"address":[903869,903952,904409,912816],"length":1,"stats":{"Line":3}},{"line":67,"address":[904494,908623,912782],"length":1,"stats":{"Line":2}},{"line":68,"address":[908805,908888],"length":1,"stats":{"Line":2}},{"line":69,"address":[909091,909008],"length":1,"stats":{"Line":2}},{"line":71,"address":[909258],"length":1,"stats":{"Line":1}},{"line":72,"address":[909304,909367],"length":1,"stats":{"Line":2}},{"line":74,"address":[909474,912670,909382],"length":1,"stats":{"Line":2}},{"line":75,"address":[909881,909817,912379],"length":1,"stats":{"Line":2}},{"line":76,"address":[910137,910209],"length":1,"stats":{"Line":2}},{"line":78,"address":[910278,910342,910451],"length":1,"stats":{"Line":2}},{"line":79,"address":[910453],"length":1,"stats":{"Line":1}},{"line":80,"address":[910744],"length":1,"stats":{"Line":1}},{"line":81,"address":[910782,911084,911135],"length":1,"stats":{"Line":2}},{"line":82,"address":[911258],"length":1,"stats":{"Line":1}},{"line":84,"address":[910819],"length":1,"stats":{"Line":1}},{"line":85,"address":[911422,910857,911371],"length":1,"stats":{"Line":2}},{"line":86,"address":[911545],"length":1,"stats":{"Line":1}},{"line":88,"address":[910894],"length":1,"stats":{"Line":0}},{"line":89,"address":[911709,910932,911658],"length":1,"stats":{"Line":0}},{"line":90,"address":[911832],"length":1,"stats":{"Line":0}},{"line":92,"address":[910969],"length":1,"stats":{"Line":0}},{"line":93,"address":[911945,911996,911007],"length":1,"stats":{"Line":0}},{"line":94,"address":[912119],"length":1,"stats":{"Line":0}},{"line":98,"address":[910385],"length":1,"stats":{"Line":0}},{"line":101,"address":[910536],"length":1,"stats":{"Line":1}},{"line":105,"address":[904523],"length":1,"stats":{"Line":1}},{"line":106,"address":[904568],"length":1,"stats":{"Line":1}},{"line":108,"address":[904595],"length":1,"stats":{"Line":1}},{"line":110,"address":[117302,118192,117264,118145],"length":1,"stats":{"Line":3}},{"line":111,"address":[117381],"length":1,"stats":{"Line":1}},{"line":112,"address":[118173,117460,117386,117483],"length":1,"stats":{"Line":2}},{"line":113,"address":[117676,118151,117617],"length":1,"stats":{"Line":1}},{"line":114,"address":[118123,117822,117881],"length":1,"stats":{"Line":1}},{"line":115,"address":[118037],"length":1,"stats":{"Line":1}},{"line":119,"address":[904771],"length":1,"stats":{"Line":1}},{"line":120,"address":[904850],"length":1,"stats":{"Line":1}},{"line":123,"address":[904887,905148,905021],"length":1,"stats":{"Line":3}},{"line":125,"address":[905053,904980,904949,908613],"length":1,"stats":{"Line":2}},{"line":126,"address":[905180,908595,905107,905076],"length":1,"stats":{"Line":2}},{"line":129,"address":[905248],"length":1,"stats":{"Line":1}},{"line":131,"address":[908509,905331],"length":1,"stats":{"Line":1}},{"line":132,"address":[905629,905716,908453],"length":1,"stats":{"Line":2}},{"line":133,"address":[905942],"length":1,"stats":{"Line":1}},{"line":136,"address":[905995],"length":1,"stats":{"Line":1}},{"line":137,"address":[908396,906081,906148],"length":1,"stats":{"Line":2}},{"line":139,"address":[906271],"length":1,"stats":{"Line":1}},{"line":140,"address":[906708,906480],"length":1,"stats":{"Line":2}},{"line":141,"address":[906724],"length":1,"stats":{"Line":1}},{"line":142,"address":[906787],"length":1,"stats":{"Line":1}},{"line":144,"address":[906958],"length":1,"stats":{"Line":1}},{"line":145,"address":[907107,908343,907040],"length":1,"stats":{"Line":2}},{"line":147,"address":[907222],"length":1,"stats":{"Line":1}},{"line":148,"address":[907249],"length":1,"stats":{"Line":1}},{"line":149,"address":[907328],"length":1,"stats":{"Line":1}},{"line":150,"address":[907363],"length":1,"stats":{"Line":1}},{"line":151,"address":[907390],"length":1,"stats":{"Line":1}},{"line":154,"address":[907438,908290],"length":1,"stats":{"Line":1}},{"line":155,"address":[907736,907816],"length":1,"stats":{"Line":2}},{"line":156,"address":[907848,908203],"length":1,"stats":{"Line":1}},{"line":158,"address":[908042],"length":1,"stats":{"Line":1}},{"line":161,"address":[906506],"length":1,"stats":{"Line":1}}],"covered":75,"coverable":83},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","create","mod.rs"],"content":"pub mod project;\npub mod resource;\npub mod task;\npub mod time_off;\npub mod vacation;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","create","project.rs"],"content":"use crate::domain::{\n    project_management::{builder::ProjectBuilder, repository::ProjectRepository},\n    shared::errors::DomainError,\n};\n\npub struct CreateProjectUseCase\u003cR: ProjectRepository\u003e {\n    repository: R,\n}\n\nimpl\u003cR: ProjectRepository\u003e CreateProjectUseCase\u003cR\u003e {\n    pub fn new(repository: R) -\u003e Self {\n        Self { repository }\n    }\n\n    pub fn execute(\u0026self, name: \u0026str, description: Option\u003c\u0026str\u003e) -\u003e Result\u003c(), DomainError\u003e {\n        let code = self.repository.get_next_code()?;\n\n        // Use the typestate builder for type safety\n        let mut project = ProjectBuilder::new(name.to_string())\n            .code(code)\n            .end_date(\"2024-12-31\".to_string()); // Required for WithDates state\n\n        // Add description if provided\n        if let Some(desc) = description {\n            project = project.description(Some(desc.to_string()));\n        }\n\n        let project = project.build(); // This returns Project\u003cPlanned\u003e (legacy method)\n\n        self.repository.save(project.into())?;\n        println!(\"Projeto {name} criado\");\n        Ok(())\n    }\n\n    #[allow(dead_code)]\n    #[cfg(test)]\n    pub fn get_repository(\u0026self) -\u003e \u0026R {\n        \u0026self.repository\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::domain::project_management::{AnyProject, builder::ProjectBuilder};\n    use crate::domain::shared::errors::DomainError;\n    use crate::domain::shared::errors::DomainErrorKind;\n    use std::cell::RefCell;\n\n    struct MockProjectRepository {\n        should_fail: bool,\n        saved_config: RefCell\u003cOption\u003cAnyProject\u003e\u003e,\n        project: AnyProject,\n    }\n\n    impl MockProjectRepository {\n        fn new(should_fail: bool) -\u003e Self {\n            Self {\n                should_fail,\n                saved_config: RefCell::new(None),\n                project: ProjectBuilder::new(\"John\".to_string())\n                    .code(\"proj-1\".to_string())\n                    .end_date(\"2024-12-31\".to_string())\n                    .build()\n                    .into(),\n            }\n        }\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            if self.should_fail {\n                return Err(DomainError::new(DomainErrorKind::Generic {\n                    message: \"Erro mockado ao salvar\".to_string(),\n                }));\n            }\n            *self.saved_config.borrow_mut() = Some(project);\n            Ok(())\n        }\n\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            Ok(self.project.clone())\n        }\n\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(\"proj-1\".to_string()) // Always return a fixed code for tests\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(vec![self.project.clone()])\n        }\n\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            if self.project.code() == code {\n                Ok(Some(self.project.clone()))\n            } else {\n                Ok(None)\n            }\n        }\n    }\n\n    #[test]\n    fn test_create_project_success() {\n        let mock_repo = MockProjectRepository::new(false);\n        let use_case = CreateProjectUseCase::new(mock_repo);\n        let name = \"John\";\n        let description = Some(\"a simple test project\");\n\n        let result = use_case.execute(name, description);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_create_project_failure() {\n        let mock_repo = MockProjectRepository::new(true);\n        let use_case = CreateProjectUseCase::new(mock_repo);\n        let name = \"John\";\n        let description = Some(\"a simple test project\");\n\n        let result = use_case.execute(name, description);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_verify_config_saved() {\n        let mock_repo = MockProjectRepository::new(false);\n        let use_case = CreateProjectUseCase::new(mock_repo);\n        let name = \"John\";\n        let description = Some(\"a simple test project\");\n        let _ = use_case.execute(name, description);\n\n        let saved_config = use_case.get_repository().saved_config.borrow();\n        assert!(saved_config.is_some());\n        let any_project = saved_config.as_ref().unwrap();\n        assert_eq!(any_project.name(), name);\n        if let AnyProject::Planned(p) = any_project {\n            assert_eq!(p.description.as_deref(), description);\n        } else {\n            panic!(\"Expected Planned project\");\n        }\n    }\n}\n","traces":[{"line":11,"address":[2052720,2052688],"length":1,"stats":{"Line":2}},{"line":15,"address":[2055345,2054064,2054033,2052752,2054951,2053639],"length":1,"stats":{"Line":1}},{"line":16,"address":[2052802,2054114],"length":1,"stats":{"Line":1}},{"line":19,"address":[2054396,2052998,2053236,2053084,2054310,2054548],"length":1,"stats":{"Line":5}},{"line":20,"address":[2053091,2054403],"length":1,"stats":{"Line":2}},{"line":21,"address":[2053268,2053195,2054023,2054507,2054580,2055335,2054476,2053164],"length":1,"stats":{"Line":2}},{"line":24,"address":[2054928,2053616,2054595,2053283],"length":1,"stats":{"Line":4}},{"line":25,"address":[2053347,2054941,2054659,2054782,2053470,2053629],"length":1,"stats":{"Line":1}},{"line":28,"address":[2054758,2053446],"length":1,"stats":{"Line":1}},{"line":30,"address":[2054003,2054957,2055315,2053645],"length":1,"stats":{"Line":3}},{"line":31,"address":[2053877,2055189],"length":1,"stats":{"Line":1}},{"line":32,"address":[2053975,2055287],"length":1,"stats":{"Line":1}},{"line":37,"address":[2055376],"length":1,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":0}}],"covered":13,"coverable":14},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","create","resource.rs"],"content":"use crate::domain::{\n    resource_management::{repository::ResourceRepository, resource::Resource},\n    shared::errors::DomainError,\n};\n\npub struct CreateResourceUseCase\u003cR: ResourceRepository\u003e {\n    repository: R,\n}\n\nimpl\u003cR: ResourceRepository\u003e CreateResourceUseCase\u003cR\u003e {\n    pub fn new(repository: R) -\u003e Self {\n        Self { repository }\n    }\n    pub fn execute(\u0026self, name: \u0026str, resource_type: \u0026str) -\u003e Result\u003c(), DomainError\u003e {\n        let code = self.repository.get_next_code(resource_type)?;\n        let r = Resource::new(code, name.to_string(), None, resource_type.to_string(), None, 0);\n        self.repository.save(r.into())?;\n        println!(\"Recurso {name} criado.\");\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::domain::resource_management::AnyResource;\n    use crate::domain::shared::errors::DomainError;\n    use crate::domain::shared::errors::DomainErrorKind;\n    use chrono::{DateTime, Local};\n    use std::cell::RefCell;\n\n    struct MockResourceRepository {\n        should_fail: bool,\n        saved_config: RefCell\u003cOption\u003cAnyResource\u003e\u003e,\n    }\n\n    impl MockResourceRepository {\n        fn new(should_fail: bool) -\u003e Self {\n            Self {\n                should_fail,\n                saved_config: RefCell::new(None),\n            }\n        }\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn save(\u0026self, resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            if self.should_fail {\n                return Err(DomainError::new(DomainErrorKind::Generic {\n                    message: \"Erro mockado ao salvar\".to_string(),\n                }));\n            }\n            *self.saved_config.borrow_mut() = Some(resource.clone());\n\n            Ok(resource)\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(vec![])\n        }\n\n        fn find_by_code(\u0026self, _code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(None)\n        }\n\n        fn save_time_off(\n            \u0026self,\n            _resource_name: \u0026str,\n            _hours: u32,\n            _date: \u0026str,\n            _description: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!(\"Not needed for these tests\")\n        }\n\n        fn save_vacation(\n            \u0026self,\n            _resource_name: \u0026str,\n            _start_date: \u0026str,\n            _end_date: \u0026str,\n            _is_time_off_compensation: bool,\n            _compensated_hours: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!(\"Not needed for these tests\")\n        }\n\n        fn check_if_layoff_period(\u0026self, _start_date: \u0026DateTime\u003cLocal\u003e, _end_date: \u0026DateTime\u003cLocal\u003e) -\u003e bool {\n            false\n        }\n\n        fn get_next_code(\u0026self, resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(format!(\"{}-1\", resource_type.to_lowercase()))\n        }\n    }\n\n    #[test]\n    fn test_create_project_success() {\n        let mock_repo = MockResourceRepository::new(false);\n        let use_case = CreateResourceUseCase::new(mock_repo);\n        let name = \"John\";\n        let resource_type = \"Developer\";\n\n        let result = use_case.execute(name, resource_type);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_create_project_failure() {\n        let mock_repo = MockResourceRepository::new(true);\n        let use_case = CreateResourceUseCase::new(mock_repo);\n        let name = \"John\";\n        let resource_type = \"Developer\";\n\n        let result = use_case.execute(name, resource_type);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_verify_config_saved() {\n        let mock_repo = MockResourceRepository::new(false);\n        let use_case = CreateResourceUseCase::new(mock_repo);\n        let name = \"John\";\n        let resource_type = \"Developer\";\n        let _ = use_case.execute(name, resource_type);\n\n        let saved_config = use_case.repository.saved_config.borrow();\n        assert!(saved_config.is_some());\n        let any_resource = saved_config.as_ref().unwrap();\n        assert_eq!(any_resource.name(), name);\n        if let AnyResource::Available(r) = any_resource {\n            assert_eq!(r.resource_type, resource_type);\n            assert_eq!(r.code, \"developer-1\");\n        } else {\n            panic!(\"Expected Available resource\");\n        }\n    }\n}\n","traces":[{"line":11,"address":[2309136,2309168],"length":1,"stats":{"Line":3}},{"line":14,"address":[2311753,2310496,2311703,2309200,2310457,2310407],"length":1,"stats":{"Line":3}},{"line":15,"address":[2309295,2310591],"length":1,"stats":{"Line":3}},{"line":16,"address":[2311709,2310373,2310413,2310884,2309588,2310988,2310810,2311669,2309514,2309692],"length":1,"stats":{"Line":3}},{"line":17,"address":[2309955,2311251,2309863,2311159,2311657,2310361],"length":1,"stats":{"Line":7}},{"line":18,"address":[2310235,2311531],"length":1,"stats":{"Line":2}},{"line":19,"address":[2311629,2310333],"length":1,"stats":{"Line":2}}],"covered":7,"coverable":7},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","create","task.rs"],"content":"use crate::domain::{\n    project_management::repository::ProjectRepository,\n    shared::errors::{DomainError, DomainErrorKind},\n    task_management::TaskBuilder,\n};\nuse chrono::NaiveDate;\n\npub struct CreateTaskArgs {\n    pub project_code: String,\n\n    pub name: String,\n\n    pub start_date: NaiveDate,\n    pub due_date: NaiveDate,\n    pub assigned_resources: Vec\u003cString\u003e,\n}\n\npub struct CreateTaskUseCase\u003cR: ProjectRepository\u003e {\n    repository: R,\n}\n\nimpl\u003cR: ProjectRepository\u003e CreateTaskUseCase\u003cR\u003e {\n    pub fn new(repository: R) -\u003e Self {\n        Self { repository }\n    }\n\n    pub fn execute(\u0026self, args: CreateTaskArgs) -\u003e Result\u003c(), DomainError\u003e {\n        let CreateTaskArgs {\n            project_code,\n\n            name,\n\n            start_date,\n            due_date,\n            assigned_resources,\n        } = args;\n\n        // 1. Load the project aggregate.\n        let mut project = self.repository.find_by_code(\u0026project_code)?.ok_or_else(|| {\n            DomainError::new(DomainErrorKind::ProjectNotFound {\n                code: project_code.clone(),\n            })\n        })?;\n\n        // 2. Delegate task creation to the project aggregate.\n        // This is a placeholder for the future implementation of `project.add_task(...)`\n        // For now, we'll keep the builder logic here.\n        if start_date \u003e due_date {\n            return Err(DomainError::new(DomainErrorKind::Generic {\n                message: \"Data de início não pode ser posterior à data de vencimento\".to_string(),\n            }));\n        }\n\n        let next_task_code = format!(\"task-{}\", project.tasks().len() + 1);\n\n        let builder = TaskBuilder::new()\n            .project_code(project_code)\n            .name(name.clone())\n            .code(next_task_code)\n            .dates(start_date, due_date)\n            .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n\n        let task = if assigned_resources.is_empty() {\n            builder\n                .validate_vacations(\u0026[])\n                .unwrap()\n                .build()\n                .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))\n        } else {\n            let mut iter = assigned_resources.into_iter();\n            let builder_with_res = builder.assign_resource(iter.next().unwrap());\n            let final_builder = iter.fold(builder_with_res, |b, r| b.assign_resource(r));\n            final_builder\n                .validate_vacations(\u0026[])\n                .unwrap()\n                .build()\n                .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))\n        }?;\n\n        // Add the task to the project (this part will be moved into a project method later)\n        project.add_task(task.into());\n\n        // 3. Save the entire project aggregate.\n        self.repository.save(project)?;\n\n        println!(\"Task {name} criada com sucesso.\");\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::domain::project_management::{AnyProject, builder::ProjectBuilder};\n    use chrono::NaiveDate;\n    use std::cell::RefCell;\n    use std::collections::HashMap;\n\n    struct MockProjectRepository {\n        should_fail: bool,\n        projects: RefCell\u003cHashMap\u003cString, AnyProject\u003e\u003e,\n    }\n\n    impl MockProjectRepository {\n        fn new(should_fail: bool) -\u003e Self {\n            let mut projects = HashMap::new();\n            let project = ProjectBuilder::new(\"Test Project\".to_string())\n                .code(\"PROJ-1\".to_string())\n                .build()\n                .into();\n            projects.insert(\"PROJ-1\".to_string(), project);\n\n            Self {\n                should_fail,\n                projects: RefCell::new(projects),\n            }\n        }\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            if self.should_fail {\n                return Err(DomainError::new(DomainErrorKind::Generic {\n                    message: \"Erro mockado ao salvar\".to_string(),\n                }));\n            }\n            self.projects.borrow_mut().insert(project.code().to_string(), project);\n            Ok(())\n        }\n\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().get(code).cloned())\n        }\n\n        // Unimplemented methods\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    fn create_test_dates() -\u003e (NaiveDate, NaiveDate) {\n        let start_date = NaiveDate::from_ymd_opt(2024, 1, 15).unwrap();\n        let due_date = NaiveDate::from_ymd_opt(2024, 1, 30).unwrap();\n        (start_date, due_date)\n    }\n\n    #[test]\n    fn test_create_task_success() {\n        let mock_repo = MockProjectRepository::new(false);\n        let use_case = CreateTaskUseCase::new(mock_repo);\n        let (start_date, due_date) = create_test_dates();\n\n        let args = CreateTaskArgs {\n            project_code: \"PROJ-1\".to_string(),\n            name: \"Implementar autenticação\".to_string(),\n            start_date,\n            due_date,\n            assigned_resources: vec![\"dev1\".to_string()],\n        };\n        let result = use_case.execute(args);\n\n        assert!(result.is_ok());\n        let project = use_case.repository.find_by_code(\"PROJ-1\").unwrap().unwrap();\n        assert_eq!(project.tasks().len(), 1);\n        assert_eq!(\n            project.tasks().get(\"task-1\").unwrap().name(),\n            \"Implementar autenticação\"\n        );\n    }\n\n    #[test]\n    fn test_create_task_fails_if_project_not_found() {\n        let mock_repo = MockProjectRepository::new(false);\n        let use_case = CreateTaskUseCase::new(mock_repo);\n        let (start_date, due_date) = create_test_dates();\n\n        let args = CreateTaskArgs {\n            project_code: \"PROJ-NONEXISTENT\".to_string(),\n            name: \"Task for nonexistent project\".to_string(),\n            start_date,\n            due_date,\n            assigned_resources: vec![],\n        };\n        let result = use_case.execute(args);\n\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":23,"address":[1105376,1105408],"length":1,"stats":{"Line":1}},{"line":27,"address":[1108371,1105440,1109856,1109813,1114229,1112787],"length":1,"stats":{"Line":1}},{"line":28,"address":[1105502,1109918],"length":1,"stats":{"Line":1}},{"line":29,"address":[1105574,1109990],"length":1,"stats":{"Line":1}},{"line":31,"address":[1105605,1110021],"length":1,"stats":{"Line":1}},{"line":33,"address":[1110045,1105629],"length":1,"stats":{"Line":1}},{"line":34,"address":[1105639,1110055],"length":1,"stats":{"Line":1}},{"line":35,"address":[1105649,1110065],"length":1,"stats":{"Line":1}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[1110614,1109702,1110105,1114272,1106198,1114118,1114384,1105785,1110201,1105689],"length":1,"stats":{"Line":5}},{"line":40,"address":[1114429,1114317],"length":1,"stats":{"Line":1}},{"line":41,"address":[1114290,1114402],"length":1,"stats":{"Line":1}},{"line":48,"address":[1110717,1110793,1106377,1106301],"length":1,"stats":{"Line":2}},{"line":49,"address":[1109551,1113967],"length":1,"stats":{"Line":0}},{"line":50,"address":[1110819,1106403],"length":1,"stats":{"Line":0}},{"line":54,"address":[1106391,1106442,1110807,1110858],"length":1,"stats":{"Line":2}},{"line":56,"address":[1106851,1107045,1111461,1113906,1106649,1107197,1109490,1111613,1111065,1111267],"length":1,"stats":{"Line":3}},{"line":57,"address":[1106697,1111113],"length":1,"stats":{"Line":1}},{"line":58,"address":[1106776,1111299,1111192,1113935,1109519,1106883],"length":1,"stats":{"Line":2}},{"line":59,"address":[1106898,1111314],"length":1,"stats":{"Line":1}},{"line":60,"address":[1106969,1111385],"length":1,"stats":{"Line":1}},{"line":61,"address":[1107022,1111438,1114523,1107101,1114683,1111517,1114656,1114496],"length":1,"stats":{"Line":1}},{"line":63,"address":[1108346,1113041,1113868,1108480,1107554,1112762,1112896,1108625,1107486,1109452,1111970,1111902],"length":1,"stats":{"Line":4}},{"line":64,"address":[1107630,1112891,1108475,1112046],"length":1,"stats":{"Line":0}},{"line":65,"address":[1107791,1112207],"length":1,"stats":{"Line":0}},{"line":68,"address":[1115003,1108468,1112884,1114976,1114843,1114816],"length":1,"stats":{"Line":0}},{"line":70,"address":[1111976,1107801,1107560,1112217],"length":1,"stats":{"Line":2}},{"line":71,"address":[1107809,1108361,1112225,1112777],"length":1,"stats":{"Line":1}},{"line":72,"address":[1115200,1108102,1112518,1115179,1115136,1115243],"length":1,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[1108239,1112655],"length":1,"stats":{"Line":1}},{"line":77,"address":[1115424,1115291,1115451,1108315,1112731,1115264],"length":1,"stats":{"Line":1}},{"line":81,"address":[1108748,1108855,1113271,1113164],"length":1,"stats":{"Line":2}},{"line":84,"address":[1113278,1109422,1113838,1108862],"length":1,"stats":{"Line":1}},{"line":86,"address":[1109117,1113533],"length":1,"stats":{"Line":1}},{"line":87,"address":[1109221,1113637],"length":1,"stats":{"Line":1}}],"covered":29,"coverable":36},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","create","time_off.rs"],"content":"use crate::domain::{\n    resource_management::repository::ResourceRepository,\n    shared::errors::{DomainError, DomainErrorKind},\n};\nuse chrono::{DateTime, Local, NaiveDate, TimeZone};\n\npub struct CreateTimeOffUseCase\u003cR: ResourceRepository\u003e {\n    repository: R,\n}\n\n#[derive(Debug)]\npub struct CreateTimeOffResult {\n    pub success: bool,\n    pub message: String,\n    pub time_off_balance: u32,\n    pub description: Option\u003cString\u003e,\n    pub date: String,\n}\n\nimpl\u003cR: ResourceRepository\u003e CreateTimeOffUseCase\u003cR\u003e {\n    pub fn new(repository: R) -\u003e Self {\n        Self { repository }\n    }\n\n    fn parse_date(date_str: \u0026str) -\u003e Result\u003cDateTime\u003cLocal\u003e, DomainError\u003e {\n        let naive = NaiveDate::parse_from_str(date_str, \"%Y-%m-%d\")\n            .map_err(|_| {\n                DomainError::new(DomainErrorKind::Generic {\n                    message: \"Formato de data inválido. Use YYYY-MM-DD\".to_string(),\n                })\n            })?\n            .and_hms_opt(0, 0, 0)\n            .ok_or_else(|| {\n                DomainError::new(DomainErrorKind::Generic {\n                    message: \"Erro ao converter hora\".to_string(),\n                })\n            })?;\n\n        Local.from_local_datetime(\u0026naive).earliest().ok_or_else(|| {\n            DomainError::new(DomainErrorKind::Generic {\n                message: \"Erro ao converter data local\".to_string(),\n            })\n        })\n    }\n\n    pub fn execute(\n        \u0026self,\n        resource: \u0026str,\n        hours: u32,\n        date: \u0026str,\n        description: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cCreateTimeOffResult, Box\u003cdyn std::error::Error\u003e\u003e {\n        // Validate date format first\n        Self::parse_date(date)?;\n\n        match self\n            .repository\n            .save_time_off(resource, hours, date, description.map(|d| d.to_string()))\n        {\n            Ok(resource) =\u003e Ok(CreateTimeOffResult {\n                success: true,\n                message: format!(\"{} horas adicionadas com sucesso para {}\", hours, resource.name()),\n                time_off_balance: resource.time_off_balance(),\n                description: description.map(|d| d.to_string()),\n                date: date.to_string(),\n            }),\n            Err(e) =\u003e Err(Box::new(e)),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        resource_management::{AnyResource, resource::Resource, state::Available},\n        shared::errors::DomainError,\n    };\n    use std::cell::RefCell;\n\n    struct MockResourceRepository {\n        resources: RefCell\u003cVec\u003cAnyResource\u003e\u003e,\n    }\n\n    impl MockResourceRepository {\n        fn new(resources: Vec\u003cAnyResource\u003e) -\u003e Self {\n            Self {\n                resources: RefCell::new(resources),\n            }\n        }\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn save(\u0026self, resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            let mut resources = self.resources.borrow_mut();\n            if let Some(index) = resources.iter().position(|r| r.id() == resource.id()) {\n                resources[index] = resource.clone();\n            } else {\n                resources.push(resource.clone());\n            }\n            Ok(resource)\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.borrow().clone())\n        }\n\n        fn find_by_code(\u0026self, _code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(None)\n        }\n\n        fn save_time_off(\n            \u0026self,\n            resource_name: \u0026str,\n            hours: u32,\n            _date: \u0026str,\n            _description: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            // Force error for specific test case\n            if resource_name == \"error_resource\" {\n                return Err(DomainError::new(DomainErrorKind::Generic {\n                    message: \"Simulated repository error\".to_string(),\n                }));\n            }\n\n            let mut resources = self.resources.borrow_mut();\n            let resource_any = resources\n                .iter_mut()\n                .find(|r| r.name() == resource_name)\n                .ok_or_else(|| {\n                    DomainError::new(DomainErrorKind::ResourceNotFound {\n                        code: \"Resource not found\".to_string(),\n                    })\n                })?;\n\n            let updated = match resource_any {\n                AnyResource::Available(r) =\u003e {\n                    let mut updated_r = r.clone();\n                    updated_r.time_off_balance += hours;\n                    AnyResource::Available(updated_r)\n                }\n                AnyResource::Assigned(r) =\u003e {\n                    let mut updated_r = r.clone();\n                    updated_r.time_off_balance += hours;\n                    AnyResource::Assigned(updated_r)\n                }\n                AnyResource::Inactive(_) =\u003e {\n                    return Err(DomainError::new(DomainErrorKind::ResourceInvalidState {\n                        current: \"Inactive\".to_string(),\n                        expected: \"Active\".to_string(),\n                    }));\n                }\n            };\n            *resource_any = updated.clone();\n            Ok(updated)\n        }\n\n        fn save_vacation(\n            \u0026self,\n            _resource_name: \u0026str,\n            _start_date: \u0026str,\n            _end_date: \u0026str,\n            _is_time_off_compensation: bool,\n            _compensated_hours: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!(\"Not needed for these tests\")\n        }\n\n        fn check_if_layoff_period(\u0026self, _start_date: \u0026DateTime\u003cLocal\u003e, _end_date: \u0026DateTime\u003cLocal\u003e) -\u003e bool {\n            false\n        }\n\n        fn get_next_code(\u0026self, resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(format!(\"{}-1\", resource_type.to_lowercase()))\n        }\n    }\n\n    fn create_test_available_resource() -\u003e AnyResource {\n        Resource::\u003cAvailable\u003e::new(\n            \"developer-1\".to_string(), // dummy code\n            \"John Doe\".to_string(),\n            None,\n            \"Developer\".to_string(),\n            None,\n            0,\n        )\n        .into()\n    }\n\n    #[test]\n    fn test_create_time_off_success() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"John Doe\", 10, \"2024-01-01\", Some(\"Test time off\"));\n\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, 10);\n    }\n\n    #[test]\n    fn test_create_time_off_nonexistent_resource() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"nonexistent\", 10, \"2024-01-01\", Some(\"Test time off\"));\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_create_time_off_accumulates_balance() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        // First entry\n        let result1 = use_case.execute(\"John Doe\", 4, \"2024-01-01\", Some(\"Manhã\"));\n        assert!(result1.is_ok());\n        assert_eq!(result1.unwrap().time_off_balance, 4);\n\n        // Second entry\n        let result2 = use_case.execute(\"John Doe\", 4, \"2024-01-02\", Some(\"Tarde\"));\n        assert!(result2.is_ok());\n\n        let final_resource = result2.unwrap();\n        assert_eq!(final_resource.time_off_balance, 8);\n    }\n\n    #[test]\n    fn test_create_time_off_repository_error() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"error_resource\", 10, \"2024-01-01\", Some(\"Test time off\"));\n\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err().to_string(), \"Simulated repository error\");\n    }\n\n    #[test]\n    fn test_create_time_off_with_empty_description() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"John Doe\", 10, \"2024-01-01\", None);\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, 10);\n        assert!(updated_resource.description.is_none());\n    }\n\n    #[test]\n    fn test_create_time_off_with_invalid_date_format() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        // Test with invalid date format - should fail at parse_date\n        let result = use_case.execute(\"John Doe\", 10, \"invalid-date\", Some(\"Test time off\"));\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"Formato de data inválido\"));\n    }\n\n    #[test]\n    fn test_create_time_off_with_invalid_date_format_2() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        // Test with invalid date format - should fail at parse_date\n        let result = use_case.execute(\"John Doe\", 10, \"01/01/2024\", Some(\"Test time off\"));\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"Formato de data inválido\"));\n    }\n\n    #[test]\n    fn test_create_time_off_with_malformed_date() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        // Test with malformed date that might cause hour conversion issues\n        let result = use_case.execute(\"John Doe\", 10, \"2024-13-45\", Some(\"Test time off\"));\n        assert!(result.is_err());\n        // This should fail at date parsing, not at hour conversion\n        assert!(result.unwrap_err().to_string().contains(\"Formato de data inválido\"));\n    }\n\n    #[test]\n    fn test_create_time_off_with_edge_case_dates() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        // Test with valid edge case dates\n        let result1 = use_case.execute(\"John Doe\", 10, \"2024-01-01\", Some(\"New Year\"));\n        assert!(result1.is_ok());\n\n        let result2 = use_case.execute(\"John Doe\", 10, \"2024-12-31\", Some(\"Year End\"));\n        assert!(result2.is_ok());\n\n        let result3 = use_case.execute(\"John Doe\", 10, \"2024-02-29\", Some(\"Leap Year\"));\n        assert!(result3.is_ok());\n    }\n\n    #[test]\n    fn test_create_time_off_with_special_characters_in_description() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"John Doe\", 10, \"2024-01-01\", Some(\"Test with special chars: !@#$%^\u0026*()\"));\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, 10);\n        assert_eq!(updated_resource.description, Some(\"Test with special chars: !@#$%^\u0026*()\".to_string()));\n    }\n\n    #[test]\n    fn test_create_time_off_with_zero_hours() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"John Doe\", 0, \"2024-01-01\", Some(\"Zero hours\"));\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, 0);\n    }\n\n    #[test]\n    fn test_create_time_off_with_large_hours() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"John Doe\", 999999, \"2024-01-01\", Some(\"Large hours\"));\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, 999999);\n    }\n\n    #[test]\n    fn test_create_time_off_with_max_u32_hours() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"John Doe\", u32::MAX, \"2024-01-01\", Some(\"Max hours\"));\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, u32::MAX);\n    }\n\n    #[test]\n    fn test_create_time_off_with_edge_case_time_conversion() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        // Test with dates that might cause time conversion issues\n        // These dates should be valid but test edge cases\n        let result1 = use_case.execute(\"John Doe\", 10, \"2024-01-01\", Some(\"Start of year\"));\n        assert!(result1.is_ok());\n\n        let result2 = use_case.execute(\"John Doe\", 10, \"2024-12-31\", Some(\"End of year\"));\n        assert!(result2.is_ok());\n\n        let result3 = use_case.execute(\"John Doe\", 10, \"2024-06-15\", Some(\"Mid year\"));\n        assert!(result3.is_ok());\n    }\n\n    #[test]\n    fn test_create_time_off_with_different_timezone_scenarios() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        // Test with dates that might have different timezone implications\n        let result1 = use_case.execute(\"John Doe\", 10, \"2024-03-10\", Some(\"DST start\"));\n        assert!(result1.is_ok());\n\n        let result2 = use_case.execute(\"John Doe\", 10, \"2024-11-03\", Some(\"DST end\"));\n        assert!(result2.is_ok());\n\n        let result3 = use_case.execute(\"John Doe\", 10, \"2024-07-04\", Some(\"Summer date\"));\n        assert!(result3.is_ok());\n    }\n\n    #[test]\n    fn test_create_time_off_with_very_short_description() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"John Doe\", 10, \"2024-01-01\", Some(\"\"));\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, 10);\n        assert_eq!(updated_resource.description, Some(\"\".to_string()));\n    }\n\n    #[test]\n    fn test_create_time_off_with_numeric_description() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"John Doe\", 10, \"2024-01-01\", Some(\"12345\"));\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, 10);\n        assert_eq!(updated_resource.description, Some(\"12345\".to_string()));\n    }\n\n    #[test]\n    fn test_create_time_off_with_inactive_resource() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        // This should fail because the mock repository doesn't have an inactive resource\n        // but we can test the error handling path\n        let result = use_case.execute(\"inactive_resource\", 10, \"2024-01-01\", Some(\"Test\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_create_time_off_with_very_long_description() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let long_description = \"A\".repeat(1000); // Very long description\n        let result = use_case.execute(\"John Doe\", 10, \"2024-01-01\", Some(\u0026long_description));\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, 10);\n        assert_eq!(updated_resource.description, Some(long_description));\n    }\n\n    #[test]\n    fn test_create_time_off_with_unicode_description() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let unicode_description = \"Férias com emojis 🏖️🌴☀️ e acentos: áéíóú çãõ\";\n        let result = use_case.execute(\"John Doe\", 10, \"2024-01-01\", Some(unicode_description));\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, 10);\n        assert_eq!(updated_resource.description, Some(unicode_description.to_string()));\n    }\n\n    #[test]\n    fn test_create_time_off_with_boundary_dates() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        // Test with boundary dates\n        let result1 = use_case.execute(\"John Doe\", 10, \"1900-01-01\", Some(\"Very old date\"));\n        assert!(result1.is_ok());\n\n        let result2 = use_case.execute(\"John Doe\", 10, \"2100-12-31\", Some(\"Future date\"));\n        assert!(result2.is_ok());\n\n        let result3 = use_case.execute(\"John Doe\", 10, \"2000-02-29\", Some(\"Leap year\"));\n        assert!(result3.is_ok());\n    }\n\n    #[test]\n    fn test_create_time_off_with_single_character_name() {\n        let repository = MockResourceRepository::new(vec![create_test_available_resource()]);\n        let use_case = CreateTimeOffUseCase::new(repository);\n\n        let result = use_case.execute(\"John Doe\", 10, \"2024-01-01\", Some(\"Single char name\"));\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.time_off_balance, 10);\n    }\n}\n","traces":[{"line":21,"address":[815728,815760],"length":1,"stats":{"Line":7}},{"line":25,"address":[816352,815808],"length":1,"stats":{"Line":7}},{"line":26,"address":[816411,816194,816738,816667,815946,816490,816570,815867,816026,816123],"length":1,"stats":{"Line":19}},{"line":27,"address":[815933,817008,816477,816896],"length":1,"stats":{"Line":10}},{"line":28,"address":[816943,817055],"length":1,"stats":{"Line":1}},{"line":29,"address":[817028,816916],"length":1,"stats":{"Line":2}},{"line":33,"address":[816102,817120,816646,817232],"length":1,"stats":{"Line":6}},{"line":34,"address":[817160,817272],"length":1,"stats":{"Line":0}},{"line":35,"address":[817133,817245],"length":1,"stats":{"Line":0}},{"line":39,"address":[816264,817456,816808,817344],"length":1,"stats":{"Line":3}},{"line":40,"address":[817496,817384],"length":1,"stats":{"Line":0}},{"line":41,"address":[817469,817357],"length":1,"stats":{"Line":0}},{"line":46,"address":[820038,818790,817568,820044,818796,818816],"length":1,"stats":{"Line":7}},{"line":54,"address":[817730,818978],"length":1,"stats":{"Line":7}},{"line":56,"address":[819222,817974],"length":1,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[817890,820086,820134,819138,820064,820112],"length":1,"stats":{"Line":10}},{"line":60,"address":[819376,818128,818587,819835],"length":1,"stats":{"Line":7}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[818135,818202,819383,819450],"length":1,"stats":{"Line":7}},{"line":63,"address":[819676,818428],"length":1,"stats":{"Line":1}},{"line":64,"address":[820160,820208,818501,820182,820230,819749],"length":1,"stats":{"Line":6}},{"line":65,"address":[819766,818518],"length":1,"stats":{"Line":3}},{"line":67,"address":[819259,818011],"length":1,"stats":{"Line":2}}],"covered":18,"coverable":24},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","create","vacation.rs"],"content":"use crate::domain::resource_management::repository::ResourceRepository;\n\npub struct CreateVacationUseCase\u003cR: ResourceRepository\u003e {\n    repository: R,\n}\n\n#[derive(Debug, PartialEq)]\npub struct CreateVacationResult {\n    pub success: bool,\n    pub message: String,\n}\n\nimpl\u003cR: ResourceRepository\u003e CreateVacationUseCase\u003cR\u003e {\n    pub fn new(repository: R) -\u003e Self {\n        Self { repository }\n    }\n\n    fn validate_dates(start_date: \u0026str, end_date: \u0026str) -\u003e bool {\n        if let (Ok(start), Ok(end)) = (\n            chrono::NaiveDate::parse_from_str(start_date, \"%Y-%m-%d\"),\n            chrono::NaiveDate::parse_from_str(end_date, \"%Y-%m-%d\"),\n        ) {\n            start \u003c= end\n        } else {\n            false\n        }\n    }\n\n    pub fn execute(\n        \u0026self,\n        resource_name: \u0026str,\n        start_date: \u0026str,\n        end_date: \u0026str,\n        is_time_off_compensation: bool,\n        compensated_hours: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cCreateVacationResult, Box\u003cdyn std::error::Error\u003e\u003e {\n        if !Self::validate_dates(start_date, end_date) {\n            return Ok(CreateVacationResult {\n                success: false,\n                message: \"Data de início deve ser anterior ou igual à data de fim\".to_string(),\n            });\n        }\n\n        match self.repository.save_vacation(\n            resource_name,\n            start_date,\n            end_date,\n            is_time_off_compensation,\n            compensated_hours,\n        ) {\n            Ok(resource) =\u003e Ok(CreateVacationResult {\n                success: true,\n                message: format!(\"Período de férias adicionado com sucesso para {}\", resource.name()),\n            }),\n            Err(e) =\u003e Ok(CreateVacationResult {\n                success: false,\n                message: format!(\"Erro ao adicionar período de férias: {e}\"),\n            }),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        resource_management::{\n            AnyResource,\n            resource::{Period, PeriodType, Resource},\n        },\n        shared::errors::DomainError,\n    };\n    use chrono::{DateTime, Local, NaiveDateTime};\n    use std::cell::RefCell;\n    use std::collections::HashMap;\n    use std::rc::Rc;\n\n    // A mock repository that uses Rc\u003cRefCell\u003c...\u003e\u003e to share state between clones.\n    struct MockResourceRepository {\n        resources: Rc\u003cRefCell\u003cHashMap\u003cString, AnyResource\u003e\u003e\u003e,\n        should_fail: bool,\n    }\n\n    impl Clone for MockResourceRepository {\n        fn clone(\u0026self) -\u003e Self {\n            Self {\n                resources: self.resources.clone(), // This clones the Rc, not the data\n                should_fail: self.should_fail,\n            }\n        }\n    }\n\n    impl MockResourceRepository {\n        fn new(should_fail: bool) -\u003e Self {\n            Self {\n                resources: Rc::new(RefCell::new(HashMap::new())),\n                should_fail,\n            }\n        }\n\n        fn add_resource(\u0026self, resource: AnyResource) {\n            self.resources\n                .borrow_mut()\n                .insert(resource.name().to_string(), resource);\n        }\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn save(\u0026self, _resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.borrow().values().cloned().collect())\n        }\n\n        fn find_by_code(\u0026self, _code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(None)\n        }\n\n        fn save_time_off(\n            \u0026self,\n            _resource_name: \u0026str,\n            _hours: u32,\n            _date: \u0026str,\n            _description: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn save_vacation(\n            \u0026self,\n            resource_name: \u0026str,\n            start_date: \u0026str,\n            end_date: \u0026str,\n            is_time_off_compensation: bool,\n            compensated_hours: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            if self.should_fail {\n                return Err(DomainError::new(\n                    crate::domain::shared::errors::DomainErrorKind::Generic {\n                        message: \"Simulated repository error\".to_string(),\n                    },\n                ));\n            }\n\n            let mut resources = self.resources.borrow_mut();\n            if let Some(any_resource) = resources.get_mut(resource_name) {\n                let new_period = Period {\n                    start_date: NaiveDateTime::parse_from_str(\u0026format!(\"{start_date} 00:00:00\"), \"%Y-%m-%d %H:%M:%S\")\n                        .unwrap()\n                        .and_local_timezone(Local)\n                        .unwrap(),\n                    end_date: NaiveDateTime::parse_from_str(\u0026format!(\"{end_date} 00:00:00\"), \"%Y-%m-%d %H:%M:%S\")\n                        .unwrap()\n                        .and_local_timezone(Local)\n                        .unwrap(),\n                    approved: true,\n                    period_type: PeriodType::Vacation,\n                    is_time_off_compensation,\n                    compensated_hours,\n                    is_layoff: false,\n                };\n\n                let add_vacation = |vacations: Option\u003cVec\u003cPeriod\u003e\u003e| -\u003e Option\u003cVec\u003cPeriod\u003e\u003e {\n                    let mut v = vacations.unwrap_or_default();\n                    v.push(new_period);\n                    Some(v)\n                };\n\n                match any_resource {\n                    AnyResource::Available(r) =\u003e r.vacations = add_vacation(r.vacations.clone()),\n                    AnyResource::Assigned(r) =\u003e r.vacations = add_vacation(r.vacations.clone()),\n                    AnyResource::Inactive(_) =\u003e {\n                        return Err(DomainError::new(\n                            crate::domain::shared::errors::DomainErrorKind::ResourceInvalidState {\n                                current: \"Inactive\".to_string(),\n                                expected: \"Active\".to_string(),\n                            },\n                        ));\n                    }\n                }\n                Ok(any_resource.clone())\n            } else {\n                Err(DomainError::new(\n                    crate::domain::shared::errors::DomainErrorKind::Generic {\n                        message: format!(\"Resource '{resource_name}' not found\"),\n                    },\n                ))\n            }\n        }\n\n        fn check_if_layoff_period(\u0026self, _start_date: \u0026DateTime\u003cLocal\u003e, _end_date: \u0026DateTime\u003cLocal\u003e) -\u003e bool {\n            false\n        }\n\n        fn get_next_code(\u0026self, resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(format!(\"{}-1\", resource_type.to_lowercase()))\n        }\n    }\n\n    fn setup_test() -\u003e (MockResourceRepository, AnyResource) {\n        let mock_repo = MockResourceRepository::new(false);\n        let resource = Resource::new(\n            \"res-01\".to_string(),\n            \"John Doe\".to_string(),\n            None,\n            \"Developer\".to_string(),\n            None,\n            10,\n        );\n        let any_resource = AnyResource::Available(resource);\n        mock_repo.add_resource(any_resource.clone());\n        (mock_repo, any_resource)\n    }\n\n    #[test]\n    fn test_create_vacation_success() {\n        let (mock_repo, resource) = setup_test();\n        let use_case = CreateVacationUseCase::new(mock_repo);\n\n        let result = use_case\n            .execute(resource.name(), \"2025-07-01\", \"2025-07-10\", false, None)\n            .unwrap();\n\n        assert!(result.success);\n        assert_eq!(result.message, \"Período de férias adicionado com sucesso para John Doe\");\n    }\n\n    #[test]\n    fn test_create_vacation_invalid_dates() {\n        let (mock_repo, resource) = setup_test();\n        let use_case = CreateVacationUseCase::new(mock_repo);\n\n        let result = use_case\n            .execute(\n                resource.name(),\n                \"2025-07-10\", // End date\n                \"2025-07-01\", // Start date\n                false,\n                None,\n            )\n            .unwrap();\n\n        assert!(!result.success);\n        assert_eq!(\n            result.message,\n            \"Data de início deve ser anterior ou igual à data de fim\"\n        );\n    }\n\n    #[test]\n    fn test_create_vacation_repository_fails() {\n        let (mut mock_repo, resource) = setup_test();\n        mock_repo.should_fail = true; // Configure mock to fail\n        let use_case = CreateVacationUseCase::new(mock_repo);\n\n        let result = use_case\n            .execute(resource.name(), \"2025-08-01\", \"2025-08-10\", false, None)\n            .unwrap();\n\n        assert!(!result.success);\n        assert!(result.message.contains(\"Simulated repository error\"));\n    }\n\n    #[test]\n    fn test_create_vacation_with_compensation() {\n        let (mock_repo, resource) = setup_test();\n        // Clone the repo for the use case, so we can inspect the original\n        let use_case = CreateVacationUseCase::new(mock_repo.clone());\n\n        let _ = use_case\n            .execute(resource.name(), \"2025-09-01\", \"2025-09-02\", true, Some(16))\n            .unwrap();\n\n        // Verify the data was saved correctly in the shared state via the original mock\n        let stored_resource = mock_repo.resources.borrow().get(resource.name()).unwrap().clone();\n        let vacations = stored_resource.vacations().unwrap();\n        let last_vacation = vacations.last().unwrap();\n\n        assert_eq!(vacations.len(), 1);\n        assert!(last_vacation.is_time_off_compensation);\n        assert_eq!(last_vacation.compensated_hours, Some(16));\n    }\n}\n","traces":[{"line":14,"address":[824336,824368],"length":1,"stats":{"Line":3}},{"line":18,"address":[824624,824400],"length":1,"stats":{"Line":1}},{"line":19,"address":[824734,824552,824776,824510],"length":1,"stats":{"Line":3}},{"line":20,"address":[824658,824434],"length":1,"stats":{"Line":3}},{"line":21,"address":[824477,824701],"length":1,"stats":{"Line":1}},{"line":23,"address":[824587,824811],"length":1,"stats":{"Line":1}},{"line":25,"address":[824547,824771],"length":1,"stats":{"Line":0}},{"line":29,"address":[826160,825878,827196,827190,824848,825884],"length":1,"stats":{"Line":1}},{"line":37,"address":[825072,826384],"length":1,"stats":{"Line":3}},{"line":38,"address":[826428,825116],"length":1,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[825085,826397],"length":1,"stats":{"Line":1}},{"line":44,"address":[825284,826596],"length":1,"stats":{"Line":3}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[825757,826847,825535,827069],"length":1,"stats":{"Line":3}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[826921,825542,825609,826854],"length":1,"stats":{"Line":2}},{"line":55,"address":[826039,827351,825380,826692],"length":1,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[826804,825492,825934,827246],"length":1,"stats":{"Line":2}}],"covered":15,"coverable":24},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","initialize_repository_use_case.rs"],"content":"use crate::domain::shared::convertable::Convertible;\nuse crate::domain::{\n    company_settings::{config::Config, repository::ConfigRepository},\n    shared::errors::DomainError,\n};\nuse crate::infrastructure::persistence::manifests::config_manifest::ConfigManifest;\nuse std::path::PathBuf;\n\npub struct InitializeRepositoryUseCase\u003cR: ConfigRepository\u003e {\n    repository: R,\n}\n\nimpl\u003cR: ConfigRepository\u003e InitializeRepositoryUseCase\u003cR\u003e {\n    pub fn new(repository: R) -\u003e Self {\n        Self { repository }\n    }\n    pub fn execute(\u0026self, path: PathBuf, manager_name: String, manager_email: String) -\u003e Result\u003c(), DomainError\u003e {\n        let config = Config::new(manager_name.clone(), manager_email.clone(), \"UTC\".to_string());\n        let config_manifest = \u003cConfigManifest as Convertible\u003cConfig\u003e\u003e::from(config);\n        self.repository.create_repository_dir(path.clone())?;\n        self.repository.save(config_manifest, path.clone())?;\n        println!(\"Configuração iniciada em: {}\", path.display());\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n    use crate::domain::shared::errors::{DomainError, DomainErrorKind};\n    use crate::infrastructure::persistence::manifests::config_manifest::ConfigManifest;\n    use std::cell::RefCell;\n\n    struct MockConfigRepository {\n        should_fail: bool,\n        saved_config: RefCell\u003cOption\u003cConfigManifest\u003e\u003e,\n        created_path: RefCell\u003cOption\u003cPathBuf\u003e\u003e,\n    }\n\n    impl MockConfigRepository {\n        fn new(should_fail: bool) -\u003e Self {\n            Self {\n                should_fail,\n                saved_config: RefCell::new(None),\n                created_path: RefCell::new(None),\n            }\n        }\n    }\n\n    impl ConfigRepository for MockConfigRepository {\n        fn save(\u0026self, config: ConfigManifest, path: PathBuf) -\u003e Result\u003c(), DomainError\u003e {\n            if self.should_fail {\n                return Err(DomainError::new(DomainErrorKind::Generic {\n                    message: \"Erro mockado ao salvar\".to_string(),\n                }));\n            }\n            *self.saved_config.borrow_mut() = Some(config.clone());\n            *self.created_path.borrow_mut() = Some(path.clone());\n\n            Ok(())\n        }\n\n        fn create_repository_dir(\u0026self, path: PathBuf) -\u003e Result\u003c(), DomainError\u003e {\n            *self.created_path.borrow_mut() = Some(path.clone());\n            Ok(())\n        }\n\n        fn load(\u0026self) -\u003e Result\u003c(Config, PathBuf), DomainError\u003e {\n            if self.should_fail {\n                return Err(DomainError::new(DomainErrorKind::Generic {\n                    message: \"Erro mockado ao carregar\".to_string(),\n                }));\n            }\n            let config = Config::new(\"mock\".to_string(), \"mock@email.com\".to_string(), \"UTC\".to_string());\n            let path = PathBuf::from(\"/mock/path\");\n            Ok((config, path))\n        }\n    }\n    #[test]\n    fn test_create_config_success() {\n        let mock_repo = MockConfigRepository::new(false);\n        let use_case = InitializeRepositoryUseCase::new(mock_repo);\n        let manager_name = \"John\".to_string();\n        let manager_email = \"john@nothing.com\".to_string();\n        let repo_path = PathBuf::new();\n\n        let result = use_case.execute(repo_path, manager_name, manager_email);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_create_config_failure() {\n        let mock_repo = MockConfigRepository::new(true);\n        let use_case = InitializeRepositoryUseCase::new(mock_repo);\n        let manager_name = \"John\".to_string();\n        let manager_email = \"john@nothing.com\".to_string();\n        let repo_path = PathBuf::new();\n\n        let result = use_case.execute(repo_path, manager_name, manager_email);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_verify_config_saved() {\n        let mock_repo = MockConfigRepository::new(false);\n        let use_case = InitializeRepositoryUseCase::new(mock_repo);\n        let manager_name = \"John\".to_string();\n        let manager_email = \"john@nothing.com\".to_string();\n        let repo_path = PathBuf::new();\n        let _ = use_case.execute(repo_path, manager_name.clone(), manager_email.clone());\n\n        let saved_config = use_case.repository.saved_config.borrow();\n        assert!(saved_config.is_some());\n        assert_eq!(saved_config.as_ref().unwrap().spec.manager_name, manager_name);\n        assert_eq!(saved_config.as_ref().unwrap().spec.manager_email, manager_email);\n    }\n}\n","traces":[{"line":14,"address":[1056416,1056448],"length":1,"stats":{"Line":3}},{"line":17,"address":[1056480,1059360,1059498,1057978,1058000,1057840],"length":1,"stats":{"Line":2}},{"line":18,"address":[1058157,1056533,1059454,1056637,1057934,1058053],"length":1,"stats":{"Line":3}},{"line":19,"address":[1058387,1056867],"length":1,"stats":{"Line":1}},{"line":20,"address":[1057846,1056964,1059366,1058415,1058484,1056895],"length":1,"stats":{"Line":3}},{"line":21,"address":[1057808,1059328,1058668,1057830,1057148,1059350],"length":1,"stats":{"Line":3}},{"line":22,"address":[1059009,1057489],"length":1,"stats":{"Line":1}},{"line":24,"address":[1059183,1057663],"length":1,"stats":{"Line":1}}],"covered":8,"coverable":8},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","list","mod.rs"],"content":"pub mod projects;\npub mod resources;\npub mod tasks;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","list","projects.rs"],"content":"use crate::domain::project_management::{AnyProject, repository::ProjectRepository};\nuse crate::domain::shared::errors::DomainError;\n\npub struct ListProjectsUseCase\u003cR: ProjectRepository\u003e {\n    repository: R,\n}\n\nimpl\u003cR: ProjectRepository\u003e ListProjectsUseCase\u003cR\u003e {\n    pub fn new(repository: R) -\u003e Self {\n        Self { repository }\n    }\n\n    pub fn execute(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n        self.repository.find_all()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::project_management::{AnyProject, builder::ProjectBuilder};\n    use std::cell::RefCell;\n\n    struct MockProjectRepository {\n        projects: RefCell\u003cVec\u003cAnyProject\u003e\u003e,\n    }\n\n    impl MockProjectRepository {\n        fn new(projects: Vec\u003cAnyProject\u003e) -\u003e Self {\n            Self {\n                projects: RefCell::new(projects),\n            }\n        }\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            self.projects.borrow_mut().push(project);\n            Ok(())\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().clone())\n        }\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().iter().find(|p| p.code() == code).cloned())\n        }\n    }\n\n    #[test]\n    fn test_list_projects_success() {\n        let projects = vec![\n            ProjectBuilder::new(\"Project A\".to_string())\n                .code(\"proj-a\".to_string())\n                .build()\n                .into(),\n            ProjectBuilder::new(\"Project B\".to_string())\n                .code(\"proj-b\".to_string())\n                .build()\n                .into(),\n        ];\n        let mock_repo = MockProjectRepository::new(projects);\n        let use_case = ListProjectsUseCase::new(mock_repo);\n\n        let result = use_case.execute().unwrap();\n        assert_eq!(result.len(), 2);\n        assert!(result.iter().any(|p| p.name() == \"Project A\"));\n        assert!(result.iter().any(|p| p.name() == \"Project B\"));\n    }\n\n    #[test]\n    fn test_list_projects_empty() {\n        let mock_repo = MockProjectRepository::new(vec![]);\n        let use_case = ListProjectsUseCase::new(mock_repo);\n\n        let result = use_case.execute().unwrap();\n        assert!(result.is_empty());\n    }\n}\n","traces":[{"line":9,"address":[251568,251520],"length":1,"stats":{"Line":1}},{"line":13,"address":[251632,251600],"length":1,"stats":{"Line":1}},{"line":14,"address":[251649,251617],"length":1,"stats":{"Line":2}}],"covered":3,"coverable":3},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","list","resources.rs"],"content":"use crate::domain::resource_management::{any_resource::AnyResource, repository::ResourceRepository};\nuse crate::domain::shared::errors::DomainError;\n\npub struct ListResourcesUseCase\u003cR: ResourceRepository\u003e {\n    repository: R,\n}\n\nimpl\u003cR: ResourceRepository\u003e ListResourcesUseCase\u003cR\u003e {\n    pub fn new(repository: R) -\u003e Self {\n        Self { repository }\n    }\n\n    pub fn execute(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n        self.repository.find_all()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::resource_management::{any_resource::AnyResource, resource::Resource};\n\n    struct MockResourceRepository {\n        resources: Vec\u003cAnyResource\u003e,\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.clone())\n        }\n        fn find_by_code(\u0026self, _code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(None)\n        }\n        fn save(\u0026self, _resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn save_time_off(\n            \u0026self,\n            _r: \u0026str,\n            _h: u32,\n            _d: \u0026str,\n            _desc: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn save_vacation(\n            \u0026self,\n            _r: \u0026str,\n            _s: \u0026str,\n            _e: \u0026str,\n            _i: bool,\n            _c: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn check_if_layoff_period(\n            \u0026self,\n            _s: \u0026chrono::DateTime\u003cchrono::Local\u003e,\n            _e: \u0026chrono::DateTime\u003cchrono::Local\u003e,\n        ) -\u003e bool {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self, resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(format!(\"{}-1\", resource_type.to_lowercase()))\n        }\n    }\n\n    fn create_test_resource(name: \u0026str, code: \u0026str, r_type: \u0026str) -\u003e AnyResource {\n        Resource::new(code.to_string(), name.to_string(), None, r_type.to_string(), None, 0).into()\n    }\n\n    #[test]\n    fn test_list_resources_success() {\n        let resources = vec![\n            create_test_resource(\"Alice\", \"dev-1\", \"Developer\"),\n            create_test_resource(\"Bob\", \"qa-1\", \"QA\"),\n        ];\n        let mock_repo = MockResourceRepository { resources };\n        let use_case = ListResourcesUseCase::new(mock_repo);\n\n        let result = use_case.execute().unwrap();\n\n        assert_eq!(result.len(), 2);\n        assert!(result.iter().any(|r| r.name() == \"Alice\"));\n        assert!(result.iter().any(|r| r.code() == \"qa-1\"));\n    }\n\n    #[test]\n    fn test_list_resources_empty() {\n        let mock_repo = MockResourceRepository { resources: vec![] };\n        let use_case = ListResourcesUseCase::new(mock_repo);\n\n        let result = use_case.execute().unwrap();\n\n        assert!(result.is_empty());\n    }\n}\n","traces":[{"line":9,"address":[674736,674768],"length":1,"stats":{"Line":1}},{"line":13,"address":[674832,674800],"length":1,"stats":{"Line":2}},{"line":14,"address":[674817,674849],"length":1,"stats":{"Line":2}}],"covered":3,"coverable":3},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","list","tasks.rs"],"content":"use crate::domain::project_management::repository::ProjectRepository;\nuse crate::domain::shared::errors::DomainError;\nuse crate::domain::task_management::any_task::AnyTask;\n\npub struct ListTasksUseCase\u003cR: ProjectRepository\u003e {\n    repository: R,\n}\n\nimpl\u003cR: ProjectRepository\u003e ListTasksUseCase\u003cR\u003e {\n    pub fn new(repository: R) -\u003e Self {\n        Self { repository }\n    }\n\n    pub fn execute(\u0026self) -\u003e Result\u003cVec\u003cAnyTask\u003e, DomainError\u003e {\n        let project = self.repository.load()?;\n        let tasks = project.tasks().values().cloned().collect();\n        Ok(tasks)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        project_management::{AnyProject, builder::ProjectBuilder},\n        shared::errors::DomainError,\n        task_management::{state::Planned, task::Task},\n    };\n    use chrono::NaiveDate;\n\n    use uuid7::uuid7;\n\n    struct MockProjectRepository {\n        project: AnyProject,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            Ok(self.project.clone())\n        }\n        // Unimplemented methods\n        fn save(\u0026self, _project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_by_code(\u0026self, _code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    fn create_test_task(code: \u0026str, name: \u0026str) -\u003e AnyTask {\n        Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-1\".to_string(),\n            code: code.to_string(),\n            name: name.to_string(),\n            description: None,\n            state: Planned,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![],\n        }\n        .into()\n    }\n\n    fn create_project_with_tasks(tasks: Vec\u003cAnyTask\u003e) -\u003e AnyProject {\n        let mut project: AnyProject = ProjectBuilder::new(\"Test Project\".to_string())\n            .code(\"PROJ-1\".to_string())\n            .build()\n            .into();\n        for task in tasks {\n            project.add_task(task);\n        }\n        project\n    }\n\n    #[test]\n    fn test_list_tasks_success() {\n        let tasks = vec![\n            create_test_task(\"TSK-1\", \"First task\"),\n            create_test_task(\"TSK-2\", \"Second task\"),\n        ];\n        let project = create_project_with_tasks(tasks);\n        let mock_repo = MockProjectRepository { project };\n        let use_case = ListTasksUseCase::new(mock_repo);\n\n        let result = use_case.execute().unwrap();\n        assert_eq!(result.len(), 2);\n        assert!(result.iter().any(|t| t.name() == \"First task\"));\n        assert!(result.iter().any(|t| t.code() == \"TSK-2\"));\n    }\n\n    #[test]\n    fn test_list_tasks_empty() {\n        let project = create_project_with_tasks(vec![]);\n        let mock_repo = MockProjectRepository { project };\n        let use_case = ListTasksUseCase::new(mock_repo);\n\n        let result = use_case.execute().unwrap();\n        assert!(result.is_empty());\n    }\n}\n","traces":[{"line":10,"address":[2055392,2055424],"length":1,"stats":{"Line":1}},{"line":14,"address":[2055456,2055888,2055870,2056296,2056302,2055864],"length":1,"stats":{"Line":1}},{"line":15,"address":[2055481,2055913],"length":1,"stats":{"Line":1}},{"line":16,"address":[2055678,2055740,2056110,2056172],"length":1,"stats":{"Line":2}},{"line":17,"address":[2056230,2055798],"length":1,"stats":{"Line":1}}],"covered":5,"coverable":5},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","mod.rs"],"content":"pub mod build_use_case;\npub mod initialize_repository_use_case;\n\npub mod create;\npub mod list;\npub mod project;\npub mod report;\npub mod resource;\npub mod task;\npub mod validate;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","project","assign_resource_to_task.rs"],"content":"use crate::domain::{\n    project_management::{AnyProject, repository::ProjectRepository},\n    resource_management::repository::ResourceRepository,\n    shared::errors::DomainError,\n};\n\n#[derive(Debug, thiserror::Error)]\npub enum AssignResourceToTaskError {\n    #[error(\"Project with code '{0}' not found\")]\n    ProjectNotFound(String),\n    #[error(\"Task with code '{0}' not found in project\")]\n    TaskNotFound(String),\n    #[error(\"One or more resources not found: {0:?}\")]\n    ResourcesNotFound(Vec\u003cString\u003e),\n    #[error(\"Domain rule violation: {0}\")]\n    DomainError(String),\n    #[error(\"Repository error: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\npub struct AssignResourceToTaskUseCase\u003cPR, RR\u003e\nwhere\n    PR: ProjectRepository,\n    RR: ResourceRepository,\n{\n    project_repository: PR,\n    resource_repository: RR,\n}\n\nimpl\u003cPR, RR\u003e AssignResourceToTaskUseCase\u003cPR, RR\u003e\nwhere\n    PR: ProjectRepository,\n    RR: ResourceRepository,\n{\n    pub fn new(project_repository: PR, resource_repository: RR) -\u003e Self {\n        Self {\n            project_repository,\n            resource_repository,\n        }\n    }\n\n    pub fn execute(\n        \u0026self,\n        project_code: \u0026str,\n        task_code: \u0026str,\n        resource_codes: \u0026[\u0026str],\n    ) -\u003e Result\u003cAnyProject, AssignResourceToTaskError\u003e {\n        // 1. Validate that all resources exist\n        let all_resources = self.resource_repository.find_all()?;\n        let existing_resource_codes: std::collections::HashSet\u003cString\u003e =\n            all_resources.iter().map(|r| r.code().to_string()).collect();\n\n        let not_found_resources: Vec\u003cString\u003e = resource_codes\n            .iter()\n            .filter(|rc| !existing_resource_codes.contains(**rc))\n            .map(|s| s.to_string())\n            .collect();\n\n        if !not_found_resources.is_empty() {\n            return Err(AssignResourceToTaskError::ResourcesNotFound(not_found_resources));\n        }\n\n        // 2. Load the project aggregate\n        let mut project = self\n            .project_repository\n            .find_by_code(project_code)?\n            .ok_or_else(|| AssignResourceToTaskError::ProjectNotFound(project_code.to_string()))?;\n\n        // 3. Delegate the assignment to the project aggregate\n        project\n            .assign_resource_to_task(task_code, resource_codes)\n            .map_err(AssignResourceToTaskError::DomainError)?;\n\n        // 4. Save the updated project aggregate\n        self.project_repository.save(project.clone())?;\n\n        Ok(project)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        project_management::{AnyProject, builder::ProjectBuilder},\n        resource_management::{AnyResource, resource::Resource},\n        task_management::{AnyTask, state::Planned, task::Task},\n    };\n    use chrono::{DateTime, Local, NaiveDate};\n    use std::{cell::RefCell, collections::HashMap};\n    use uuid7::uuid7;\n\n    // --- Mocks ---\n    struct MockProjectRepository {\n        projects: RefCell\u003cHashMap\u003cString, AnyProject\u003e\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            self.projects.borrow_mut().insert(project.code().to_string(), project);\n            Ok(())\n        }\n\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().get(code).cloned())\n        }\n\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    struct MockResourceRepository {\n        resources: Vec\u003cAnyResource\u003e,\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.clone())\n        }\n\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.iter().find(|r| r.code() == code).cloned())\n        }\n\n        fn save(\u0026self, _resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn save_time_off(\n            \u0026self,\n            _name: \u0026str,\n            _hours: u32,\n            _date: \u0026str,\n            _desc: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn save_vacation(\n            \u0026self,\n            _name: \u0026str,\n            _start: \u0026str,\n            _end: \u0026str,\n            _comp: bool,\n            _hours: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn check_if_layoff_period(\u0026self, _start_date: \u0026DateTime\u003cLocal\u003e, _end_date: \u0026DateTime\u003cLocal\u003e) -\u003e bool {\n            unimplemented!()\n        }\n\n        fn get_next_code(\u0026self, resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(format!(\"{}-1\", resource_type.to_lowercase()))\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_task(code: \u0026str, assignees: \u0026[\u0026str]) -\u003e Task\u003cPlanned\u003e {\n        Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-1\".to_string(),\n            code: code.to_string(),\n            name: \"Test Task\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: assignees.iter().map(|\u0026s| s.to_string()).collect(),\n        }\n    }\n\n    fn create_test_resource(name: \u0026str) -\u003e AnyResource {\n        Resource::new(\n            format!(\"dev-{name}\"),\n            name.to_string(),\n            None,\n            \"Developer\".to_string(),\n            None,\n            0,\n        )\n        .into()\n    }\n\n    fn setup_test_project(tasks: Vec\u003cAnyTask\u003e) -\u003e AnyProject {\n        let mut project: AnyProject = ProjectBuilder::new(\"Test Project\".to_string())\n            .code(\"PROJ-1\".to_string())\n            .build()\n            .into();\n        for task in tasks {\n            project.add_task(task);\n        }\n        project\n    }\n\n    // --- Tests ---\n    #[test]\n    fn test_assign_new_resources_success() {\n        let project = setup_test_project(vec![create_test_task(\"TSK-1\", \u0026[\"dev-res-1\"]).into()]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n        let resource_repo = MockResourceRepository {\n            resources: vec![create_test_resource(\"res-1\"), create_test_resource(\"res-2\")],\n        };\n        let use_case = AssignResourceToTaskUseCase::new(project_repo, resource_repo);\n\n        let result = use_case.execute(\"PROJ-1\", \"TSK-1\", \u0026[\"dev-res-2\"]);\n\n        assert!(result.is_ok());\n        let updated_project = result.unwrap();\n        let updated_task = updated_project.tasks().get(\"TSK-1\").unwrap();\n        let mut assignees = updated_task.assigned_resources().to_vec();\n        assignees.sort();\n        assert_eq!(assignees, vec![\"dev-res-1\", \"dev-res-2\"]);\n    }\n\n    #[test]\n    fn test_assign_fails_if_project_not_found() {\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::new()),\n        };\n        let resource_repo = MockResourceRepository {\n            resources: vec![create_test_resource(\"res-1\")],\n        };\n        let use_case = AssignResourceToTaskUseCase::new(project_repo, resource_repo);\n\n        let result = use_case.execute(\"PROJ-NONEXISTENT\", \"TSK-1\", \u0026[\"dev-res-1\"]);\n\n        assert!(matches!(result, Err(AssignResourceToTaskError::ProjectNotFound(_))));\n    }\n\n    #[test]\n    fn test_assign_fails_if_resource_not_found() {\n        let project = setup_test_project(vec![create_test_task(\"TSK-1\", \u0026[]).into()]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n        let resource_repo = MockResourceRepository {\n            resources: vec![create_test_resource(\"res-1\")],\n        };\n        let use_case = AssignResourceToTaskUseCase::new(project_repo, resource_repo);\n\n        let result = use_case.execute(\"PROJ-1\", \"TSK-1\", \u0026[\"res-NONEXISTENT\"]);\n\n        assert!(matches!(result, Err(AssignResourceToTaskError::ResourcesNotFound(_))));\n    }\n}\n","traces":[{"line":35,"address":[1415328,1415392],"length":1,"stats":{"Line":1}},{"line":42,"address":[1417808,1420014,1417783,1415472,1417706,1420091],"length":1,"stats":{"Line":1}},{"line":49,"address":[1417981,1415645],"length":1,"stats":{"Line":1}},{"line":50,"address":[1415846,1420112,1418186,1420147,1420211,1415925,1420176,1418259],"length":1,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[1420254,1420288,1420302,1416107,1418435,1420240],"length":1,"stats":{"Line":3}},{"line":56,"address":[1416130,1420371,1420435,1420400,1420336,1418458],"length":1,"stats":{"Line":3}},{"line":59,"address":[1418567,1418496,1416168,1416239],"length":1,"stats":{"Line":2}},{"line":60,"address":[1418585,1416257],"length":1,"stats":{"Line":1}},{"line":64,"address":[1416490,1416745,1416436,1419069,1420020,1416633,1417712,1419212,1416888,1418957,1418814],"length":1,"stats":{"Line":5}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[1418861,1416537,1416448,1418772],"length":1,"stats":{"Line":1}},{"line":67,"address":[1420560,1420583,1416722,1416792,1420464,1419116,1419046,1420487],"length":1,"stats":{"Line":4}},{"line":70,"address":[1419443,1417119,1417262,1419586,1420012,1417704],"length":1,"stats":{"Line":1}},{"line":71,"address":[1417033,1419357],"length":1,"stats":{"Line":1}},{"line":72,"address":[1417096,1417166,1419420,1419490],"length":1,"stats":{"Line":1}},{"line":75,"address":[1417295,1419992,1417684,1419627],"length":1,"stats":{"Line":1}},{"line":77,"address":[1417582,1419891],"length":1,"stats":{"Line":1}}],"covered":16,"coverable":19},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","project","cancel_project.rs"],"content":"use crate::domain::{\n    project_management::{any_project::AnyProject, repository::ProjectRepository},\n    shared::errors::DomainError,\n};\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum CancelProjectError {\n    #[error(\"Project with code '{0}' not found.\")]\n    ProjectNotFound(String),\n    #[error(\"An unexpected domain rule was violated: {0}\")]\n    DomainError(String),\n    #[error(\"A repository error occurred: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\npub struct CancelProjectUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    project_repository: PR,\n}\n\nimpl\u003cPR\u003e CancelProjectUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    pub fn new(project_repository: PR) -\u003e Self {\n        Self { project_repository }\n    }\n\n    pub fn execute(\u0026self, project_code: \u0026str) -\u003e Result\u003cAnyProject, CancelProjectError\u003e {\n        // 1. Load the project aggregate.\n        let project = self\n            .project_repository\n            .find_by_code(project_code)?\n            .ok_or_else(|| CancelProjectError::ProjectNotFound(project_code.to_string()))?;\n\n        // 2. Delegate the cancellation to the project aggregate.\n        let cancelled_project = project.cancel().map_err(CancelProjectError::DomainError)?;\n\n        // 3. Save the updated project aggregate.\n        self.project_repository.save(cancelled_project.clone())?;\n\n        Ok(cancelled_project)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::project_management::builder::ProjectBuilder;\n    use std::{cell::RefCell, collections::HashMap};\n\n    // --- Mocks ---\n    #[derive(Clone)]\n    struct MockProjectRepository {\n        projects: RefCell\u003cHashMap\u003cString, AnyProject\u003e\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            self.projects.borrow_mut().insert(project.code().to_string(), project);\n            Ok(())\n        }\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().get(code).cloned())\n        }\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_project(code: \u0026str) -\u003e AnyProject {\n        ProjectBuilder::new(\"Test Project\".to_string())\n            .code(code.to_string())\n            .build()\n            .into()\n    }\n\n    // --- Tests ---\n    #[test]\n    fn test_cancel_project_fails_if_not_found() {\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::new()),\n        };\n        let use_case = CancelProjectUseCase::new(project_repo);\n\n        let result = use_case.execute(\"PROJ-NONEXISTENT\");\n        assert!(matches!(result, Err(CancelProjectError::ProjectNotFound(_))));\n    }\n\n    // TODO: Enable this test once `AnyProject::cancel` is implemented.\n\n    #[test]\n    fn test_cancel_project_success() {\n        let initial_project = create_test_project(\"PROJ-1\");\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(initial_project.code().to_string(), initial_project)])),\n        };\n        let use_case = CancelProjectUseCase::new(project_repo.clone());\n\n        let result = use_case.execute(\"PROJ-1\");\n\n        assert!(result.is_ok());\n        let cancelled_project = result.unwrap();\n        assert_eq!(cancelled_project.status(), \"Cancelled\");\n    }\n}\n","traces":[{"line":28,"address":[790512,790544],"length":1,"stats":{"Line":1}},{"line":32,"address":[790576,792968,792976,791752,791760,791792],"length":1,"stats":{"Line":1}},{"line":34,"address":[790668,790752,790918,791863,791968,792134,791884,792050,790647,790834],"length":1,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[791933,790717,791871,790655],"length":1,"stats":{"Line":1}},{"line":37,"address":[793008,790813,793104,790883,792099,793127,793031,792029],"length":1,"stats":{"Line":4}},{"line":40,"address":[792254,791138,792354,791758,792974,791038],"length":1,"stats":{"Line":2}},{"line":43,"address":[791408,791476,792624,792692],"length":1,"stats":{"Line":2}},{"line":45,"address":[791657,792873],"length":1,"stats":{"Line":1}}],"covered":8,"coverable":9},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","project","describe_project.rs"],"content":"use crate::domain::{\n    project_management::{any_project::AnyProject, repository::ProjectRepository},\n    shared::errors::DomainError,\n};\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum DescribeProjectError {\n    #[error(\"Project with code '{0}' not found.\")]\n    ProjectNotFound(String),\n    #[error(\"A repository error occurred: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\npub struct DescribeProjectUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    project_repository: PR,\n}\n\nimpl\u003cPR\u003e DescribeProjectUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    pub fn new(project_repository: PR) -\u003e Self {\n        Self { project_repository }\n    }\n\n    pub fn execute(\u0026self, project_code: \u0026str) -\u003e Result\u003cAnyProject, DescribeProjectError\u003e {\n        self.project_repository\n            .find_by_code(project_code)?\n            .ok_or_else(|| DescribeProjectError::ProjectNotFound(project_code.to_string()))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::project_management::builder::ProjectBuilder;\n    use std::{cell::RefCell, collections::HashMap};\n\n    // --- Mocks ---\n    struct MockProjectRepository {\n        projects: RefCell\u003cHashMap\u003cString, AnyProject\u003e\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            self.projects.borrow_mut().insert(project.code().to_string(), project);\n            Ok(())\n        }\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().get(code).cloned())\n        }\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_project(code: \u0026str) -\u003e AnyProject {\n        ProjectBuilder::new(\"Test Project\".to_string())\n            .code(code.to_string())\n            .description(Some(\"A test project.\".to_string()))\n            .build()\n            .into()\n    }\n\n    #[test]\n    fn test_describe_project_success() {\n        let project_code = \"PROJ-1\";\n        let project = create_test_project(project_code);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n        let use_case = DescribeProjectUseCase::new(project_repo);\n\n        let result = use_case.execute(project_code);\n\n        assert!(result.is_ok());\n        let found_project = result.unwrap();\n        assert_eq!(found_project.code(), project_code);\n        assert_eq!(found_project.name(), \"Test Project\");\n    }\n\n    #[test]\n    fn test_describe_project_not_found() {\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::new()),\n        };\n        let use_case = DescribeProjectUseCase::new(project_repo);\n\n        let result = use_case.execute(\"PROJ-NONEXISTENT\");\n\n        assert!(matches!(result, Err(DescribeProjectError::ProjectNotFound(_))));\n    }\n}\n","traces":[{"line":26,"address":[1744160,1744192],"length":1,"stats":{"Line":1}},{"line":30,"address":[1744224,1744448],"length":1,"stats":{"Line":1}},{"line":31,"address":[1744287,1744362,1744511,1744586],"length":1,"stats":{"Line":1}},{"line":32,"address":[1744274,1744330,1744498,1744554],"length":1,"stats":{"Line":1}},{"line":33,"address":[1744672,1744421,1744791,1744768,1744695,1744645],"length":1,"stats":{"Line":3}}],"covered":5,"coverable":5},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","project","detect_resource_conflicts.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","project","mod.rs"],"content":"pub mod assign_resource_to_task;\npub mod cancel_project;\npub mod describe_project;\npub mod detect_resource_conflicts;\npub mod update_project;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","project","update_project.rs"],"content":"use crate::domain::{\n    project_management::{any_project::AnyProject, repository::ProjectRepository},\n    shared::errors::DomainError,\n};\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum UpdateProjectError {\n    #[error(\"Project with code '{0}' not found.\")]\n    ProjectNotFound(String),\n    #[error(\"A repository error occurred: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\n#[derive(Debug, Clone, Default)]\npub struct UpdateProjectArgs {\n    pub name: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n}\n\npub struct UpdateProjectUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    project_repository: PR,\n}\n\nimpl\u003cPR\u003e UpdateProjectUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    pub fn new(project_repository: PR) -\u003e Self {\n        Self { project_repository }\n    }\n\n    pub fn execute(\u0026self, project_code: \u0026str, args: UpdateProjectArgs) -\u003e Result\u003cAnyProject, UpdateProjectError\u003e {\n        // 1. Load the project aggregate.\n        let mut project = self\n            .project_repository\n            .find_by_code(project_code)?\n            .ok_or_else(|| UpdateProjectError::ProjectNotFound(project_code.to_string()))?;\n\n        // 2. Update the fields on the aggregate.\n        if let Some(name) = args.name {\n            project.set_name(name);\n        }\n        if let Some(description) = args.description {\n            project.set_description(Some(description));\n        }\n\n        // 3. Save the updated project aggregate.\n        self.project_repository.save(project.clone())?;\n\n        Ok(project)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::project_management::builder::ProjectBuilder;\n    use std::{cell::RefCell, collections::HashMap};\n\n    // --- Mocks ---\n    struct MockProjectRepository {\n        projects: RefCell\u003cHashMap\u003cString, AnyProject\u003e\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            self.projects.borrow_mut().insert(project.code().to_string(), project);\n            Ok(())\n        }\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().get(code).cloned())\n        }\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_project(code: \u0026str, name: \u0026str, description: Option\u003c\u0026str\u003e) -\u003e AnyProject {\n        ProjectBuilder::new(name.to_string())\n            .code(code.to_string())\n            .description(description.map(|s| s.to_string()))\n            .build()\n            .into()\n    }\n\n    // --- Tests ---\n\n    // TODO: Enable this test once `AnyProject::set_name` and `AnyProject::set_description` are implemented.\n    #[test]\n    fn test_update_project_name_and_description_success() {\n        let initial_project = create_test_project(\"PROJ-1\", \"Old Name\", Some(\"Old Description\"));\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(initial_project.code().to_string(), initial_project)])),\n        };\n        let use_case = UpdateProjectUseCase::new(project_repo);\n\n        let args = UpdateProjectArgs {\n            name: Some(\"New Name\".to_string()),\n            description: Some(\"New Description\".to_string()),\n        };\n\n        let result = use_case.execute(\"PROJ-1\", args);\n\n        assert!(result.is_ok());\n        let updated_project = result.unwrap();\n        assert_eq!(updated_project.name(), \"New Name\");\n        assert_eq!(updated_project.description().unwrap(), \"New Description\");\n    }\n\n    #[test]\n    fn test_update_project_fails_if_not_found() {\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::new()),\n        };\n        let use_case = UpdateProjectUseCase::new(project_repo);\n\n        let args = UpdateProjectArgs {\n            name: Some(\"New Name\".to_string()),\n            ..Default::default()\n        };\n\n        let result = use_case.execute(\"PROJ-NONEXISTENT\", args);\n        assert!(matches!(result, Err(UpdateProjectError::ProjectNotFound(_))));\n    }\n}\n","traces":[{"line":32,"address":[2193408,2193440],"length":1,"stats":{"Line":1}},{"line":36,"address":[2195280,2194864,2193472,2194831,2196639,2196672],"length":1,"stats":{"Line":1}},{"line":38,"address":[2195341,2194961,2195470,2193662,2195606,2193798,2194040,2195848,2196769,2193904,2193533,2195712],"length":1,"stats":{"Line":5}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[2193573,2195510,2193702,2195381],"length":1,"stats":{"Line":1}},{"line":41,"address":[2197207,2195752,2197111,2193944,2193881,2197184,2195689,2197088],"length":1,"stats":{"Line":4}},{"line":44,"address":[2194119,2195927],"length":1,"stats":{"Line":1}},{"line":45,"address":[2194200,2194287,2196008,2196095],"length":1,"stats":{"Line":2}},{"line":47,"address":[2194294,2194212,2196102,2196020],"length":1,"stats":{"Line":2}},{"line":48,"address":[2196206,2194326,2194398,2196134],"length":1,"stats":{"Line":2}},{"line":52,"address":[2196199,2194391,2196229,2194421],"length":1,"stats":{"Line":2}},{"line":54,"address":[2196413,2194605],"length":1,"stats":{"Line":1}}],"covered":11,"coverable":12},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","report","mod.rs"],"content":"pub mod task;\npub mod vacation;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","report","task.rs"],"content":"use crate::domain::{project_management::repository::ProjectRepository, task_management::AnyTask};\nuse csv::Writer;\nuse std::error::Error;\nuse std::io;\n\n/// `TaskReportUseCase` gera um relatório em formato CSV com todas as tarefas.\npub struct TaskReportUseCase\u003cP: ProjectRepository\u003e {\n    project_repository: P,\n}\n\nimpl\u003cP: ProjectRepository\u003e TaskReportUseCase\u003cP\u003e {\n    /// Cria uma nova instância do caso de uso com o repositório necessário.\n    pub fn new(project_repository: P) -\u003e Self {\n        Self { project_repository }\n    }\n\n    /// Executa a geração do relatório, escrevendo o resultado em um `Writer` fornecido.\n    pub fn execute\u003cW: io::Write\u003e(\u0026self, writer: \u0026mut Writer\u003cW\u003e) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        // Escrever o cabeçalho do CSV\n        writer.write_record([\n            \"Code\",\n            \"Name\",\n            \"Status\",\n            \"Progress\",\n            \"StartDate\",\n            \"DueDate\",\n            \"Assignees\",\n        ])?;\n\n        let project = self.project_repository.load()?;\n        let tasks: Vec\u003c\u0026AnyTask\u003e = project.tasks().values().collect();\n\n        // Iterar sobre as tarefas e escrever os registros\n        for any_task in tasks {\n            // Extrair dados comuns e específicos do estado de cada tarefa\n            let (code, name, start_date, due_date, assigned_resources, status_str, progress_str) = match any_task {\n                // Zero-copy: sem clone!\n                AnyTask::Planned(task) =\u003e (\n                    \u0026task.code,               // Referência\n                    \u0026task.name,               // Referência\n                    task.start_date,          // Copy é OK\n                    task.due_date,            // Copy é OK\n                    \u0026task.assigned_resources, // Referência\n                    \"Planned\",                // \u0026'static str\n                    \"0\",                      // \u0026'static str\n                ),\n                AnyTask::InProgress(task) =\u003e (\n                    \u0026task.code,               // Referência\n                    \u0026task.name,               // Referência\n                    task.start_date,          // Copy é OK\n                    task.due_date,            // Copy é OK\n                    \u0026task.assigned_resources, // Referência\n                    \"InProgress\",             // \u0026'static str\n                    \"0\",                      // \u0026'static str - simplificado para consistência\n                ),\n                AnyTask::Completed(task) =\u003e (\n                    \u0026task.code,               // Referência\n                    \u0026task.name,               // Referência\n                    task.start_date,          // Copy é OK\n                    task.due_date,            // Copy é OK\n                    \u0026task.assigned_resources, // Referência\n                    \"Completed\",              // \u0026'static str\n                    \"100\",                    // \u0026'static str\n                ),\n                AnyTask::Blocked(task) =\u003e (\n                    \u0026task.code,               // Referência\n                    \u0026task.name,               // Referência\n                    task.start_date,          // Copy é OK\n                    task.due_date,            // Copy é OK\n                    \u0026task.assigned_resources, // Referência\n                    \"Blocked\",                // \u0026'static str\n                    \"N/A\",                    // \u0026'static str\n                ),\n                AnyTask::Cancelled(task) =\u003e (\n                    \u0026task.code,               // Referência\n                    \u0026task.name,               // Referência\n                    task.start_date,          // Copy é OK\n                    task.due_date,            // Copy é OK\n                    \u0026task.assigned_resources, // Referência\n                    \"Cancelled\",              // \u0026'static str\n                    \"N/A\",                    // \u0026'static str\n                ),\n            };\n\n            let assignees_str = assigned_resources.join(\", \");\n\n            writer.write_record([\n                code,\n                name,\n                status_str,\n                progress_str,\n                \u0026start_date.to_string(),\n                \u0026due_date.to_string(),\n                \u0026assignees_str,\n            ])?;\n        }\n\n        writer.flush()?;\n        Ok(())\n    }\n}\n\n// ===================================\n// TESTES\n// ===================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        project_management::{AnyProject, builder::ProjectBuilder},\n        shared::errors::{DomainError, DomainErrorKind},\n        task_management::{\n            Task,\n            state::{Completed, InProgress, Planned, Blocked, Cancelled},\n        },\n    };\n    use chrono::NaiveDate;\n    use uuid7::uuid7;\n\n    // --- Mock ---\n    struct MockProjectRepository {\n        project: AnyProject,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            Ok(self.project.clone())\n        }\n        fn save(\u0026self, _project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_by_code(\u0026self, _code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    // --- Teste Principal ---\n    #[test]\n    fn test_task_report_generation() {\n        // 1. Setup: Criar dados de teste\n        let task1: Task\u003cInProgress\u003e = Task {\n            id: uuid7(),\n            project_code: \"PROJ\".to_string(),\n            code: \"TSK-001\".to_string(),\n            name: \"Implement Login\".to_string(),\n            description: None,\n            state: InProgress { progress: 50 },\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![\"Alice\".to_string()],\n        };\n        let task2: Task\u003cCompleted\u003e = Task {\n            id: uuid7(),\n            project_code: \"PROJ\".to_string(),\n            code: \"TSK-002\".to_string(),\n            name: \"Setup Database\".to_string(),\n            description: None,\n            state: Completed,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 2).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 5).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![\"Bob\".to_string(), \"Charlie\".to_string()],\n        };\n\n        let mut project: AnyProject = ProjectBuilder::new(\"Test Project\".to_string())\n            .code(\"PROJ-1\".to_string())\n            .build()\n            .into();\n        project.add_task(task1.into());\n        project.add_task(task2.into());\n\n        let mock_repo = MockProjectRepository { project };\n        let use_case = TaskReportUseCase::new(mock_repo);\n\n        // 2. Act: Executar e escrever para um buffer\n        let mut writer = Writer::from_writer(vec![]);\n        let result = use_case.execute(\u0026mut writer);\n        assert!(result.is_ok());\n\n        // 3. Assert: Verificar o conteúdo do CSV\n        let csv_data = String::from_utf8(writer.into_inner().unwrap()).unwrap();\n        let mut lines = csv_data.trim().lines();\n\n        assert_eq!(\n            lines.next().unwrap(),\n            \"Code,Name,Status,Progress,StartDate,DueDate,Assignees\"\n        );\n        let lines_set: std::collections::HashSet\u003c\u0026str\u003e = lines.collect();\n        assert!(lines_set.contains(\"TSK-001,Implement Login,InProgress,0,2025-01-01,2025-01-10,Alice\"));\n        assert!(lines_set.contains(\"TSK-002,Setup Database,Completed,100,2025-01-02,2025-01-05,\\\"Bob, Charlie\\\"\"));\n    }\n\n    #[test]\n    fn test_task_report_with_all_task_states() {\n        use crate::domain::task_management::state::{Planned, Blocked, Cancelled};\n\n        // Criar tarefas com todos os estados\n        let planned_task: Task\u003cPlanned\u003e = Task {\n            id: uuid7(),\n            project_code: \"PROJ\".to_string(),\n            code: \"TSK-PLAN\".to_string(),\n            name: \"Planning Phase\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![],\n        };\n\n        let blocked_task: Task\u003cBlocked\u003e = Task {\n            id: uuid7(),\n            project_code: \"PROJ\".to_string(),\n            code: \"TSK-BLOCK\".to_string(),\n            name: \"Blocked Task\".to_string(),\n            description: None,\n            state: Blocked { reason: \"Waiting for dependency\".to_string() },\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 5).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 20).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![\"Developer\".to_string()],\n        };\n\n        let cancelled_task: Task\u003cCancelled\u003e = Task {\n            id: uuid7(),\n            project_code: \"PROJ\".to_string(),\n            code: \"TSK-CANCEL\".to_string(),\n            name: \"Cancelled Task\".to_string(),\n            description: None,\n            state: Cancelled,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 25).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![],\n        };\n\n        let mut project: AnyProject = ProjectBuilder::new(\"All States Project\".to_string())\n            .code(\"PROJ-ALL\".to_string())\n            .build()\n            .into();\n        project.add_task(planned_task.into());\n        project.add_task(blocked_task.into());\n        project.add_task(cancelled_task.into());\n\n        let mock_repo = MockProjectRepository { project };\n        let use_case = TaskReportUseCase::new(mock_repo);\n\n        let mut writer = Writer::from_writer(vec![]);\n        let result = use_case.execute(\u0026mut writer);\n        assert!(result.is_ok());\n\n        let csv_data = String::from_utf8(writer.into_inner().unwrap()).unwrap();\n        let mut lines = csv_data.trim().lines();\n\n        // Verificar cabeçalho\n        assert_eq!(\n            lines.next().unwrap(),\n            \"Code,Name,Status,Progress,StartDate,DueDate,Assignees\"\n        );\n\n        let lines_set: std::collections::HashSet\u003c\u0026str\u003e = lines.collect();\n        \n        // Verificar todas as variantes de tarefas\n        assert!(lines_set.contains(\"TSK-PLAN,Planning Phase,Planned,0,2025-01-01,2025-01-15,\"));\n        assert!(lines_set.contains(\"TSK-BLOCK,Blocked Task,Blocked,N/A,2025-01-05,2025-01-20,Developer\"));\n        assert!(lines_set.contains(\"TSK-CANCEL,Cancelled Task,Cancelled,N/A,2025-01-10,2025-01-25,\"));\n    }\n\n    #[test]\n    fn test_task_report_with_empty_project() {\n        let project: AnyProject = ProjectBuilder::new(\"Empty Project\".to_string())\n            .code(\"PROJ-EMPTY\".to_string())\n            .build()\n            .into();\n\n        let mock_repo = MockProjectRepository { project };\n        let use_case = TaskReportUseCase::new(mock_repo);\n\n        let mut writer = Writer::from_writer(vec![]);\n        let result = use_case.execute(\u0026mut writer);\n        assert!(result.is_ok());\n\n        let csv_data = String::from_utf8(writer.into_inner().unwrap()).unwrap();\n        let mut lines = csv_data.trim().lines();\n\n        // Verificar que só tem o cabeçalho\n        assert_eq!(\n            lines.next().unwrap(),\n            \"Code,Name,Status,Progress,StartDate,DueDate,Assignees\"\n        );\n        assert_eq!(lines.next(), None);\n    }\n\n    #[test]\n    fn test_task_report_with_tasks_no_assigned_resources() {\n        use crate::domain::task_management::state::Planned;\n\n        let task: Task\u003cPlanned\u003e = Task {\n            id: uuid7(),\n            project_code: \"PROJ\".to_string(),\n            code: \"TSK-NO-RES\".to_string(),\n            name: \"No Resources Task\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![],\n        };\n\n        let mut project: AnyProject = ProjectBuilder::new(\"No Resources Project\".to_string())\n            .code(\"PROJ-NO-RES\".to_string())\n            .build()\n            .into();\n        project.add_task(task.into());\n\n        let mock_repo = MockProjectRepository { project };\n        let use_case = TaskReportUseCase::new(mock_repo);\n\n        let mut writer = Writer::from_writer(vec![]);\n        let result = use_case.execute(\u0026mut writer);\n        assert!(result.is_ok());\n\n        let csv_data = String::from_utf8(writer.into_inner().unwrap()).unwrap();\n        let mut lines = csv_data.trim().lines();\n\n        // Verificar cabeçalho\n        assert_eq!(\n            lines.next().unwrap(),\n            \"Code,Name,Status,Progress,StartDate,DueDate,Assignees\"\n        );\n\n        // Verificar tarefa sem recursos atribuídos\n        let task_line = lines.next().unwrap();\n        assert!(task_line.contains(\"TSK-NO-RES,No Resources Task,Planned,0,2025-01-01,2025-01-10,\"));\n    }\n\n    #[test]\n    fn test_task_report_with_multiple_assigned_resources() {\n        use crate::domain::task_management::state::InProgress;\n\n        let task: Task\u003cInProgress\u003e = Task {\n            id: uuid7(),\n            project_code: \"PROJ\".to_string(),\n            code: \"TSK-MULTI\".to_string(),\n            name: \"Multi Resource Task\".to_string(),\n            description: None,\n            state: InProgress { progress: 75 },\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![\n                \"Alice\".to_string(),\n                \"Bob\".to_string(),\n                \"Charlie\".to_string(),\n                \"Diana\".to_string(),\n            ],\n        };\n\n        let mut project: AnyProject = ProjectBuilder::new(\"Multi Resource Project\".to_string())\n            .code(\"PROJ-MULTI\".to_string())\n            .build()\n            .into();\n        project.add_task(task.into());\n\n        let mock_repo = MockProjectRepository { project };\n        let use_case = TaskReportUseCase::new(mock_repo);\n\n        let mut writer = Writer::from_writer(vec![]);\n        let result = use_case.execute(\u0026mut writer);\n        assert!(result.is_ok());\n\n        let csv_data = String::from_utf8(writer.into_inner().unwrap()).unwrap();\n        let mut lines = csv_data.trim().lines();\n\n        // Verificar cabeçalho\n        assert_eq!(\n            lines.next().unwrap(),\n            \"Code,Name,Status,Progress,StartDate,DueDate,Assignees\"\n        );\n\n        // Verificar tarefa com múltiplos recursos\n        let task_line = lines.next().unwrap();\n        assert!(task_line.contains(\"TSK-MULTI,Multi Resource Task,InProgress,0,2025-01-01,2025-01-15\"));\n        assert!(task_line.contains(\"Alice, Bob, Charlie, Diana\"));\n    }\n\n    #[test]\n    fn test_task_report_csv_formatting() {\n        use crate::domain::task_management::state::Completed;\n\n        let task: Task\u003cCompleted\u003e = Task {\n            id: uuid7(),\n            project_code: \"PROJ\".to_string(),\n            code: \"TSK-FORMAT\".to_string(),\n            name: \"Task with \\\"quotes\\\" and, commas\".to_string(),\n            description: None,\n            state: Completed,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![\"John \\\"The Developer\\\"\".to_string()],\n        };\n\n        let mut project: AnyProject = ProjectBuilder::new(\"Format Test Project\".to_string())\n            .code(\"PROJ-FORMAT\".to_string())\n            .build()\n            .into();\n        project.add_task(task.into());\n\n        let mock_repo = MockProjectRepository { project };\n        let use_case = TaskReportUseCase::new(mock_repo);\n\n        let mut writer = Writer::from_writer(vec![]);\n        let result = use_case.execute(\u0026mut writer);\n        assert!(result.is_ok());\n\n        let csv_data = String::from_utf8(writer.into_inner().unwrap()).unwrap();\n        let mut lines = csv_data.trim().lines();\n\n        // Verificar cabeçalho\n        assert_eq!(\n            lines.next().unwrap(),\n            \"Code,Name,Status,Progress,StartDate,DueDate,Assignees\"\n        );\n\n        // Verificar que o CSV lida corretamente com caracteres especiais\n        let task_line = lines.next().unwrap();\n        assert!(task_line.contains(\"TSK-FORMAT\"));\n        // O CSV escapa aspas e vírgulas, então vamos verificar o formato real\n        assert!(task_line.contains(\"Task with \\\"quotes\\\" and, commas\") || task_line.contains(\"Task with \\\"\\\"quotes\\\"\\\" and, commas\"));\n        assert!(task_line.contains(\"John \\\"The Developer\\\"\") || task_line.contains(\"John \\\"\\\"The Developer\\\"\\\"\"));\n    }\n\n    #[test]\n    fn test_task_report_repository_error() {\n        // Mock que sempre retorna erro\n        struct ErrorMockProjectRepository;\n\n        impl ProjectRepository for ErrorMockProjectRepository {\n            fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n                Err(DomainError::new(DomainErrorKind::Generic {\n                    message: \"Repository error\".to_string(),\n                }))\n            }\n            fn save(\u0026self, _project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n                unimplemented!()\n            }\n            fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n                unimplemented!()\n            }\n            fn find_by_code(\u0026self, _code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n                unimplemented!()\n            }\n            fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n                unimplemented!()\n            }\n        }\n\n        let mock_repo = ErrorMockProjectRepository;\n        let use_case = TaskReportUseCase::new(mock_repo);\n\n        let mut writer = Writer::from_writer(vec![]);\n        let result = use_case.execute(\u0026mut writer);\n        assert!(result.is_err());\n\n        let error = result.unwrap_err();\n        assert!(error.to_string().contains(\"Repository error\"));\n    }\n\n    #[test]\n    fn test_task_report_csv_writer_error() {\n        use crate::domain::task_management::state::Planned;\n\n        let task: Task\u003cPlanned\u003e = Task {\n            id: uuid7(),\n            project_code: \"PROJ\".to_string(),\n            code: \"TSK-ERROR\".to_string(),\n            name: \"Error Test Task\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![],\n        };\n\n        let mut project: AnyProject = ProjectBuilder::new(\"Error Test Project\".to_string())\n            .code(\"PROJ-ERROR\".to_string())\n            .build()\n            .into();\n        project.add_task(task.into());\n\n        let mock_repo = MockProjectRepository { project };\n        let use_case = TaskReportUseCase::new(mock_repo);\n\n        // Criar um writer que falha ao escrever\n        let mut writer = Writer::from_writer(vec![]);\n        let result = use_case.execute(\u0026mut writer);\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":13,"address":[2573184,2573216],"length":1,"stats":{"Line":1}},{"line":18,"address":[2576464,2579643,2582837,2582843,2576437,2573264,2576443,2579637,2579664],"length":1,"stats":{"Line":3}},{"line":20,"address":[2579997,2576797,2573332,2576532,2573597,2579732],"length":1,"stats":{"Line":3}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[2580038,2576838,2573638],"length":1,"stats":{"Line":3}},{"line":31,"address":[2573946,2573875,2580346,2577075,2580275,2577146],"length":1,"stats":{"Line":3}},{"line":34,"address":[2577334,2580534,2580392,2573992,2574134,2577192],"length":1,"stats":{"Line":3}},{"line":36,"address":[2574197,2581665,2577397,2580597,2578465,2575265],"length":1,"stats":{"Line":3}},{"line":38,"address":[2580980,2577735,2574535,2577780,2580935,2574580],"length":1,"stats":{"Line":2}},{"line":39,"address":[2577750,2580950,2574550],"length":1,"stats":{"Line":1}},{"line":40,"address":[2574557,2577757,2580957],"length":1,"stats":{"Line":1}},{"line":41,"address":[2574564,2580964,2577764],"length":1,"stats":{"Line":1}},{"line":42,"address":[2577770,2574570,2580970],"length":1,"stats":{"Line":1}},{"line":43,"address":[2580976,2574576,2577776],"length":1,"stats":{"Line":1}},{"line":47,"address":[2577930,2574730,2574685,2581085,2577885,2581130],"length":1,"stats":{"Line":2}},{"line":48,"address":[2577900,2574700,2581100],"length":1,"stats":{"Line":1}},{"line":49,"address":[2581107,2577907,2574707],"length":1,"stats":{"Line":1}},{"line":50,"address":[2581114,2577914,2574714],"length":1,"stats":{"Line":1}},{"line":51,"address":[2574720,2581120,2577920],"length":1,"stats":{"Line":1}},{"line":52,"address":[2574726,2577926,2581126],"length":1,"stats":{"Line":1}},{"line":56,"address":[2578178,2574978,2581423,2581378,2578223,2575023],"length":1,"stats":{"Line":2}},{"line":57,"address":[2574993,2578193,2581393],"length":1,"stats":{"Line":1}},{"line":58,"address":[2575000,2578200,2581400],"length":1,"stats":{"Line":1}},{"line":59,"address":[2581407,2575007,2578207],"length":1,"stats":{"Line":1}},{"line":60,"address":[2578213,2581413,2575013],"length":1,"stats":{"Line":1}},{"line":61,"address":[2575019,2578219,2581419],"length":1,"stats":{"Line":1}},{"line":65,"address":[2581235,2574835,2578035,2581273,2574873,2578073],"length":1,"stats":{"Line":2}},{"line":66,"address":[2574843,2578043,2581243],"length":1,"stats":{"Line":1}},{"line":67,"address":[2574850,2578050,2581250],"length":1,"stats":{"Line":1}},{"line":68,"address":[2574857,2578057,2581257],"length":1,"stats":{"Line":1}},{"line":69,"address":[2574863,2581263,2578063],"length":1,"stats":{"Line":1}},{"line":70,"address":[2574869,2581269,2578069],"length":1,"stats":{"Line":1}},{"line":74,"address":[2578373,2581573,2581528,2575128,2575173,2578328],"length":1,"stats":{"Line":2}},{"line":75,"address":[2575143,2578343,2581543],"length":1,"stats":{"Line":1}},{"line":76,"address":[2575150,2578350,2581550],"length":1,"stats":{"Line":1}},{"line":77,"address":[2578357,2581557,2575157],"length":1,"stats":{"Line":1}},{"line":78,"address":[2575163,2581563,2578363],"length":1,"stats":{"Line":1}},{"line":79,"address":[2575169,2578369,2581569],"length":1,"stats":{"Line":1}},{"line":85,"address":[2578653,2575453,2581853],"length":1,"stats":{"Line":2}},{"line":87,"address":[2579452,2579546,2582443,2582652,2576043,2576252,2576346,2579243,2582746],"length":1,"stats":{"Line":2}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[2578843,2581936,2575643,2578736,2582043,2575536],"length":1,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[2578911,2575711,2582111],"length":1,"stats":{"Line":2}},{"line":93,"address":[2582223,2579023,2575823],"length":1,"stats":{"Line":2}},{"line":94,"address":[2579127,2582327,2575927],"length":1,"stats":{"Line":2}},{"line":98,"address":[2577694,2577484,2580894,2574284,2574494,2580684],"length":1,"stats":{"Line":1}},{"line":99,"address":[2580819,2574419,2577619],"length":1,"stats":{"Line":1}}],"covered":45,"coverable":55},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","report","vacation.rs"],"content":"use crate::domain::{\n    project_management::repository::ProjectRepository, resource_management::repository::ResourceRepository,\n};\nuse csv::Writer;\nuse std::error::Error;\nuse std::io;\n\n/// `VacationReportUseCase` gera um relatório em formato CSV com os períodos de férias\n/// de todos os recursos, associados ao projeto atual.\n/// `VacationReportUseCase` gera um relatório em formato CSV com os períodos de férias\n/// de todos os recursos, associados ao projeto atual.\npub struct VacationReportUseCase\u003cP: ProjectRepository, R: ResourceRepository\u003e {\n    project_repository: P,\n    resource_repository: R,\n}\n\nimpl\u003cP: ProjectRepository, R: ResourceRepository\u003e VacationReportUseCase\u003cP, R\u003e {\n    /// Cria uma nova instância do caso de uso com os repositórios necessários.\n    pub fn new(project_repository: P, resource_repository: R) -\u003e Self {\n        Self {\n            project_repository,\n            resource_repository,\n        }\n    }\n\n    /// Executa a geração do relatório, escrevendo o resultado em um `Writer` fornecido.\n    ///\n    /// # Arguments\n    ///\n    /// * `writer` - Um `csv::Writer` para onde o relatório será escrito.\n    ///\n    /// # Errors\n    ///\n    /// Retorna um erro se houver falha ao carregar os dados dos repositórios ou\n    /// ao escrever no `writer`.\n    pub fn execute\u003cW: io::Write\u003e(\u0026self, writer: \u0026mut Writer\u003cW\u003e) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n        // Escrever o cabeçalho do CSV\n        writer.write_record([\"Recurso\", \"Projeto\", \"Data Início\", \"Data Fim\", \"Layoff\"])?;\n\n        // Carregar o projeto do diretório atual.\n        // A lógica assume que há um único projeto de referência no contexto.\n        let project = self.project_repository.load()?;\n        let resources = self.resource_repository.find_all()?;\n\n        // Iterar sobre os recursos e seus períodos de férias\n        for resource in resources {\n            if let Some(periods) = resource.vacations() {\n                for period in periods {\n                    writer.write_record([\n                        resource.name(),\n                        project.name(),\n                        \u0026period.start_date.to_rfc3339(),\n                        \u0026period.end_date.to_rfc3339(),\n                        \u0026period.is_layoff.to_string(),\n                    ])?;\n                }\n            }\n        }\n\n        // Garantir que todos os dados sejam escritos no buffer/arquivo\n        writer.flush()?;\n\n        Ok(())\n    }\n}\n\n// ===================================\n// TESTES\n// ===================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        project_management::{AnyProject, builder::ProjectBuilder},\n        resource_management::{\n            AnyResource,\n            resource::{Period, PeriodType, Resource},\n            state::Available,\n        },\n        shared::errors::DomainError,\n    };\n    use chrono::{Local, TimeZone};\n\n    // --- Mocks ---\n\n    struct MockProjectRepository {\n        project: AnyProject,\n    }\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, _project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            unimplemented!()\n        }\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            Ok(self.project.clone())\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(\"proj-1\".to_string())\n        }\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            if self.project.code() == code {\n                Ok(Some(self.project.clone()))\n            } else {\n                Ok(None)\n            }\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(vec![self.project.clone()])\n        }\n    }\n\n    struct MockResourceRepository {\n        resources: Vec\u003cAnyResource\u003e,\n    }\n    impl ResourceRepository for MockResourceRepository {\n        fn save(\u0026self, _resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.clone())\n        }\n        fn find_by_code(\u0026self, _code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(None)\n        }\n        fn save_time_off(\n            \u0026self,\n            _r: \u0026str,\n            _h: u32,\n            _d: \u0026str,\n            _desc: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn save_vacation(\n            \u0026self,\n            _r: \u0026str,\n            _s: \u0026str,\n            _e: \u0026str,\n            _i: bool,\n            _c: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn check_if_layoff_period(\u0026self, _s: \u0026chrono::DateTime\u003cLocal\u003e, _e: \u0026chrono::DateTime\u003cLocal\u003e) -\u003e bool {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self, resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(format!(\"{}-1\", resource_type.to_lowercase()))\n        }\n    }\n\n    // --- Teste Principal ---\n\n    #[test]\n    fn test_vacation_report_generation() {\n        // 1. Setup: Create test data\n        let project: AnyProject = ProjectBuilder::new(\"ProjetoTTR\".to_string())\n            .code(\"proj-1\".to_string())\n            .build()\n            .start()\n            .into();\n\n        let mut resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"Alice\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            None,\n            0,\n        );\n        resource1.vacations = Some(vec![Period {\n            start_date: Local.with_ymd_and_hms(2025, 7, 1, 9, 0, 0).unwrap(),\n            end_date: Local.with_ymd_and_hms(2025, 7, 10, 18, 0, 0).unwrap(),\n            approved: true,\n            period_type: PeriodType::Vacation,\n            is_time_off_compensation: false,\n            compensated_hours: None,\n            is_layoff: false,\n        }]);\n\n        let resource2 =\n            Resource::\u003cAvailable\u003e::new(\"qa-1\".to_string(), \"Bob\".to_string(), None, \"QA\".to_string(), None, 0); // No vacation\n\n        let mock_project_repo = MockProjectRepository { project };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = VacationReportUseCase::new(mock_project_repo, mock_resource_repo);\n\n        // 2. Act: Execute and write to a buffer\n        let mut writer = csv::Writer::from_writer(vec![]);\n        let result = use_case.execute(\u0026mut writer);\n        assert!(result.is_ok());\n\n        // 3. Assert: Verify the CSV content\n        let csv_data = String::from_utf8(writer.into_inner().unwrap()).unwrap();\n        let mut lines = csv_data.trim().lines();\n\n        assert_eq!(lines.next().unwrap(), \"Recurso,Projeto,Data Início,Data Fim,Layoff\");\n        let alice_line = lines.next().unwrap();\n        assert!(alice_line.starts_with(\"Alice,ProjetoTTR,\"));\n        assert!(alice_line.ends_with(\",false\"));\n        assert!(lines.next().is_none()); // Bob should not be in the report\n    }\n}\n","traces":[{"line":19,"address":[1444416,1444320],"length":1,"stats":{"Line":1}},{"line":36,"address":[1449995,1447163,1444480,1447224,1447248,1449934],"length":1,"stats":{"Line":1}},{"line":38,"address":[1447309,1444541],"length":1,"stats":{"Line":1}},{"line":42,"address":[1444801,1447569],"length":1,"stats":{"Line":1}},{"line":43,"address":[1447798,1447203,1447876,1445030,1449974,1445105],"length":1,"stats":{"Line":2}},{"line":46,"address":[1448124,1448355,1448228,1445457,1445584,1445353],"length":1,"stats":{"Line":3}},{"line":47,"address":[1448438,1445667,1446022,1448793],"length":1,"stats":{"Line":2}},{"line":48,"address":[1446101,1448929,1448872,1446158],"length":1,"stats":{"Line":2}},{"line":49,"address":[1446788,1447057,1449736,1446965,1449828,1449559],"length":1,"stats":{"Line":1}},{"line":50,"address":[1446276,1449047],"length":1,"stats":{"Line":1}},{"line":51,"address":[1446339,1449110],"length":1,"stats":{"Line":1}},{"line":52,"address":[1449167,1446396],"length":1,"stats":{"Line":1}},{"line":53,"address":[1446516,1449287],"length":1,"stats":{"Line":1}},{"line":54,"address":[1446636,1449407],"length":1,"stats":{"Line":1}},{"line":61,"address":[1445927,1448487,1448698,1445716],"length":1,"stats":{"Line":1}},{"line":63,"address":[1445851,1448622],"length":1,"stats":{"Line":1}}],"covered":16,"coverable":16},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","resource","deactivate_resource.rs"],"content":"use crate::domain::{\n    resource_management::{any_resource::AnyResource, repository::ResourceRepository},\n    shared::errors::DomainError,\n};\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum DeactivateResourceError {\n    #[error(\"Resource with code '{0}' not found.\")]\n    ResourceNotFound(String),\n    #[error(\"An unexpected domain rule was violated: {0}\")]\n    DomainError(String),\n    #[error(\"A repository error occurred: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\npub struct DeactivateResourceUseCase\u003cRR\u003e\nwhere\n    RR: ResourceRepository,\n{\n    resource_repository: RR,\n}\n\nimpl\u003cRR\u003e DeactivateResourceUseCase\u003cRR\u003e\nwhere\n    RR: ResourceRepository,\n{\n    pub fn new(resource_repository: RR) -\u003e Self {\n        Self { resource_repository }\n    }\n\n    pub fn execute(\u0026self, resource_code: \u0026str) -\u003e Result\u003cAnyResource, DeactivateResourceError\u003e {\n        // 1. Find the resource from the repository.\n        let resource = self\n            .resource_repository\n            .find_by_code(resource_code)?\n            .ok_or_else(|| DeactivateResourceError::ResourceNotFound(resource_code.to_string()))?;\n\n        // 2. Call the domain logic to deactivate the resource.\n        // This consumes the resource and returns a new one in the `Inactive` state.\n        let deactivated_resource = resource.deactivate().map_err(DeactivateResourceError::DomainError)?;\n\n        // 3. Save the now-inactive resource back to the repository.\n        let saved_resource = self.resource_repository.save(deactivated_resource)?;\n\n        Ok(saved_resource)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::resource_management::{resource::Resource, state::Available};\n    use std::{cell::RefCell, collections::HashMap};\n    use uuid7::uuid7;\n\n    // --- Mocks ---\n    #[derive(Clone)]\n    struct MockResourceRepository {\n        resources: RefCell\u003cHashMap\u003cString, AnyResource\u003e\u003e,\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn save(\u0026self, resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            self.resources\n                .borrow_mut()\n                .insert(resource.code().to_string(), resource.clone());\n            Ok(resource)\n        }\n\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.borrow().get(code).cloned())\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self, _resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n        fn save_time_off(\n            \u0026self,\n            _name: \u0026str,\n            _hours: u32,\n            _date: \u0026str,\n            _desc: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn save_vacation(\n            \u0026self,\n            _name: \u0026str,\n            _start: \u0026str,\n            _end: \u0026str,\n            _comp: bool,\n            _hours: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn check_if_layoff_period(\n            \u0026self,\n            _start: \u0026chrono::DateTime\u003cchrono::Local\u003e,\n            _end: \u0026chrono::DateTime\u003cchrono::Local\u003e,\n        ) -\u003e bool {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_resource(code: \u0026str) -\u003e AnyResource {\n        Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: code.to_string(),\n            name: \"Test Resource\".to_string(),\n            email: None,\n            resource_type: \"Test\".to_string(),\n            vacations: None,\n            time_off_balance: 0,\n            time_off_history: None,\n            state: Available,\n        }\n        .into()\n    }\n\n    // --- Tests ---\n    // TODO: Enable this test once `AnyResource::deactivate` and `AnyResource::status` are implemented.\n\n    #[test]\n    fn test_deactivate_resource_success() {\n        let initial_resource = create_test_resource(\"RES-1\");\n        let resource_repo = MockResourceRepository {\n            resources: RefCell::new(HashMap::from([(initial_resource.code().to_string(), initial_resource)])),\n        };\n        let use_case = DeactivateResourceUseCase::new(resource_repo.clone());\n\n        let result = use_case.execute(\"RES-1\");\n\n        assert!(result.is_ok());\n\n        let deactivated_resource = result.unwrap();\n        assert_eq!(deactivated_resource.status(), \"Inactive\");\n    }\n\n    #[test]\n    fn test_deactivate_resource_fails_if_not_found() {\n        let resource_repo = MockResourceRepository {\n            resources: RefCell::new(HashMap::new()),\n        };\n        let use_case = DeactivateResourceUseCase::new(resource_repo);\n\n        let result = use_case.execute(\"RES-NONEXISTENT\");\n\n        assert!(matches!(result, Err(DeactivateResourceError::ResourceNotFound(_))));\n    }\n}\n","traces":[{"line":28,"address":[2652256,2652224],"length":1,"stats":{"Line":1}},{"line":32,"address":[2654831,2654849,2653535,2652288,2653553,2653584],"length":1,"stats":{"Line":1}},{"line":34,"address":[2652344,2652373,2653844,2653937,2652466,2652641,2653669,2652548,2653762,2653640],"length":1,"stats":{"Line":4}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[2653656,2652431,2652360,2653727],"length":1,"stats":{"Line":1}},{"line":37,"address":[2653823,2654903,2654976,2654880,2652606,2654999,2653902,2652527],"length":1,"stats":{"Line":4}},{"line":41,"address":[2652764,2654160,2654837,2652864,2654060,2653541],"length":1,"stats":{"Line":2}},{"line":44,"address":[2653260,2654451,2654556,2654801,2653505,2653155],"length":1,"stats":{"Line":2}},{"line":46,"address":[2653458,2654754],"length":1,"stats":{"Line":1}}],"covered":8,"coverable":9},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","resource","describe_resource.rs"],"content":"use crate::domain::{\n    resource_management::{any_resource::AnyResource, repository::ResourceRepository},\n    shared::errors::DomainError,\n};\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum DescribeResourceError {\n    #[error(\"Resource with code '{0}' not found.\")]\n    ResourceNotFound(String),\n    #[error(\"A repository error occurred: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\npub struct DescribeResourceUseCase\u003cRR\u003e\nwhere\n    RR: ResourceRepository,\n{\n    resource_repository: RR,\n}\n\nimpl\u003cRR\u003e DescribeResourceUseCase\u003cRR\u003e\nwhere\n    RR: ResourceRepository,\n{\n    pub fn new(resource_repository: RR) -\u003e Self {\n        Self { resource_repository }\n    }\n\n    pub fn execute(\u0026self, resource_code: \u0026str) -\u003e Result\u003cAnyResource, DescribeResourceError\u003e {\n        self.resource_repository\n            .find_by_code(resource_code)?\n            .ok_or_else(|| DescribeResourceError::ResourceNotFound(resource_code.to_string()))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        resource_management::{resource::Resource, state::Available},\n        shared::errors::DomainError,\n    };\n    use std::{cell::RefCell, collections::HashMap};\n    use uuid7::uuid7;\n\n    // --- Mocks ---\n    struct MockResourceRepository {\n        resources: RefCell\u003cHashMap\u003cString, AnyResource\u003e\u003e,\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn save(\u0026self, _resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.borrow().get(code).cloned())\n        }\n\n        // Other methods are not needed for this test.\n        fn get_next_code(\u0026self, _resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n        fn save_time_off(\n            \u0026self,\n            _name: \u0026str,\n            _hours: u32,\n            _date: \u0026str,\n            _desc: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn save_vacation(\n            \u0026self,\n            _name: \u0026str,\n            _start: \u0026str,\n            _end: \u0026str,\n            _comp: bool,\n            _hours: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn check_if_layoff_period(\n            \u0026self,\n            _start: \u0026chrono::DateTime\u003cchrono::Local\u003e,\n            _end: \u0026chrono::DateTime\u003cchrono::Local\u003e,\n        ) -\u003e bool {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_resource(code: \u0026str) -\u003e AnyResource {\n        Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: code.to_string(),\n            name: \"Test Resource\".to_string(),\n            email: Some(\"test@resource.com\".to_string()),\n            resource_type: \"Test\".to_string(),\n            vacations: None,\n            time_off_balance: 16,\n            time_off_history: None,\n            state: Available,\n        }\n        .into()\n    }\n\n    #[test]\n    fn test_describe_resource_success() {\n        let resource_code = \"RES-1\";\n        let resource = create_test_resource(resource_code);\n        let resource_repo = MockResourceRepository {\n            resources: RefCell::new(HashMap::from([(resource.code().to_string(), resource)])),\n        };\n        let use_case = DescribeResourceUseCase::new(resource_repo);\n\n        let result = use_case.execute(resource_code);\n\n        assert!(result.is_ok());\n        let found_resource = result.unwrap();\n        assert_eq!(found_resource.code(), resource_code);\n        assert_eq!(found_resource.name(), \"Test Resource\");\n    }\n\n    #[test]\n    fn test_describe_resource_not_found() {\n        let resource_repo = MockResourceRepository {\n            resources: RefCell::new(HashMap::new()),\n        };\n        let use_case = DescribeResourceUseCase::new(resource_repo);\n\n        let result = use_case.execute(\"RES-NONEXISTENT\");\n\n        assert!(matches!(result, Err(DescribeResourceError::ResourceNotFound(_))));\n    }\n}\n","traces":[{"line":26,"address":[1709104,1709136],"length":1,"stats":{"Line":1}},{"line":30,"address":[1709408,1709168],"length":1,"stats":{"Line":1}},{"line":31,"address":[1709231,1709471,1709555,1709315],"length":1,"stats":{"Line":2}},{"line":32,"address":[1709523,1709283,1709458,1709218],"length":1,"stats":{"Line":1}},{"line":33,"address":[1709374,1709614,1709648,1709767,1709744,1709671],"length":1,"stats":{"Line":4}}],"covered":5,"coverable":5},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","resource","mod.rs"],"content":"pub mod deactivate_resource;\npub mod describe_resource;\npub mod update_resource;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","resource","update_resource.rs"],"content":"use crate::domain::{\n    resource_management::{any_resource::AnyResource, repository::ResourceRepository},\n    shared::errors::DomainError,\n};\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum UpdateResourceError {\n    #[error(\"Resource with code '{0}' not found.\")]\n    ResourceNotFound(String),\n\n    #[error(\"A repository error occurred: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\n#[derive(Debug, Clone, Default)]\npub struct UpdateResourceArgs {\n    pub name: Option\u003cString\u003e,\n    pub email: Option\u003cString\u003e,\n    pub resource_type: Option\u003cString\u003e,\n}\n\npub struct UpdateResourceUseCase\u003cRR\u003e\nwhere\n    RR: ResourceRepository,\n{\n    resource_repository: RR,\n}\n\nimpl\u003cRR\u003e UpdateResourceUseCase\u003cRR\u003e\nwhere\n    RR: ResourceRepository,\n{\n    pub fn new(resource_repository: RR) -\u003e Self {\n        Self { resource_repository }\n    }\n\n    pub fn execute(\u0026self, resource_code: \u0026str, args: UpdateResourceArgs) -\u003e Result\u003cAnyResource, UpdateResourceError\u003e {\n        // 1. Load the resource aggregate.\n        let mut resource = self\n            .resource_repository\n            .find_by_code(resource_code)?\n            .ok_or_else(|| UpdateResourceError::ResourceNotFound(resource_code.to_string()))?;\n\n        // 2. Update the fields on the aggregate.\n        // In a more complex scenario, this would be a method on the `AnyResource`\n        // aggregate to enforce invariants. For simple field updates, this is acceptable.\n        if let Some(name) = args.name {\n            resource.set_name(name);\n        }\n        if let Some(email) = args.email {\n            resource.set_email(Some(email));\n        }\n        if let Some(resource_type) = args.resource_type {\n            resource.set_resource_type(resource_type);\n        }\n\n        // 3. Save the updated resource aggregate.\n        // The repository's `save` method should handle the update.\n        let updated_resource = self.resource_repository.save(resource)?;\n\n        // 4. Return the updated resource.\n        Ok(updated_resource)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::resource_management::{resource::Resource, state::Available};\n    use std::{cell::RefCell, collections::HashMap};\n    use uuid7::uuid7;\n\n    // --- Mocks ---\n    struct MockResourceRepository {\n        resources: RefCell\u003cHashMap\u003cString, AnyResource\u003e\u003e,\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn save(\u0026self, resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            self.resources\n                .borrow_mut()\n                .insert(resource.code().to_string(), resource.clone());\n            Ok(resource)\n        }\n\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.borrow().get(code).cloned())\n        }\n\n        // Other methods are not needed for this test.\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self, _resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n        fn save_time_off(\n            \u0026self,\n            _name: \u0026str,\n            _hours: u32,\n            _date: \u0026str,\n            _desc: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn save_vacation(\n            \u0026self,\n            _name: \u0026str,\n            _start: \u0026str,\n            _end: \u0026str,\n            _comp: bool,\n            _hours: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n        fn check_if_layoff_period(\n            \u0026self,\n            _start: \u0026chrono::DateTime\u003cchrono::Local\u003e,\n            _end: \u0026chrono::DateTime\u003cchrono::Local\u003e,\n        ) -\u003e bool {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_resource(code: \u0026str, name: \u0026str, email: \u0026str, r#type: \u0026str) -\u003e AnyResource {\n        Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: code.to_string(),\n            name: name.to_string(),\n            email: Some(email.to_string()),\n            resource_type: r#type.to_string(),\n            vacations: None,\n            time_off_balance: 0,\n            time_off_history: None,\n            state: Available,\n        }\n        .into()\n    }\n\n    #[test]\n    fn test_update_resource_name_and_email_success() {\n        let initial_resource = create_test_resource(\"DEV-1\", \"Old Name\", \"old@test.com\", \"Developer\");\n        let resource_repo = MockResourceRepository {\n            resources: RefCell::new(HashMap::from([(initial_resource.code().to_string(), initial_resource)])),\n        };\n        let use_case = UpdateResourceUseCase::new(resource_repo);\n\n        let args = UpdateResourceArgs {\n            name: Some(\"New Name\".to_string()),\n            email: Some(\"new@test.com\".to_string()),\n            resource_type: None,\n        };\n\n        let result = use_case.execute(\"DEV-1\", args);\n\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        assert_eq!(updated_resource.name(), \"New Name\");\n        assert_eq!(updated_resource.email().unwrap(), \"new@test.com\");\n        assert_eq!(updated_resource.resource_type(), \"Developer\"); // Should not change\n    }\n\n    #[test]\n    fn test_update_resource_fails_if_not_found() {\n        let resource_repo = MockResourceRepository {\n            resources: RefCell::new(HashMap::new()),\n        };\n        let use_case = UpdateResourceUseCase::new(resource_repo);\n\n        let args = UpdateResourceArgs {\n            name: Some(\"New Name\".to_string()),\n            ..Default::default()\n        };\n\n        let result = use_case.execute(\"DEV-NONEXISTENT\", args);\n\n        assert!(matches!(result, Err(UpdateResourceError::ResourceNotFound(_))));\n    }\n}\n","traces":[{"line":34,"address":[1426112,1426144],"length":1,"stats":{"Line":2}},{"line":38,"address":[1426176,1427784,1428592,1430311,1427895,1430200],"length":1,"stats":{"Line":2}},{"line":40,"address":[1428653,1426641,1428951,1429202,1428806,1426786,1426535,1426237,1429057,1430448,1428032,1426390],"length":1,"stats":{"Line":7}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[1428717,1426301,1426439,1428855],"length":1,"stats":{"Line":2}},{"line":43,"address":[1429106,1431008,1431031,1429034,1426618,1431104,1431127,1426690],"length":1,"stats":{"Line":5}},{"line":48,"address":[1426873,1429289],"length":1,"stats":{"Line":1}},{"line":49,"address":[1429370,1426954,1429461,1427045],"length":1,"stats":{"Line":2}},{"line":51,"address":[1429468,1427052,1429382,1426966],"length":1,"stats":{"Line":2}},{"line":52,"address":[1427176,1429500,1427084,1429592],"length":1,"stats":{"Line":2}},{"line":54,"address":[1427183,1429599,1429557,1427141],"length":1,"stats":{"Line":1}},{"line":55,"address":[1427298,1429714,1429644,1427228],"length":1,"stats":{"Line":0}},{"line":60,"address":[1429732,1427316,1429651,1427968,1427235,1430384],"length":1,"stats":{"Line":2}},{"line":63,"address":[1429933,1427517],"length":1,"stats":{"Line":1}}],"covered":12,"coverable":14},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","task","assign_resource.rs"],"content":"use crate::domain::{\n    resource_management::{AnyResource, repository::ResourceRepository},\n    shared::errors::DomainError,\n    task_management::{AnyTask, repository::TaskRepository},\n};\n\n#[derive(Debug, thiserror::Error)]\npub enum AssignResourceError {\n    #[error(\"Task with code '{0}' not found\")]\n    TaskNotFound(String),\n    #[error(\"Resource with code '{0}' not found\")]\n    ResourceNotFound(String),\n    #[error(\"Project '{0}' not found for task\")]\n    ProjectNotFound(String),\n    #[error(\"Resource '{0}' is not available for assignment\")]\n    ResourceNotAvailable(String),\n    #[error(\"Repository error: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\npub struct AssignResourceToTaskUseCase\u003cTR, RR\u003e\nwhere\n    TR: TaskRepository,\n    RR: ResourceRepository,\n{\n    task_repository: TR,\n    resource_repository: RR,\n}\n\nimpl\u003cTR, RR\u003e AssignResourceToTaskUseCase\u003cTR, RR\u003e\nwhere\n    TR: TaskRepository,\n    RR: ResourceRepository,\n{\n    pub fn new(task_repository: TR, resource_repository: RR) -\u003e Self {\n        Self {\n            task_repository,\n            resource_repository,\n        }\n    }\n\n    pub fn execute(\u0026self, task_code: \u0026str, resource_code: \u0026str) -\u003e Result\u003cAnyTask, AssignResourceError\u003e {\n        // 1. Find the task\n        let task = self\n            .task_repository\n            .find_by_code(task_code)?\n            .ok_or_else(|| AssignResourceError::TaskNotFound(task_code.to_string()))?;\n\n        // 2. Find the resource\n        let resource = self\n            .resource_repository\n            .find_by_code(resource_code)?\n            .ok_or_else(|| AssignResourceError::ResourceNotFound(resource_code.to_string()))?;\n\n        // 3. Validate resource availability\n        if !self.is_resource_available(\u0026resource) {\n            return Err(AssignResourceError::ResourceNotAvailable(resource_code.to_string()));\n        }\n\n        // 4. Assign resource to task (this will be implemented in the domain)\n        let updated_task = self.assign_resource_to_task(task, resource)?;\n\n        // 5. Save the updated task\n        self.task_repository.save(updated_task.clone())?;\n\n        Ok(updated_task)\n    }\n\n    fn is_resource_available(\u0026self, _resource: \u0026AnyResource) -\u003e bool {\n        // For now, consider all resources available\n        // This can be enhanced with business logic later\n        true\n    }\n\n    fn assign_resource_to_task(\u0026self, task: AnyTask, _resource: AnyResource) -\u003e Result\u003cAnyTask, AssignResourceError\u003e {\n        // This will be implemented in the domain layer\n        // For now, return the task as-is\n        Ok(task)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{resource_management::resource::Resource, task_management::builder::TaskBuilder};\n    use chrono::NaiveDate;\n    use std::{cell::RefCell, collections::HashMap};\n\n    // --- Mocks ---\n    struct MockTaskRepository {\n        tasks: RefCell\u003cHashMap\u003cString, AnyTask\u003e\u003e,\n    }\n\n    impl TaskRepository for MockTaskRepository {\n        fn save(\u0026self, task: AnyTask) -\u003e Result\u003cAnyTask, DomainError\u003e {\n            self.tasks.borrow_mut().insert(task.code().to_string(), task.clone());\n            Ok(task)\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyTask\u003e, DomainError\u003e {\n            Ok(self.tasks.borrow().values().cloned().collect())\n        }\n\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyTask\u003e, DomainError\u003e {\n            Ok(self.tasks.borrow().get(code).cloned())\n        }\n\n        fn find_by_project(\u0026self, _project_code: \u0026str) -\u003e Result\u003cVec\u003cAnyTask\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn get_next_code(\u0026self, _project_code: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    struct MockResourceRepository {\n        resources: RefCell\u003cHashMap\u003cString, AnyResource\u003e\u003e,\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn save(\u0026self, resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            self.resources\n                .borrow_mut()\n                .insert(resource.code().to_string(), resource.clone());\n            Ok(resource)\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.borrow().values().cloned().collect())\n        }\n\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.borrow().get(code).cloned())\n        }\n\n        fn save_time_off(\n            \u0026self,\n            _resource_name: \u0026str,\n            _hours: u32,\n            _date: \u0026str,\n            _description: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn save_vacation(\n            \u0026self,\n            _resource_name: \u0026str,\n            _start_date: \u0026str,\n            _end_date: \u0026str,\n            _is_time_off_compensation: bool,\n            _compensated_hours: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn check_if_layoff_period(\n            \u0026self,\n            _start_date: \u0026chrono::DateTime\u003cchrono::Local\u003e,\n            _end_date: \u0026chrono::DateTime\u003cchrono::Local\u003e,\n        ) -\u003e bool {\n            unimplemented!()\n        }\n\n        fn get_next_code(\u0026self, _resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_task(code: \u0026str, name: \u0026str, project_code: \u0026str) -\u003e AnyTask {\n        TaskBuilder::new()\n            .project_code(project_code.to_string())\n            .name(name.to_string())\n            .code(code.to_string())\n            .dates(\n                NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n                NaiveDate::from_ymd_opt(2024, 12, 31).unwrap(),\n            )\n            .unwrap()\n            .assign_resource(\"RES-001\")\n            .validate_vacations(\u0026[])\n            .unwrap()\n            .build()\n            .unwrap()\n            .into()\n    }\n\n    fn create_test_resource(code: \u0026str, name: \u0026str, resource_type: \u0026str) -\u003e AnyResource {\n        Resource::new(\n            code.to_string(),\n            name.to_string(),\n            None,\n            resource_type.to_string(),\n            None,\n            0,\n        )\n        .into()\n    }\n\n    // --- Tests ---\n    #[test]\n    fn test_assign_resource_to_task_success() {\n        // Arrange\n        let task = create_test_task(\"TASK-001\", \"Test Task\", \"PROJ-001\");\n        let resource = create_test_resource(\"RES-001\", \"Test Resource\", \"developer\");\n\n        let task_repo = MockTaskRepository {\n            tasks: RefCell::new(HashMap::from([(task.code().to_string(), task.clone())])),\n        };\n        let resource_repo = MockResourceRepository {\n            resources: RefCell::new(HashMap::from([(resource.code().to_string(), resource.clone())])),\n        };\n\n        let use_case = AssignResourceToTaskUseCase::new(task_repo, resource_repo);\n\n        // Act\n        let result = use_case.execute(\"TASK-001\", \"RES-001\");\n\n        // Assert\n        assert!(result.is_ok());\n        let updated_task = result.unwrap();\n        assert_eq!(updated_task.code(), \"TASK-001\");\n    }\n\n    #[test]\n    fn test_assign_resource_task_not_found() {\n        // Arrange\n        let resource = create_test_resource(\"RES-001\", \"Test Resource\", \"developer\");\n\n        let task_repo = MockTaskRepository {\n            tasks: RefCell::new(HashMap::new()),\n        };\n        let resource_repo = MockResourceRepository {\n            resources: RefCell::new(HashMap::from([(resource.code().to_string(), resource.clone())])),\n        };\n\n        let use_case = AssignResourceToTaskUseCase::new(task_repo, resource_repo);\n\n        // Act\n        let result = use_case.execute(\"NONEXISTENT-TASK\", \"RES-001\");\n\n        // Assert\n        assert!(matches!(result, Err(AssignResourceError::TaskNotFound(_))));\n    }\n\n    #[test]\n    fn test_assign_resource_resource_not_found() {\n        // Arrange\n        let task = create_test_task(\"TASK-001\", \"Test Task\", \"PROJ-001\");\n\n        let task_repo = MockTaskRepository {\n            tasks: RefCell::new(HashMap::from([(task.code().to_string(), task.clone())])),\n        };\n        let resource_repo = MockResourceRepository {\n            resources: RefCell::new(HashMap::new()),\n        };\n\n        let use_case = AssignResourceToTaskUseCase::new(task_repo, resource_repo);\n\n        // Act\n        let result = use_case.execute(\"TASK-001\", \"NONEXISTENT-RESOURCE\");\n\n        // Assert\n        assert!(matches!(result, Err(AssignResourceError::ResourceNotFound(_))));\n    }\n}\n","traces":[{"line":35,"address":[261584],"length":1,"stats":{"Line":1}},{"line":42,"address":[261648,264023,263930],"length":1,"stats":{"Line":1}},{"line":44,"address":[262075,261891,261766,261795,261979],"length":1,"stats":{"Line":4}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[261853,261782],"length":1,"stats":{"Line":1}},{"line":47,"address":[261958,262037,264064,264087],"length":1,"stats":{"Line":4}},{"line":50,"address":[263994,262220,262718,262566,262296,262448],"length":1,"stats":{"Line":7}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[262352,262232],"length":1,"stats":{"Line":2}},{"line":53,"address":[262622,264183,262543,264160],"length":1,"stats":{"Line":5}},{"line":56,"address":[262839,262895],"length":1,"stats":{"Line":2}},{"line":57,"address":[263069,262917],"length":1,"stats":{"Line":0}},{"line":61,"address":[263936,262936,263207],"length":1,"stats":{"Line":2}},{"line":64,"address":[263472,263543],"length":1,"stats":{"Line":2}},{"line":66,"address":[263828],"length":1,"stats":{"Line":1}},{"line":69,"address":[264256],"length":1,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[264272],"length":1,"stats":{"Line":1}},{"line":78,"address":[264307],"length":1,"stats":{"Line":1}}],"covered":15,"coverable":19},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","task","delete_task.rs"],"content":"use crate::domain::{\n    project_management::repository::ProjectRepository, shared::errors::DomainError, task_management::any_task::AnyTask,\n};\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum CancelTaskError {\n    #[error(\"Project with code '{0}' not found.\")]\n    ProjectNotFound(String),\n    #[error(\"Task with code '{0}' not found in project.\")]\n    TaskNotFound(String),\n    #[error(\"An unexpected domain rule was violated: {0}\")]\n    DomainError(String),\n    #[error(\"A repository error occurred: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\npub struct CancelTaskUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    project_repository: PR,\n}\n\nimpl\u003cPR\u003e CancelTaskUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    pub fn new(project_repository: PR) -\u003e Self {\n        Self { project_repository }\n    }\n\n    pub fn execute(\u0026self, project_code: \u0026str, task_code: \u0026str) -\u003e Result\u003cAnyTask, CancelTaskError\u003e {\n        // 1. Load the project aggregate.\n        let mut project = self\n            .project_repository\n            .find_by_code(project_code)?\n            .ok_or_else(|| CancelTaskError::ProjectNotFound(project_code.to_string()))?;\n\n        // 2. Delegate the cancellation to the project aggregate.\n        project.cancel_task(task_code).map_err(CancelTaskError::DomainError)?;\n\n        // 3. Save the updated project aggregate.\n        self.project_repository.save(project.clone())?;\n\n        // 4. Return the updated (cancelled) task.\n        let cancelled_task = project\n            .tasks()\n            .get(task_code)\n            .cloned()\n            .ok_or_else(|| CancelTaskError::TaskNotFound(task_code.to_string()))?;\n\n        Ok(cancelled_task)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        project_management::{AnyProject, builder::ProjectBuilder},\n        task_management::{state::Planned, task::Task},\n    };\n    use chrono::NaiveDate;\n    use std::{cell::RefCell, collections::HashMap};\n    use uuid7::uuid7;\n\n    // --- Mocks ---\n    #[derive(Clone)]\n    struct MockProjectRepository {\n        projects: RefCell\u003cHashMap\u003cString, AnyProject\u003e\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            self.projects.borrow_mut().insert(project.code().to_string(), project);\n            Ok(())\n        }\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().get(code).cloned())\n        }\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_task(code: \u0026str) -\u003e AnyTask {\n        Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-1\".to_string(),\n            code: code.to_string(),\n            name: \"Test Task\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![],\n        }\n        .into()\n    }\n\n    fn setup_test_project(tasks: Vec\u003cAnyTask\u003e) -\u003e AnyProject {\n        let mut project: AnyProject = ProjectBuilder::new(\"Test Project\".to_string())\n            .code(\"PROJ-1\".to_string())\n            .build()\n            .into();\n        for task in tasks {\n            project.add_task(task);\n        }\n        project\n    }\n\n    // --- Tests ---\n\n    #[test]\n    fn test_cancel_task_fails_if_project_not_found() {\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::new()),\n        };\n        let use_case = CancelTaskUseCase::new(project_repo);\n\n        let result = use_case.execute(\"PROJ-NONEXISTENT\", \"TSK-1\");\n        assert!(matches!(result, Err(CancelTaskError::ProjectNotFound(_))));\n    }\n\n    // TODO: Enable this test once `AnyProject::cancel_task` is implemented.\n\n    #[test]\n    fn test_cancel_task_success() {\n        // This requires `cancel_task` to be implemented on the real `AnyProject`\n        let project = setup_test_project(vec![create_test_task(\"TSK-1\")]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n        let use_case = CancelTaskUseCase::new(project_repo.clone());\n\n        let result = use_case.execute(\"PROJ-1\", \"TSK-1\");\n\n        assert!(result.is_ok());\n        let cancelled_task = result.unwrap();\n        assert_eq!(cancelled_task.status(), \"Cancelled\");\n    }\n}\n","traces":[{"line":29,"address":[3134304,3134272],"length":1,"stats":{"Line":1}},{"line":33,"address":[3135638,3136966,3134336,3136972,3135664,3135644],"length":1,"stats":{"Line":1}},{"line":35,"address":[3134515,3134681,3135843,3135759,3136009,3134597,3135925,3134431],"length":1,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[3135808,3135746,3134480,3134418],"length":1,"stats":{"Line":1}},{"line":38,"address":[3137088,3137015,3137111,3136992,3134576,3135974,3134646,3135904],"length":1,"stats":{"Line":4}},{"line":41,"address":[3134861,3135636,3136964,3134801,3136129,3136189],"length":1,"stats":{"Line":2}},{"line":44,"address":[3136962,3135634,3136386,3135058],"length":1,"stats":{"Line":1}},{"line":47,"address":[3136948,3135620,3135381,3136709,3136854,3135526],"length":1,"stats":{"Line":1}},{"line":49,"address":[3135302,3136630],"length":1,"stats":{"Line":1}},{"line":51,"address":[3135430,3137184,3136686,3135358,3137303,3137207,3137280,3136758],"length":1,"stats":{"Line":1}},{"line":53,"address":[3136907,3135579],"length":1,"stats":{"Line":1}}],"covered":11,"coverable":12},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","task","describe_task.rs"],"content":"use crate::domain::{\n    project_management::repository::ProjectRepository, shared::errors::DomainError, task_management::any_task::AnyTask,\n};\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum DescribeTaskError {\n    #[error(\"Project with code '{0}' not found.\")]\n    ProjectNotFound(String),\n    #[error(\"Task with code '{0}' not found in project '{1}'.\")]\n    TaskNotFound(String, String),\n    #[error(\"A repository error occurred: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\npub struct DescribeTaskUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    project_repository: PR,\n}\n\nimpl\u003cPR\u003e DescribeTaskUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    pub fn new(project_repository: PR) -\u003e Self {\n        Self { project_repository }\n    }\n\n    pub fn execute(\u0026self, project_code: \u0026str, task_code: \u0026str) -\u003e Result\u003cAnyTask, DescribeTaskError\u003e {\n        let project = self\n            .project_repository\n            .find_by_code(project_code)?\n            .ok_or_else(|| DescribeTaskError::ProjectNotFound(project_code.to_string()))?;\n\n        let task = project\n            .tasks()\n            .get(task_code)\n            .cloned()\n            .ok_or_else(|| DescribeTaskError::TaskNotFound(task_code.to_string(), project_code.to_string()))?;\n\n        Ok(task)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::project_management::any_project::AnyProject;\n    use crate::domain::{\n        project_management::builder::ProjectBuilder,\n        task_management::{state::Planned, task::Task},\n    };\n    use chrono::NaiveDate;\n    use std::{cell::RefCell, collections::HashMap};\n    use uuid7::uuid7;\n\n    // --- Mocks ---\n    struct MockProjectRepository {\n        projects: RefCell\u003cHashMap\u003cString, AnyProject\u003e\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, _project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().get(code).cloned())\n        }\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_task(code: \u0026str) -\u003e AnyTask {\n        Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-1\".to_string(),\n            code: code.to_string(),\n            name: \"Test Task\".to_string(),\n            description: Some(\"A test task.\".to_string()),\n            state: Planned,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![\"dev-1\".to_string()],\n        }\n        .into()\n    }\n\n    fn create_test_project(code: \u0026str, tasks: Vec\u003cAnyTask\u003e) -\u003e AnyProject {\n        let mut project: AnyProject = ProjectBuilder::new(\"Test Project\".to_string())\n            .code(code.to_string())\n            .build()\n            .into();\n        for task in tasks {\n            project.add_task(task);\n        }\n        project\n    }\n\n    #[test]\n    fn test_describe_task_success() {\n        let project_code = \"PROJ-1\";\n        let task_code = \"TSK-1\";\n        let project = create_test_project(project_code, vec![create_test_task(task_code)]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project_code.to_string(), project)])),\n        };\n        let use_case = DescribeTaskUseCase::new(project_repo);\n\n        let result = use_case.execute(project_code, task_code);\n\n        assert!(result.is_ok());\n        let found_task = result.unwrap();\n        assert_eq!(found_task.code(), task_code);\n        assert!(!found_task.assigned_resources().is_empty());\n    }\n\n    #[test]\n    fn test_describe_task_not_found() {\n        let project_code = \"PROJ-1\";\n        let project = create_test_project(project_code, vec![]); // No tasks\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project_code.to_string(), project)])),\n        };\n        let use_case = DescribeTaskUseCase::new(project_repo);\n\n        let result = use_case.execute(project_code, \"TSK-NONEXISTENT\");\n\n        assert!(matches!(result, Err(DescribeTaskError::TaskNotFound(_, _))));\n    }\n\n    #[test]\n    fn test_describe_task_project_not_found() {\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::new()),\n        };\n        let use_case = DescribeTaskUseCase::new(project_repo);\n\n        let result = use_case.execute(\"PROJ-NONEXISTENT\", \"TSK-1\");\n\n        assert!(matches!(result, Err(DescribeTaskError::ProjectNotFound(_))));\n    }\n}\n","traces":[{"line":27,"address":[2235696,2235664],"length":1,"stats":{"Line":1}},{"line":31,"address":[2236616,2236640,2235728,2236622,2237528,2237534],"length":1,"stats":{"Line":1}},{"line":32,"address":[2235902,2236730,2236068,2236896,2235818,2236980,2236814,2235984],"length":1,"stats":{"Line":3}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[2236717,2235867,2235805,2236779],"length":1,"stats":{"Line":1}},{"line":35,"address":[2236875,2236033,2236945,2235963,2237552,2237575,2237671,2237648],"length":1,"stats":{"Line":4}},{"line":37,"address":[2236510,2237277,2236365,2237422],"length":1,"stats":{"Line":2}},{"line":39,"address":[2237146,2236234],"length":1,"stats":{"Line":1}},{"line":41,"address":[2237198,2237952,2237766,2236414,2236286,2237326,2237974,2237744],"length":1,"stats":{"Line":4}},{"line":43,"address":[2236563,2237475],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":10},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","task","link_task.rs"],"content":"use crate::domain::{\n    project_management::repository::ProjectRepository, shared::errors::DomainError, task_management::any_task::AnyTask,\n};\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum LinkTaskError {\n    #[error(\"Project with code '{0}' not found.\")]\n    ProjectNotFound(String),\n    #[error(\"Task with code '{0}' not found in the project.\")]\n    TaskNotFound(String),\n    #[error(\"Dependency task with code '{0}' not found in the project.\")]\n    DependencyNotFound(String),\n    #[error(\"A task cannot depend on itself.\")]\n    SelfDependencyError,\n    #[error(\"Circular dependency detected: adding this link would create a loop.\")]\n    CircularDependencyError,\n    #[error(\"An unexpected domain rule was violated: {0}\")]\n    DomainError(String),\n    #[error(\"A repository error occurred: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\nimpl From\u003cString\u003e for LinkTaskError {\n    fn from(err: String) -\u003e Self {\n        LinkTaskError::DomainError(err)\n    }\n}\n\n/// `LinkTaskUseCase` is responsible for creating a dependency between two tasks.\npub struct LinkTaskUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    project_repository: PR,\n}\n\nimpl\u003cPR\u003e LinkTaskUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    pub fn new(project_repository: PR) -\u003e Self {\n        Self { project_repository }\n    }\n\n    pub fn execute(\n        \u0026self,\n        project_code: \u0026str,\n        task_code: \u0026str,\n        dependency_code: \u0026str,\n    ) -\u003e Result\u003cAnyTask, LinkTaskError\u003e {\n        if task_code == dependency_code {\n            return Err(LinkTaskError::SelfDependencyError);\n        }\n\n        // 1. Load the project aggregate that contains the tasks.\n        let mut project = self\n            .project_repository\n            .find_by_code(project_code)?\n            .ok_or_else(|| LinkTaskError::ProjectNotFound(project_code.to_string()))?;\n\n        // 2. Ensure both tasks exist within the project.\n        if !project.tasks().contains_key(task_code) {\n            return Err(LinkTaskError::TaskNotFound(task_code.to_string()));\n        }\n        if !project.tasks().contains_key(dependency_code) {\n            return Err(LinkTaskError::DependencyNotFound(dependency_code.to_string()));\n        }\n\n        // 3. Check for circular dependencies.\n        // We perform a DFS traversal starting from the dependency to see if it eventually leads back to the original task.\n        let mut stack = vec![dependency_code.to_string()];\n        let mut visited = std::collections::HashSet::new();\n\n        while let Some(current_code) = stack.pop() {\n            if current_code == task_code {\n                return Err(LinkTaskError::CircularDependencyError);\n            }\n\n            // To avoid infinite loops on existing cycles, we only process each node once.\n            if !visited.insert(current_code.clone()) {\n                continue;\n            }\n\n            if let Some(task) = project.tasks().get(\u0026current_code) {\n                let dependencies = match task {\n                    AnyTask::Planned(t) =\u003e \u0026t.dependencies,\n                    AnyTask::InProgress(t) =\u003e \u0026t.dependencies,\n                    AnyTask::Blocked(t) =\u003e \u0026t.dependencies,\n                    AnyTask::Completed(t) =\u003e \u0026t.dependencies,\n                    AnyTask::Cancelled(t) =\u003e \u0026t.dependencies,\n                };\n                for dep in dependencies {\n                    stack.push(dep.clone());\n                }\n            }\n        }\n\n        // 4. Add the dependency to the task.\n        let updated_task = project.add_dependency_to_task(task_code, dependency_code)?;\n\n        // 5. Save the entire project aggregate with the modified task.\n        self.project_repository.save(project)?;\n\n        Ok(updated_task)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        project_management::{any_project::AnyProject, builder::ProjectBuilder},\n        task_management::{any_task::AnyTask, state::Planned, task::Task},\n    };\n    use chrono::NaiveDate;\n    use std::{cell::RefCell, collections::HashMap};\n    use uuid7::uuid7;\n\n    // --- Mocks ---\n    struct MockProjectRepository {\n        projects: RefCell\u003cHashMap\u003cString, AnyProject\u003e\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            self.projects.borrow_mut().insert(project.code().to_string(), project);\n            Ok(())\n        }\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().get(code).cloned())\n        }\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_task(code: \u0026str) -\u003e AnyTask {\n        Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-1\".to_string(),\n            code: code.to_string(),\n            name: format!(\"Task {code}\"),\n            description: None,\n            state: Planned,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![],\n        }\n        .into()\n    }\n\n    fn setup_test_project(tasks: Vec\u003cAnyTask\u003e) -\u003e AnyProject {\n        let mut project: AnyProject = ProjectBuilder::new(\"Test Project\".to_string())\n            .code(\"PROJ-1\".to_string())\n            .build()\n            .into();\n        for task in tasks {\n            project.add_task(task);\n        }\n        project\n    }\n\n    // --- Tests ---\n    #[test]\n    fn test_link_task_success() {\n        let project = setup_test_project(vec![create_test_task(\"A\"), create_test_task(\"B\")]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n        let use_case = LinkTaskUseCase::new(project_repo);\n\n        let result = use_case.execute(\"PROJ-1\", \"B\", \"A\");\n\n        assert!(result.is_ok());\n        let updated_task = result.unwrap();\n\n        let deps = match updated_task {\n            AnyTask::Planned(t) =\u003e t.dependencies,\n            _ =\u003e panic!(\"Expected a planned task\"),\n        };\n        assert_eq!(deps, vec![\"A\".to_string()]);\n    }\n\n    #[test]\n    fn test_link_task_fails_if_task_not_found() {\n        let project = setup_test_project(vec![create_test_task(\"A\")]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n        let use_case = LinkTaskUseCase::new(project_repo);\n\n        let result = use_case.execute(\"PROJ-1\", \"B_NONEXISTENT\", \"A\");\n        assert!(matches!(result, Err(LinkTaskError::TaskNotFound(_))));\n    }\n\n    #[test]\n    fn test_link_task_fails_if_dependency_not_found() {\n        let project = setup_test_project(vec![create_test_task(\"A\")]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n        let use_case = LinkTaskUseCase::new(project_repo);\n\n        let result = use_case.execute(\"PROJ-1\", \"A\", \"B_NONEXISTENT\");\n        assert!(matches!(result, Err(LinkTaskError::DependencyNotFound(_))));\n    }\n\n    #[test]\n    fn test_link_task_fails_on_self_dependency() {\n        let project = setup_test_project(vec![create_test_task(\"A\")]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n        let use_case = LinkTaskUseCase::new(project_repo);\n\n        let result = use_case.execute(\"PROJ-1\", \"A\", \"A\");\n        assert!(matches!(result, Err(LinkTaskError::SelfDependencyError)));\n    }\n\n    #[test]\n    fn test_link_task_fails_on_circular_dependency() {\n        // B depends on A (B -\u003e A)\n        let task_a = create_test_task(\"A\");\n        let mut task_b = create_test_task(\"B\");\n        if let AnyTask::Planned(t) = \u0026mut task_b {\n            t.dependencies.push(\"A\".to_string());\n        }\n\n        let project = setup_test_project(vec![task_a, task_b]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n        let use_case = LinkTaskUseCase::new(project_repo);\n\n        // Try to create dependency A -\u003e B, which would create a cycle (A -\u003e B -\u003e A)\n        let result = use_case.execute(\"PROJ-1\", \"A\", \"B\");\n\n        assert!(matches!(result, Err(LinkTaskError::CircularDependencyError)));\n    }\n}\n","traces":[{"line":25,"address":[844992],"length":1,"stats":{"Line":0}},{"line":26,"address":[844995],"length":1,"stats":{"Line":0}},{"line":42,"address":[289760,289728],"length":1,"stats":{"Line":1}},{"line":46,"address":[295654,296408,293120,289792,292326,293080],"length":1,"stats":{"Line":2}},{"line":52,"address":[289926,293254],"length":1,"stats":{"Line":1}},{"line":53,"address":[293387,290059],"length":1,"stats":{"Line":1}},{"line":57,"address":[293325,290245,290332,293660,289997,293485,290157,293573],"length":1,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[289984,293447,290119,293312],"length":1,"stats":{"Line":2}},{"line":60,"address":[290294,293552,293622,290224,296448,296567,296544,296471],"length":1,"stats":{"Line":2}},{"line":63,"address":[290469,290533,293861,293797],"length":1,"stats":{"Line":5}},{"line":64,"address":[290576,290645,293973,293904],"length":1,"stats":{"Line":2}},{"line":66,"address":[293947,290619,294103,290775],"length":1,"stats":{"Line":3}},{"line":67,"address":[290818,294214,290886,294146],"length":1,"stats":{"Line":2}},{"line":72,"address":[296403,290863,291002,294191,293075,294330],"length":1,"stats":{"Line":4}},{"line":73,"address":[294617,291238,291289,294566],"length":1,"stats":{"Line":4}},{"line":75,"address":[294619,291359,294687,291291],"length":1,"stats":{"Line":4}},{"line":76,"address":[294772,294853,291525,291444],"length":1,"stats":{"Line":4}},{"line":77,"address":[294901,291573],"length":1,"stats":{"Line":1}},{"line":81,"address":[291531,295020,291692,294859],"length":1,"stats":{"Line":4}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[291763,295091],"length":1,"stats":{"Line":2}},{"line":86,"address":[295193,291865],"length":1,"stats":{"Line":2}},{"line":87,"address":[291952,295280],"length":1,"stats":{"Line":2}},{"line":88,"address":[295311,291983],"length":1,"stats":{"Line":0}},{"line":89,"address":[292014,295342],"length":1,"stats":{"Line":0}},{"line":90,"address":[295369,292041],"length":1,"stats":{"Line":0}},{"line":91,"address":[292072,295400],"length":1,"stats":{"Line":0}},{"line":93,"address":[295424,292096],"length":1,"stats":{"Line":2}},{"line":94,"address":[295567,292239],"length":1,"stats":{"Line":1}},{"line":100,"address":[293023,295660,292332,296351],"length":1,"stats":{"Line":1}},{"line":103,"address":[295915,292587,296035,292707],"length":1,"stats":{"Line":2}},{"line":105,"address":[292917,296245],"length":1,"stats":{"Line":1}}],"covered":25,"coverable":33},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","task","mod.rs"],"content":"pub mod assign_resource;\npub mod delete_task;\npub mod describe_task;\npub mod link_task;\npub mod remove_dependency;\npub mod update_task;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","task","remove_dependency.rs"],"content":"use crate::domain::{\n    project_management::repository::ProjectRepository, shared::errors::DomainError, task_management::any_task::AnyTask,\n};\n\n#[derive(Debug, thiserror::Error)]\npub enum RemoveDependencyError {\n    #[error(\"Project with code '{0}' not found\")]\n    ProjectNotFound(String),\n    #[error(\"Task with code '{0}' not found in the project\")]\n    TaskNotFound(String),\n    #[error(\"Dependency '{0}' not found in task '{1}'\")]\n    DependencyNotFound(String, String),\n    #[error(\"Cannot remove dependency: task '{0}' is currently blocked by '{1}'\")]\n    TaskBlockedByDependency(String, String),\n    #[error(\"Domain rule violation: {0}\")]\n    DomainError(String),\n    #[error(\"Repository error: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\nimpl From\u003cString\u003e for RemoveDependencyError {\n    fn from(err: String) -\u003e Self {\n        RemoveDependencyError::DomainError(err)\n    }\n}\n\n/// `RemoveTaskDependencyUseCase` is responsible for removing a dependency between two tasks.\npub struct RemoveTaskDependencyUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    project_repository: PR,\n}\n\nimpl\u003cPR\u003e RemoveTaskDependencyUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    pub fn new(project_repository: PR) -\u003e Self {\n        Self { project_repository }\n    }\n\n    pub fn execute(\n        \u0026self,\n        project_code: \u0026str,\n        task_code: \u0026str,\n        dependency_code: \u0026str,\n    ) -\u003e Result\u003cAnyTask, RemoveDependencyError\u003e {\n        // 1. Load the project aggregate\n        let mut project = self\n            .project_repository\n            .find_by_code(project_code)?\n            .ok_or_else(|| RemoveDependencyError::ProjectNotFound(project_code.to_string()))?;\n\n        // 2. Ensure both tasks exist within the project\n        if !project.tasks().contains_key(task_code) {\n            return Err(RemoveDependencyError::TaskNotFound(task_code.to_string()));\n        }\n        if !project.tasks().contains_key(dependency_code) {\n            return Err(RemoveDependencyError::DependencyNotFound(\n                dependency_code.to_string(),\n                task_code.to_string(),\n            ));\n        }\n\n        // 3. Check if the dependency actually exists\n        let task = project.tasks().get(task_code).unwrap();\n        let dependencies = match task {\n            AnyTask::Planned(t) =\u003e \u0026t.dependencies,\n            AnyTask::InProgress(t) =\u003e \u0026t.dependencies,\n            AnyTask::Blocked(t) =\u003e \u0026t.dependencies,\n            AnyTask::Completed(t) =\u003e \u0026t.dependencies,\n            AnyTask::Cancelled(t) =\u003e \u0026t.dependencies,\n        };\n\n        if !dependencies.contains(\u0026dependency_code.to_string()) {\n            return Err(RemoveDependencyError::DependencyNotFound(\n                dependency_code.to_string(),\n                task_code.to_string(),\n            ));\n        }\n\n        // 4. Validate that removing the dependency won't break critical constraints\n        if self.is_task_blocked_by_dependency(\u0026project, task_code, dependency_code)? {\n            return Err(RemoveDependencyError::TaskBlockedByDependency(\n                task_code.to_string(),\n                dependency_code.to_string(),\n            ));\n        }\n\n        // 5. Remove the dependency from the task\n        let updated_task = project.remove_dependency_from_task(task_code, dependency_code)?;\n\n        // 6. Save the updated project\n        self.project_repository.save(project.clone())?;\n\n        Ok(updated_task)\n    }\n\n    fn is_task_blocked_by_dependency(\n        \u0026self,\n        project: \u0026crate::domain::project_management::AnyProject,\n        task_code: \u0026str,\n        dependency_code: \u0026str,\n    ) -\u003e Result\u003cbool, RemoveDependencyError\u003e {\n        // This is a simplified check - in a real system, you might want more sophisticated validation\n        // For now, we'll just check if the task is currently blocked and the dependency is the only blocker\n\n        let task = project.tasks().get(task_code).unwrap();\n        let dependencies = match task {\n            AnyTask::Planned(t) =\u003e \u0026t.dependencies,\n            AnyTask::InProgress(t) =\u003e \u0026t.dependencies,\n            AnyTask::Blocked(t) =\u003e \u0026t.dependencies,\n            AnyTask::Completed(t) =\u003e \u0026t.dependencies,\n            AnyTask::Cancelled(t) =\u003e \u0026t.dependencies,\n        };\n\n        // If task has only one dependency and it's the one we're trying to remove,\n        // and the task is currently blocked, we should prevent removal\n        if dependencies.len() == 1 \u0026\u0026 dependencies.contains(\u0026dependency_code.to_string()) {\n            // Check if task is in blocked state\n            match task {\n                AnyTask::Blocked(_) =\u003e return Ok(true),\n                _ =\u003e return Ok(false),\n            }\n        }\n\n        Ok(false)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        project_management::{AnyProject, builder::ProjectBuilder},\n        task_management::{state::Planned, task::Task},\n    };\n    use chrono::NaiveDate;\n    use std::{cell::RefCell, collections::HashMap};\n    use uuid7::uuid7;\n\n    // --- Mocks ---\n    struct MockProjectRepository {\n        projects: RefCell\u003cHashMap\u003cString, AnyProject\u003e\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            self.projects.borrow_mut().insert(project.code().to_string(), project);\n            Ok(())\n        }\n\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().get(code).cloned())\n        }\n\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_task(code: \u0026str, dependencies: Vec\u003cString\u003e) -\u003e Task\u003cPlanned\u003e {\n        Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-1\".to_string(),\n            code: code.to_string(),\n            name: format!(\"Test Task {}\", code),\n            description: None,\n            state: Planned,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies,\n            assigned_resources: vec![],\n        }\n    }\n\n    fn setup_test_project(tasks: Vec\u003cAnyTask\u003e) -\u003e AnyProject {\n        let mut project: AnyProject = ProjectBuilder::new(\"Test Project\".to_string())\n            .code(\"PROJ-1\".to_string())\n            .build()\n            .into();\n        for task in tasks {\n            project.add_task(task);\n        }\n        project\n    }\n\n    // --- Tests ---\n    #[test]\n    fn test_remove_dependency_success() {\n        // Arrange\n        let task_a = create_test_task(\"TASK-A\", vec![\"TASK-B\".to_string()]);\n        let task_b = create_test_task(\"TASK-B\", vec![]);\n\n        let project = setup_test_project(vec![task_a.into(), task_b.into()]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project.clone())])),\n        };\n\n        let use_case = RemoveTaskDependencyUseCase::new(project_repo);\n\n        // Act\n        let result = use_case.execute(\"PROJ-1\", \"TASK-A\", \"TASK-B\");\n\n        // Assert\n        assert!(result.is_ok());\n        let updated_task = result.unwrap();\n        assert_eq!(updated_task.code(), \"TASK-A\");\n\n        // Verify dependency was removed by checking the returned task\n        let dependencies = match updated_task {\n            AnyTask::Planned(t) =\u003e t.dependencies.clone(),\n            _ =\u003e panic!(\"Expected Planned task\"),\n        };\n        assert!(!dependencies.contains(\u0026\"TASK-B\".to_string()));\n    }\n\n    #[test]\n    fn test_remove_dependency_project_not_found() {\n        // Arrange\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::new()),\n        };\n\n        let use_case = RemoveTaskDependencyUseCase::new(project_repo);\n\n        // Act\n        let result = use_case.execute(\"NONEXISTENT-PROJ\", \"TASK-A\", \"TASK-B\");\n\n        // Assert\n        assert!(matches!(result, Err(RemoveDependencyError::ProjectNotFound(_))));\n    }\n\n    #[test]\n    fn test_remove_dependency_task_not_found() {\n        // Arrange\n        let task_b = create_test_task(\"TASK-B\", vec![]);\n        let project = setup_test_project(vec![task_b.into()]);\n\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n\n        let use_case = RemoveTaskDependencyUseCase::new(project_repo);\n\n        // Act\n        let result = use_case.execute(\"PROJ-1\", \"NONEXISTENT-TASK\", \"TASK-B\");\n\n        // Assert\n        assert!(matches!(result, Err(RemoveDependencyError::TaskNotFound(_))));\n    }\n\n    #[test]\n    fn test_remove_dependency_not_found() {\n        // Arrange\n        let task_a = create_test_task(\"TASK-A\", vec![]);\n        let task_b = create_test_task(\"TASK-B\", vec![]);\n\n        let project = setup_test_project(vec![task_a.into(), task_b.into()]);\n        let project_repo = MockProjectRepository {\n            projects: RefCell::new(HashMap::from([(project.code().to_string(), project)])),\n        };\n\n        let use_case = RemoveTaskDependencyUseCase::new(project_repo);\n\n        // Act\n        let result = use_case.execute(\"PROJ-1\", \"TASK-A\", \"TASK-B\");\n\n        // Assert\n        assert!(matches!(result, Err(RemoveDependencyError::DependencyNotFound(_, _))));\n    }\n}\n","traces":[{"line":22,"address":[1439872],"length":1,"stats":{"Line":0}},{"line":23,"address":[1439875],"length":1,"stats":{"Line":0}},{"line":39,"address":[2022864],"length":1,"stats":{"Line":1}},{"line":43,"address":[2022896,2026060,2024102],"length":1,"stats":{"Line":2}},{"line":50,"address":[2023075,2023162,2023250,2023337],"length":1,"stats":{"Line":5}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[2023062,2023124],"length":1,"stats":{"Line":2}},{"line":53,"address":[2026080,2023229,2023299,2026103],"length":1,"stats":{"Line":6}},{"line":56,"address":[2023545,2023466],"length":1,"stats":{"Line":6}},{"line":57,"address":[2023638,2023588],"length":1,"stats":{"Line":2}},{"line":59,"address":[2023780,2023615],"length":1,"stats":{"Line":4}},{"line":60,"address":[2023946],"length":1,"stats":{"Line":0}},{"line":61,"address":[2023817],"length":1,"stats":{"Line":0}},{"line":62,"address":[2023875],"length":1,"stats":{"Line":0}},{"line":67,"address":[2023844,2024129],"length":1,"stats":{"Line":3}},{"line":68,"address":[2024178],"length":1,"stats":{"Line":2}},{"line":69,"address":[2024243],"length":1,"stats":{"Line":2}},{"line":70,"address":[2024274],"length":1,"stats":{"Line":0}},{"line":71,"address":[2024305],"length":1,"stats":{"Line":0}},{"line":72,"address":[2024332],"length":1,"stats":{"Line":0}},{"line":73,"address":[2024363],"length":1,"stats":{"Line":0}},{"line":76,"address":[2024387],"length":1,"stats":{"Line":2}},{"line":77,"address":[2024717],"length":1,"stats":{"Line":1}},{"line":78,"address":[2024611],"length":1,"stats":{"Line":1}},{"line":79,"address":[2024646],"length":1,"stats":{"Line":1}},{"line":84,"address":[2024913,2026055],"length":1,"stats":{"Line":1}},{"line":85,"address":[2025899],"length":1,"stats":{"Line":0}},{"line":86,"address":[2025220],"length":1,"stats":{"Line":0}},{"line":87,"address":[2025828],"length":1,"stats":{"Line":0}},{"line":92,"address":[2025197,2025258,2025807],"length":1,"stats":{"Line":2}},{"line":95,"address":[2025453,2025524],"length":1,"stats":{"Line":2}},{"line":97,"address":[2025708],"length":1,"stats":{"Line":1}},{"line":100,"address":[2026810,2026816,2026176],"length":1,"stats":{"Line":1}},{"line":109,"address":[2026282],"length":1,"stats":{"Line":1}},{"line":110,"address":[2026336],"length":1,"stats":{"Line":1}},{"line":111,"address":[2026401],"length":1,"stats":{"Line":1}},{"line":112,"address":[2026429],"length":1,"stats":{"Line":0}},{"line":113,"address":[2026457],"length":1,"stats":{"Line":0}},{"line":114,"address":[2026481],"length":1,"stats":{"Line":0}},{"line":115,"address":[2026509],"length":1,"stats":{"Line":0}},{"line":120,"address":[2026648,2026530],"length":1,"stats":{"Line":1}},{"line":122,"address":[2026728],"length":1,"stats":{"Line":1}},{"line":123,"address":[2026768],"length":1,"stats":{"Line":0}},{"line":124,"address":[2026786],"length":1,"stats":{"Line":1}},{"line":128,"address":[2026632],"length":1,"stats":{"Line":0}}],"covered":26,"coverable":45},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","task","update_task.rs"],"content":"use crate::domain::{\n    project_management::repository::ProjectRepository, shared::errors::DomainError, task_management::any_task::AnyTask,\n};\nuse chrono::NaiveDate;\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum UpdateTaskError {\n    #[error(\"Project with code '{0}' not found.\")]\n    ProjectNotFound(String),\n    #[error(\"Task with code '{0}' not found in project.\")]\n    TaskNotFound(String),\n    #[error(\"An unexpected domain rule was violated: {0}\")]\n    DomainError(String),\n    #[error(\"A repository error occurred: {0}\")]\n    RepositoryError(#[from] DomainError),\n}\n\n#[derive(Debug, Clone, Default)]\npub struct UpdateTaskArgs {\n    pub name: Option\u003cString\u003e,\n    pub description: Option\u003cString\u003e,\n    pub start_date: Option\u003cNaiveDate\u003e,\n    pub due_date: Option\u003cNaiveDate\u003e,\n}\n\npub struct UpdateTaskUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    project_repository: PR,\n}\n\nimpl\u003cPR\u003e UpdateTaskUseCase\u003cPR\u003e\nwhere\n    PR: ProjectRepository,\n{\n    pub fn new(project_repository: PR) -\u003e Self {\n        Self { project_repository }\n    }\n\n    pub fn execute(\n        \u0026self,\n        project_code: \u0026str,\n        task_code: \u0026str,\n        args: UpdateTaskArgs,\n    ) -\u003e Result\u003cAnyTask, UpdateTaskError\u003e {\n        // 1. Load the project aggregate.\n        let mut project = self\n            .project_repository\n            .find_by_code(project_code)?\n            .ok_or_else(|| UpdateTaskError::ProjectNotFound(project_code.to_string()))?;\n\n        // Check if a reschedule is needed before args is moved.\n        let needs_reschedule = args.due_date.is_some();\n\n        // 2. Delegate the update to the project aggregate.\n        // This method ensures all domain invariants are respected.\n        project\n            .update_task(task_code, args.name, args.description, args.start_date, args.due_date)\n            .map_err(UpdateTaskError::DomainError)?;\n\n        // 3. If the due date was changed, reschedule all dependent tasks.\n        if needs_reschedule {\n            project\n                .reschedule_dependents_of(task_code)\n                .map_err(UpdateTaskError::DomainError)?;\n        }\n\n        // 4. Save the updated project aggregate.\n        self.project_repository.save(project.clone())?;\n\n        // 5. Return the updated task to the caller.\n        let updated_task = project\n            .tasks()\n            .get(task_code)\n            .cloned()\n            // This should ideally not happen if update_task succeeded, but we check for safety.\n            .ok_or_else(|| UpdateTaskError::TaskNotFound(task_code.to_string()))?;\n\n        Ok(updated_task)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        project_management::{AnyProject, builder::ProjectBuilder},\n        task_management::{state::Planned, task::Task},\n    };\n    use std::{cell::RefCell, collections::HashMap, rc::Rc};\n    use uuid7::uuid7;\n\n    // --- Mocks ---\n    #[derive(Clone)]\n    struct MockProjectRepository {\n        projects: Rc\u003cRefCell\u003cHashMap\u003cString, AnyProject\u003e\u003e\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            self.projects.borrow_mut().insert(project.code().to_string(), project);\n            Ok(())\n        }\n        fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n            Ok(self.projects.borrow().get(code).cloned())\n        }\n        fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n            unimplemented!()\n        }\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n            unimplemented!()\n        }\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            unimplemented!()\n        }\n    }\n\n    // --- Helpers ---\n    fn create_test_task(code: \u0026str, name: \u0026str) -\u003e AnyTask {\n        Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-1\".to_string(),\n            code: code.to_string(),\n            name: name.to_string(),\n            description: Some(\"Initial Description\".to_string()),\n            state: Planned,\n            start_date: NaiveDate::from_ymd_opt(2025, 1, 1).unwrap(),\n            due_date: NaiveDate::from_ymd_opt(2025, 1, 10).unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![],\n        }\n        .into()\n    }\n\n    fn setup_test_project(tasks: Vec\u003cAnyTask\u003e) -\u003e AnyProject {\n        let mut project: AnyProject = ProjectBuilder::new(\"Test Project\".to_string())\n            .code(\"PROJ-1\".to_string())\n            .build()\n            .into();\n        for task in tasks {\n            project.add_task(task);\n        }\n        project\n    }\n\n    // --- Tests ---\n\n    // TODO: Enable this test once `AnyProject::update_task` is implemented.\n    #[test]\n    fn test_update_task_name_success() {\n        let project = setup_test_project(vec![create_test_task(\"TSK-1\", \"Old Name\")]);\n        let project_repo = MockProjectRepository {\n            projects: Rc::new(RefCell::new(HashMap::from([(project.code().to_string(), project)]))),\n        };\n        let use_case = UpdateTaskUseCase::new(project_repo);\n\n        let args = UpdateTaskArgs {\n            name: Some(\"New Name\".to_string()),\n            ..Default::default()\n        };\n\n        let result = use_case.execute(\"PROJ-1\", \"TSK-1\", args);\n\n        assert!(result.is_ok());\n        let updated_task = result.unwrap();\n        assert_eq!(updated_task.name(), \"New Name\");\n        assert_eq!(updated_task.description().unwrap(), \"Initial Description\");\n    }\n\n    #[test]\n    fn test_update_task_fails_if_project_not_found() {\n        let project_repo = MockProjectRepository {\n            projects: Rc::new(RefCell::new(HashMap::new())),\n        };\n        let use_case = UpdateTaskUseCase::new(project_repo);\n\n        let args = UpdateTaskArgs {\n            name: Some(\"New Name\".to_string()),\n            ..Default::default()\n        };\n\n        let result = use_case.execute(\"PROJ-NONEXISTENT\", \"TSK-1\", args);\n        assert!(matches!(result, Err(UpdateTaskError::ProjectNotFound(_))));\n    }\n\n    fn create_task_with_deps(code: \u0026str, start_date: NaiveDate, due_date: NaiveDate, deps: Vec\u003c\u0026str\u003e) -\u003e AnyTask {\n        Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-1\".to_string(),\n            code: code.to_string(),\n            name: format!(\"Task {code}\"),\n            description: None,\n            state: Planned,\n            start_date,\n            due_date,\n            actual_end_date: None,\n            dependencies: deps.into_iter().map(String::from).collect(),\n            assigned_resources: vec![],\n        }\n        .into()\n    }\n\n    #[test]\n    fn test_update_task_reschedules_dependents() {\n        let d = |day| NaiveDate::from_ymd_opt(2025, 1, day).unwrap();\n\n        // A depends on nothing\n        let task_a = create_task_with_deps(\"A\", d(1), d(5), vec![]);\n        // B depends on A\n        let task_b = create_task_with_deps(\"B\", d(6), d(10), vec![\"A\"]);\n        // C depends on B\n        let task_c = create_task_with_deps(\"C\", d(11), d(15), vec![\"B\"]);\n\n        let project = setup_test_project(vec![task_a, task_b, task_c]);\n        let project_repo = MockProjectRepository {\n            projects: Rc::new(RefCell::new(HashMap::from([(project.code().to_string(), project)]))),\n        };\n        let use_case = UpdateTaskUseCase::new(project_repo.clone());\n\n        // We delay task A by 3 days (it now ends on day 8 instead of 5)\n        let args = UpdateTaskArgs {\n            due_date: Some(d(8)),\n            ..Default::default()\n        };\n\n        let result = use_case.execute(\"PROJ-1\", \"A\", args);\n        assert!(result.is_ok());\n\n        // Verification\n        let final_project = project_repo.find_by_code(\"PROJ-1\").unwrap().unwrap();\n        let final_tasks = final_project.tasks();\n\n        let final_a = final_tasks.get(\"A\").unwrap();\n        assert_eq!(*final_a.due_date(), d(8)); // Original task is updated\n\n        let final_b = final_tasks.get(\"B\").unwrap();\n        assert_eq!(*final_b.start_date(), d(9)); // B now starts the day after A ends\n        assert_eq!(*final_b.due_date(), d(13)); // B keeps its 4-day duration\n\n        let final_c = final_tasks.get(\"C\").unwrap();\n        assert_eq!(*final_c.start_date(), d(14)); // C now starts the day after B ends\n        assert_eq!(*final_c.due_date(), d(18)); // C keeps its 4-day duration\n    }\n}\n","traces":[{"line":38,"address":[1181072,1181056],"length":1,"stats":{"Line":1}},{"line":42,"address":[1183344,1185489,1183249,1183151,1181104,1185391],"length":1,"stats":{"Line":2}},{"line":49,"address":[1181330,1183819,1181579,1181473,1185397,1183466,1181226,1183570,1183713,1183962,1181722,1183157],"length":1,"stats":{"Line":9}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[1181266,1181377,1183617,1183506],"length":1,"stats":{"Line":3}},{"line":52,"address":[1183796,1183866,1185584,1185703,1181626,1181556,1185680,1185607],"length":1,"stats":{"Line":6}},{"line":55,"address":[1184065,1184143,1181903,1181825],"length":1,"stats":{"Line":4}},{"line":59,"address":[1184310,1184453,1185377,1182213,1182070,1183137],"length":1,"stats":{"Line":2}},{"line":60,"address":[1184155,1181915],"length":1,"stats":{"Line":2}},{"line":61,"address":[1184287,1182047,1184357,1182117],"length":1,"stats":{"Line":2}},{"line":64,"address":[1184482,1182242],"length":1,"stats":{"Line":2}},{"line":65,"address":[1184729,1182346,1184586,1183135,1185375,1182489],"length":1,"stats":{"Line":1}},{"line":66,"address":[1184540,1182300],"length":1,"stats":{"Line":1}},{"line":67,"address":[1182393,1184563,1184633,1182323],"length":1,"stats":{"Line":1}},{"line":71,"address":[1184778,1185373,1182264,1183133,1184504,1182538],"length":1,"stats":{"Line":2}},{"line":74,"address":[1182993,1182845,1185356,1185085,1183116,1185233],"length":1,"stats":{"Line":1}},{"line":76,"address":[1185004,1182764],"length":1,"stats":{"Line":1}},{"line":79,"address":[1182897,1185776,1185895,1185137,1185062,1185872,1182822,1185799],"length":1,"stats":{"Line":1}},{"line":81,"address":[1185323,1183083],"length":1,"stats":{"Line":1}}],"covered":18,"coverable":19},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","validate","mod.rs"],"content":"pub mod vacations;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","validate","vacations.rs"],"content":"use crate::domain::{\n    project_management::{repository::ProjectRepository, vacation_rules::VacationRules, layoff_period::LayoffPeriod},\n    resource_management::repository::ResourceRepository,\n    resource_management::resource::Period,\n    shared::errors::DomainError,\n};\nuse chrono::{DateTime, FixedOffset, Local, NaiveDate, Offset, TimeZone};\n\npub struct ValidateVacationsUseCase\u003cP: ProjectRepository, R: ResourceRepository\u003e {\n    project_repository: P,\n    resource_repository: R,\n}\n\nimpl\u003cP: ProjectRepository, R: ResourceRepository\u003e ValidateVacationsUseCase\u003cP, R\u003e {\n    pub fn new(project_repository: P, resource_repository: R) -\u003e Self {\n        Self {\n            project_repository,\n            resource_repository,\n        }\n    }\n\n    fn check_vacation_overlap(\u0026self, period1: \u0026Period, period2: \u0026Period) -\u003e bool {\n        period1.start_date \u003c= period2.end_date \u0026\u0026 period2.start_date \u003c= period1.end_date\n    }\n\n    fn check_layoff_overlap(\u0026self, vacation_period: \u0026Period, layoff_period: \u0026(String, String)) -\u003e bool {\n        let layoff_start = NaiveDate::parse_from_str(\u0026layoff_period.0, \"%Y-%m-%d\")\n            .unwrap()\n            .and_hms_opt(0, 0, 0)\n            .unwrap();\n        let layoff_end = NaiveDate::parse_from_str(\u0026layoff_period.1, \"%Y-%m-%d\")\n            .unwrap()\n            .and_hms_opt(0, 0, 0)\n            .unwrap();\n\n        let offset = Local::now().offset().fix();\n        let layoff_start: DateTime\u003cFixedOffset\u003e = DateTime::from_naive_utc_and_offset(layoff_start, offset);\n        let layoff_end: DateTime\u003cFixedOffset\u003e = DateTime::from_naive_utc_and_offset(layoff_end, offset);\n\n        vacation_period.start_date \u003c= layoff_end \u0026\u0026 layoff_start \u003c= vacation_period.end_date\n    }\n\n    fn has_valid_layoff_vacation(\u0026self, vacations: \u0026[Period], vacation_rules: \u0026VacationRules) -\u003e bool {\n        if let Some(layoff_periods) = \u0026vacation_rules.layoff_periods\n            \u0026\u0026 let Some(require_layoff) = vacation_rules.require_layoff_vacation_period\n            \u0026\u0026 require_layoff\n        {\n            // Verifica se pelo menos uma férias coincide com algum período de layoff\n            for vacation in vacations {\n                for layoff_period in layoff_periods {\n                    if self.check_layoff_overlap(\n                        vacation,\n                        \u0026(layoff_period.start_date.clone(), layoff_period.end_date.clone()),\n                    ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        true\n    }\n\n    pub fn execute(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, DomainError\u003e {\n        let resources = self.resource_repository.find_all()?;\n        let project = self.project_repository.load()?;\n        let mut mensagens = Vec::new();\n\n        // Verificar sobreposição entre todos os recursos\n        for (i, resource1) in resources.iter().enumerate() {\n            if let Some(vacations1) = resource1.vacations() {\n                // Verificar sobreposição com outros recursos\n                for resource2 in resources.iter().skip(i + 1) {\n                    if let Some(vacations2) = resource2.vacations() {\n                        for period1 in vacations1 {\n                            for period2 in vacations2 {\n                                if self.check_vacation_overlap(period1, period2) {\n                                    mensagens.push(format!(\n                                        \"⚠️ Sobreposição detectada: {} e {} têm férias sobrepostas entre {} e {}\",\n                                        resource1.name(),\n                                        resource2.name(),\n                                        period1.start_date.format(\"%d/%m/%Y\"),\n                                        period1.end_date.format(\"%d/%m/%Y\")\n                                    ));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Verificar se há férias durante o período de layoff quando necessário\n                if let Some(vacation_rules) = project.vacation_rules()\n                    \u0026\u0026 !self.has_valid_layoff_vacation(vacations1, vacation_rules)\n                {\n                    mensagens.push(format!(\n                        \"⚠️ {} não possui férias durante nenhum período de layoff\",\n                        resource1.name()\n                    ));\n                }\n            }\n        }\n\n        if mensagens.is_empty() {\n            mensagens.push(\"✅ Não foram encontradas sobreposições de férias\".to_string());\n        }\n\n        Ok(mensagens)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        project_management::{builder::ProjectBuilder, vacation_rules::VacationRules},\n        resource_management::{\n            AnyResource,\n            resource::{PeriodType, Resource},\n            state::Available,\n        },\n    };\n    use chrono::{Duration, Local};\n\n    struct MockProjectRepository {\n        vacation_rules: Option\u003cVacationRules\u003e,\n    }\n\n    struct MockResourceRepository {\n        resources: Vec\u003cAnyResource\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, _project: crate::domain::project_management::AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            Ok(())\n        }\n\n        fn load(\u0026self) -\u003e Result\u003ccrate::domain::project_management::AnyProject, DomainError\u003e {\n            let mut builder = ProjectBuilder::new(\"Test Project\".to_string()).code(\"proj-1\".to_string());\n\n            if let Some(rules) = self.vacation_rules.clone() {\n                builder = builder.vacation_rules(rules);\n            }\n\n            Ok(builder.build().start().into())\n        }\n\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(\"proj-1\".to_string())\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003ccrate::domain::project_management::AnyProject\u003e, DomainError\u003e {\n            let mut builder = ProjectBuilder::new(\"Test Project\".to_string()).code(\"proj-1\".to_string());\n            if let Some(rules) = self.vacation_rules.clone() {\n                builder = builder.vacation_rules(rules);\n            }\n            Ok(vec![builder.build().start().into()])\n        }\n\n        fn find_by_code(\n            \u0026self,\n            code: \u0026str,\n        ) -\u003e Result\u003cOption\u003ccrate::domain::project_management::AnyProject\u003e, DomainError\u003e {\n            if code == \"proj-1\" {\n                let mut builder = ProjectBuilder::new(\"Test Project\".to_string()).code(\"proj-1\".to_string());\n                if let Some(rules) = self.vacation_rules.clone() {\n                    builder = builder.vacation_rules(rules);\n                }\n                Ok(Some(builder.build().start().into()))\n            } else {\n                Ok(None)\n            }\n        }\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn save(\u0026self, resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            Ok(resource)\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.clone())\n        }\n        fn find_by_code(\u0026self, _code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(None)\n        }\n\n        fn save_time_off(\n            \u0026self,\n            _resource_name: \u0026str,\n            _hours: u32,\n            _date: \u0026str,\n            _description: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!(\"Not needed for these tests\")\n        }\n\n        fn save_vacation(\n            \u0026self,\n            _resource_name: \u0026str,\n            _start_date: \u0026str,\n            _end_date: \u0026str,\n            _is_time_off_compensation: bool,\n            _compensated_hours: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!(\"Not needed for these tests\")\n        }\n\n        fn check_if_layoff_period(\u0026self, _start_date: \u0026DateTime\u003cLocal\u003e, _end_date: \u0026DateTime\u003cLocal\u003e) -\u003e bool {\n            false\n        }\n\n        fn get_next_code(\u0026self, resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(format!(\"{}-1\", resource_type.to_lowercase()))\n        }\n    }\n\n    #[test]\n    fn test_detect_vacation_overlap() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_no_vacation_overlap() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(5),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(10),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(\n            result\n                .iter()\n                .any(|msg| msg.contains(\"Não foram encontradas sobreposições\"))\n        );\n    }\n\n    #[test]\n    fn test_vacation_overlap_edge_case() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(11),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Não deve haver sobreposição quando há um dia de intervalo\n        assert!(\n            result\n                .iter()\n                .any(|msg| msg.contains(\"Não foram encontradas sobreposições\"))\n        );\n    }\n\n    #[test]\n    fn test_vacation_overlap_contained() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(20),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_vacation_overlap_multiple_periods() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![\n                Period {\n                    start_date: now,\n                    end_date: now + Duration::days(5),\n                    approved: true,\n                    period_type: PeriodType::Vacation,\n                    is_time_off_compensation: false,\n                    compensated_hours: None,\n                    is_layoff: false,\n                },\n                Period {\n                    start_date: now + Duration::days(20),\n                    end_date: now + Duration::days(25),\n                    approved: true,\n                    period_type: PeriodType::Vacation,\n                    is_time_off_compensation: false,\n                    compensated_hours: None,\n                    is_layoff: false,\n                },\n            ]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(3),\n                end_date: now + Duration::days(8),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_vacation_overlap_three_resources() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource3 = Resource::\u003cAvailable\u003e::new(\n            \"dev-3\".to_string(),\n            \"Pedro\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(12),\n                end_date: now + Duration::days(18),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into(), resource3.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição entre resource2 e resource3\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n        assert!(result.iter().any(|msg| msg.contains(\"Maria\") \u0026\u0026 msg.contains(\"Pedro\")));\n    }\n\n    #[test]\n    fn test_vacation_overlap_no_vacations() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            None,\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            None,\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(\n            result\n                .iter()\n                .any(|msg| msg.contains(\"Não foram encontradas sobreposições\"))\n        );\n    }\n\n    #[test]\n    fn test_vacation_overlap_single_resource() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(\n            result\n                .iter()\n                .any(|msg| msg.contains(\"Não foram encontradas sobreposições\"))\n        );\n    }\n\n    #[test]\n    fn test_vacation_overlap_empty_resources() {\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository { resources: vec![] };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(\n            result\n                .iter()\n                .any(|msg| msg.contains(\"Não foram encontradas sobreposições\"))\n        );\n    }\n\n    #[test]\n    fn test_vacation_overlap_mixed_vacation_types() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::TimeOff,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição independente do tipo de período\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_vacation_overlap_approved_and_unapproved() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: false,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição independente do status de aprovação\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_success() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-25\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n                LayoffPeriod {\n                    start_date: \"2024-02-01\".to_string(),\n                    end_date: \"2024-02-28\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar que há férias durante período de layoff (sucesso)\n        assert!(result.iter().any(|msg| msg.contains(\"Não foram encontradas sobreposições\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_failure() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(50),\n                end_date: now + Duration::days(60),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n                LayoffPeriod {\n                    start_date: \"2024-02-01\".to_string(),\n                    end_date: \"2024-02-28\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar que não há férias durante período de layoff\n        assert!(result.iter().any(|msg| msg.contains(\"não possui férias durante nenhum período de layoff\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_not_required() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(50),\n                end_date: now + Duration::days(60),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(false),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n                LayoffPeriod {\n                    start_date: \"2024-02-01\".to_string(),\n                    end_date: \"2024-02-28\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Não deve verificar layoff quando não é obrigatório\n        assert!(result.iter().any(|msg| msg.contains(\"Não foram encontradas sobreposições\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_no_layoff_periods() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: None,\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve funcionar mesmo sem períodos de layoff definidos\n        assert!(result.iter().any(|msg| msg.contains(\"Não foram encontradas sobreposições\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_edge_case_overlap() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-25\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-20\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-30\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição entre recursos\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_partial_overlap() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-10\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-20\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-25\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-15\".to_string(),\n                    end_date: \"2024-01-30\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição entre recursos\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_multiple_layoff_periods() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-25\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-20\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-30\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n                LayoffPeriod {\n                    start_date: \"2024-03-01\".to_string(),\n                    end_date: \"2024-03-31\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição entre recursos\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_no_vacations() {\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n            ]),\n        };\n\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local::now() + Duration::days(60),\n                end_date: Local::now() + Duration::days(75),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: Some(0),\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar que não há férias durante período de layoff\n        assert!(result.iter().any(|msg| msg.contains(\"não possui férias durante nenhum período de layoff\")));\n    }\n\n    #[test]\n    fn test_no_vacation_overlap_success_message() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            None,\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            None,\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: None \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve retornar mensagem de sucesso quando não há sobreposições\n        assert!(result.iter().any(|msg| msg.contains(\"✅ Não foram encontradas sobreposições de férias\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_with_vacations_but_no_layoff_overlap() {\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n            ]),\n        };\n\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local::now() + Duration::days(60),\n                end_date: Local::now() + Duration::days(75),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: Some(0),\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar que não há férias durante período de layoff\n        assert!(result.iter().any(|msg| msg.contains(\"não possui férias durante nenhum período de layoff\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_early_return_true() {\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n            ]),\n        };\n\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-20\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: Some(0),\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Não deve ter mensagem de layoff warning já que férias sobrepõem período de layoff\n        assert!(!result.iter().any(|msg| msg.contains(\"não possui férias durante nenhum período de layoff\")));\n        // Deve retornar mensagem de sucesso\n        assert!(result.iter().any(|msg| msg.contains(\"✅ Não foram encontradas sobreposições de férias\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_exact_overlap() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-01\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-31\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve retornar mensagem de sucesso (não há sobreposições entre recursos)\n        assert!(result.iter().any(|msg| msg.contains(\"✅ Não foram encontradas sobreposições de férias\")));\n    }\n\n    #[test]\n    fn test_no_overlaps_no_layoff_rules() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-02-01\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-02-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-01\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        // Sem regras de layoff\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: None \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve retornar mensagem de sucesso (não há sobreposições nem regras de layoff)\n        assert!(result.iter().any(|msg| msg.contains(\"✅ Não foram encontradas sobreposições de férias\")));\n    }\n}\n","traces":[{"line":15,"address":[2223968,2224032],"length":1,"stats":{"Line":1}},{"line":22,"address":[2224112,2224240],"length":1,"stats":{"Line":2}},{"line":23,"address":[2224295,2224167],"length":1,"stats":{"Line":1}},{"line":26,"address":[2224368,2224912],"length":1,"stats":{"Line":3}},{"line":27,"address":[2224420,2224964],"length":1,"stats":{"Line":4}},{"line":31,"address":[2224559,2225103],"length":1,"stats":{"Line":3}},{"line":36,"address":[2224697,2225241],"length":1,"stats":{"Line":4}},{"line":37,"address":[2224741,2225285],"length":1,"stats":{"Line":3}},{"line":38,"address":[2224791,2225335],"length":1,"stats":{"Line":4}},{"line":40,"address":[2224842,2225386],"length":1,"stats":{"Line":3}},{"line":43,"address":[2226144,2226805,2226811,2225456,2226117,2226123],"length":1,"stats":{"Line":2}},{"line":44,"address":[2225528,2226216],"length":1,"stats":{"Line":2}},{"line":45,"address":[2226261,2226299,2225611,2225573],"length":1,"stats":{"Line":3}},{"line":46,"address":[2225626,2226314],"length":1,"stats":{"Line":1}},{"line":49,"address":[2226330,2225657,2225642,2226345],"length":1,"stats":{"Line":3}},{"line":50,"address":[2226411,2225723,2226447,2225759],"length":1,"stats":{"Line":5}},{"line":51,"address":[2226700,2226756,2226012,2226068],"length":1,"stats":{"Line":8}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[2225824,2226512],"length":1,"stats":{"Line":3}},{"line":55,"address":[2226107,2226795],"length":1,"stats":{"Line":2}},{"line":59,"address":[2225740,2226428],"length":1,"stats":{"Line":1}},{"line":61,"address":[2225596,2226284],"length":1,"stats":{"Line":1}},{"line":64,"address":[2229958,2226832,2229982,2230000,2233150,2233126],"length":1,"stats":{"Line":1}},{"line":65,"address":[2226871,2230039],"length":1,"stats":{"Line":2}},{"line":66,"address":[2230244,2227064,2227139,2230307],"length":1,"stats":{"Line":3}},{"line":67,"address":[2230563,2227395],"length":1,"stats":{"Line":1}},{"line":70,"address":[2227542,2227462,2230710,2230630],"length":1,"stats":{"Line":2}},{"line":71,"address":[2227809,2230977,2228075,2231243],"length":1,"stats":{"Line":4}},{"line":73,"address":[2228182,2231350],"length":1,"stats":{"Line":2}},{"line":74,"address":[2232065,2228897,2231661,2228493],"length":1,"stats":{"Line":3}},{"line":75,"address":[2229006,2232174],"length":1,"stats":{"Line":1}},{"line":76,"address":[2229148,2232316],"length":1,"stats":{"Line":2}},{"line":77,"address":[2229288,2232456],"length":1,"stats":{"Line":1}},{"line":78,"address":[2229481,2229533,2232649,2232701],"length":1,"stats":{"Line":2}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[2229317,2232485],"length":1,"stats":{"Line":2}},{"line":81,"address":[2229368,2232536],"length":1,"stats":{"Line":1}},{"line":82,"address":[2232582,2229414],"length":1,"stats":{"Line":2}},{"line":83,"address":[2229450,2232618],"length":1,"stats":{"Line":1}},{"line":92,"address":[2231695,2228527],"length":1,"stats":{"Line":2}},{"line":93,"address":[2231801,2228633],"length":1,"stats":{"Line":2}},{"line":95,"address":[2228715,2231883],"length":1,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[2228672,2231840],"length":1,"stats":{"Line":2}},{"line":103,"address":[2227835,2231003],"length":1,"stats":{"Line":1}},{"line":104,"address":[2227960,2231128],"length":1,"stats":{"Line":1}},{"line":107,"address":[2231050,2227882],"length":1,"stats":{"Line":2}}],"covered":44,"coverable":47},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","company_settings","business_rules.rs"],"content":"use crate::domain::shared::errors::DomainError;\nuse crate::domain::company_settings::errors::CompanySettingsError;\nuse crate::domain::company_settings::validations::CompanySettingsValidator;\nuse crate::domain::company_settings::config::Config;\n\n/// Regras de negócio para configurações da empresa\npub struct CompanySettingsBusinessRules;\n\nimpl CompanySettingsBusinessRules {\n    /// Aplica todas as regras de negócio para criar uma nova configuração\n    pub fn apply_creation_rules(\n        manager_name: \u0026str,\n        manager_email: \u0026str,\n        default_timezone: \u0026str,\n    ) -\u003e Result\u003cConfig, CompanySettingsError\u003e {\n        // 1. Aplicar regras de negócio específicas primeiro\n        Self::apply_name_business_rules(manager_name)?;\n        Self::apply_email_business_rules(manager_email)?;\n        Self::apply_timezone_business_rules(default_timezone)?;\n\n        // 2. Validar dados de entrada\n        CompanySettingsValidator::validate_all_config(\n            manager_name,\n            manager_email,\n            default_timezone,\n        )?;\n\n        // 3. Criar e retornar a configuração\n        Ok(Config::new(\n            manager_name.to_string(),\n            manager_email.to_string(),\n            default_timezone.to_string(),\n        ))\n    }\n\n    /// Aplica regras de negócio específicas para o nome\n    fn apply_name_business_rules(name: \u0026str) -\u003e Result\u003c(), CompanySettingsError\u003e {\n        // Regra: Nome não pode conter apenas espaços\n        if name.trim().is_empty() {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_name\".to_string(),\n                value: name.to_string(),\n                reason: \"Nome do gerente não pode conter apenas espaços\".to_string(),\n            });\n        }\n\n        // Regra: Nome deve ter pelo menos uma palavra com 2+ caracteres\n        let words: Vec\u003c\u0026str\u003e = name.split_whitespace().collect();\n        let has_valid_word = words.iter().any(|word| word.len() \u003e= 2);\n        \n        if !has_valid_word {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_name\".to_string(),\n                value: name.to_string(),\n                reason: \"Nome do gerente deve ter pelo menos uma palavra com 2+ caracteres\".to_string(),\n            });\n        }\n\n        // Regra: Nome não pode começar ou terminar com hífen ou apóstrofo\n        if name.starts_with('-') || name.starts_with('\\'') || \n           name.ends_with('-') || name.ends_with('\\'') {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_name\".to_string(),\n                value: name.to_string(),\n                reason: \"Nome do gerente não pode começar ou terminar com hífen ou apóstrofo\".to_string(),\n            });\n        }\n\n        Ok(())\n    }\n\n    /// Aplica regras de negócio específicas para o email\n    fn apply_email_business_rules(email: \u0026str) -\u003e Result\u003c(), CompanySettingsError\u003e {\n        // Regra: Email deve ser único (simulado - em produção seria verificado no banco)\n        if email == \"admin@system.local\" {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_email\".to_string(),\n                value: email.to_string(),\n                reason: \"Email 'admin@system.local' é reservado para o sistema\".to_string(),\n            });\n        }\n\n        // Regra: Email não pode ser muito genérico\n        let generic_emails = [\"test@example.com\", \"admin@company.com\", \"user@domain.com\"];\n        if generic_emails.contains(\u0026email) {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_email\".to_string(),\n                value: email.to_string(),\n                reason: \"Email muito genérico, use um email específico da empresa\".to_string(),\n            });\n        }\n\n        // Regra: Email deve ter domínio válido (não pode ser localhost, etc.)\n        let invalid_domains = [\"localhost\", \"127.0.0.1\", \"::1\", \"0.0.0.0\"];\n        if let Some(domain) = email.split('@').nth(1) {\n            if invalid_domains.contains(\u0026domain) {\n                return Err(CompanySettingsError::ConfigurationInvalid {\n                    field: \"manager_email\".to_string(),\n                    value: email.to_string(),\n                    reason: \"Domínio de email inválido\".to_string(),\n                });\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Aplica regras de negócio específicas para o fuso horário\n    fn apply_timezone_business_rules(timezone: \u0026str) -\u003e Result\u003c(), CompanySettingsError\u003e {\n        // Regra: Fuso horário deve ser apropriado para o contexto da empresa\n        let recommended_timezones = [\n            \"America/Sao_Paulo\", \"America/New_York\", \"Europe/London\", \"UTC\"\n        ];\n\n        if !recommended_timezones.contains(\u0026timezone) {\n            // Apenas um warning, não um erro\n            // Em produção, isso poderia ser logado\n        }\n\n        // Regra: Não permitir fusos horários muito extremos para empresas\n        let extreme_timezones = [\"Asia/Tokyo\", \"Pacific/Auckland\"];\n        if extreme_timezones.contains(\u0026timezone) {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"default_timezone\".to_string(),\n                value: timezone.to_string(),\n                reason: \"Fuso horário muito extremo para o contexto da empresa\".to_string(),\n            });\n        }\n\n        Ok(())\n    }\n\n    /// Aplica regras de negócio para atualização de configurações\n    pub fn apply_update_rules(\n        current_config: \u0026Config,\n        new_manager_name: Option\u003c\u0026str\u003e,\n        new_manager_email: Option\u003c\u0026str\u003e,\n        new_default_timezone: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cConfig, CompanySettingsError\u003e {\n        let manager_name = new_manager_name.unwrap_or(\u0026current_config.manager_name);\n        let manager_email = new_manager_email.unwrap_or(\u0026current_config.manager_email);\n        let default_timezone = new_default_timezone.unwrap_or(\u0026current_config.default_timezone);\n\n        // Aplicar regras de criação\n        Self::apply_creation_rules(manager_name, manager_email, default_timezone)\n    }\n\n    /// Valida se uma configuração pode ser removida\n    pub fn can_remove_config(config: \u0026Config) -\u003e Result\u003cbool, CompanySettingsError\u003e {\n        // Regra: Configuração não pode ser removida se for a única configuração ativa\n        // Simulado - em produção seria verificado no banco\n        if config.manager_email == \"admin@system.local\" {\n            return Err(CompanySettingsError::OperationNotAllowed {\n                operation: \"remove\".to_string(),\n                reason: \"Configuração do sistema não pode ser removida\".to_string(),\n            });\n        }\n\n        Ok(true)\n    }\n\n    /// Aplica regras de negócio para migração de configurações\n    pub fn apply_migration_rules(\n        old_config: \u0026Config,\n        new_config: \u0026Config,\n    ) -\u003e Result\u003c(), CompanySettingsError\u003e {\n        // Regra: Migração só pode ser feita em horário de baixa atividade\n        // Simulado - em produção seria verificado o horário atual\n        let current_hour = 14; // Simulado\n        if current_hour \u003e= 9 \u0026\u0026 current_hour \u003c= 18 {\n            return Err(CompanySettingsError::OperationNotAllowed {\n                operation: \"migration\".to_string(),\n                reason: \"Migração só pode ser feita fora do horário comercial\".to_string(),\n            });\n        }\n\n        // Regra: Configuração deve manter compatibilidade\n        if old_config.default_timezone != new_config.default_timezone {\n            // Verificar se a mudança é compatível\n            if !Self::is_timezone_change_compatible(\n                \u0026old_config.default_timezone,\n                \u0026new_config.default_timezone,\n            ) {\n                return Err(CompanySettingsError::ConfigurationInvalid {\n                    field: \"default_timezone\".to_string(),\n                    value: new_config.default_timezone.clone(),\n                    reason: \"Mudança de fuso horário não é compatível com a configuração atual\".to_string(),\n                });\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Verifica se uma mudança de fuso horário é compatível\n    fn is_timezone_change_compatible(old: \u0026str, new: \u0026str) -\u003e bool {\n        // Regra: Mudanças entre fusos horários similares são permitidas\n        let compatible_groups = [\n            vec![\"UTC\", \"GMT\"],\n            vec![\"America/Sao_Paulo\", \"America/Argentina/Buenos_Aires\"],\n            vec![\"Europe/London\", \"Europe/Paris\", \"Europe/Berlin\"],\n        ];\n\n        for group in \u0026compatible_groups {\n            if group.contains(\u0026old) \u0026\u0026 group.contains(\u0026new) {\n                return true;\n            }\n        }\n\n        false\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_apply_creation_rules_success() {\n        let result = CompanySettingsBusinessRules::apply_creation_rules(\n            \"John Doe\",\n            \"john@company.com\",\n            \"America/Sao_Paulo\"\n        );\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_apply_creation_rules_name_with_spaces_only() {\n        let result = CompanySettingsBusinessRules::apply_creation_rules(\n            \"   \",\n            \"john@company.com\",\n            \"UTC\"\n        );\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_name\" \u0026\u0026 reason.contains(\"espaços\")));\n    }\n\n    #[test]\n    fn test_apply_creation_rules_name_starts_with_hyphen() {\n        let result = CompanySettingsBusinessRules::apply_creation_rules(\n            \"-John Doe\",\n            \"john@company.com\",\n            \"UTC\"\n        );\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_name\" \u0026\u0026 reason.contains(\"hífen\")));\n    }\n\n    #[test]\n    fn test_apply_creation_rules_reserved_email() {\n        let result = CompanySettingsBusinessRules::apply_creation_rules(\n            \"Admin User\",\n            \"admin@system.local\",\n            \"UTC\"\n        );\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_email\" \u0026\u0026 reason.contains(\"reservado\")));\n    }\n\n    #[test]\n    fn test_apply_creation_rules_generic_email() {\n        let result = CompanySettingsBusinessRules::apply_creation_rules(\n            \"Admin User\",\n            \"admin@company.com\",\n            \"UTC\"\n        );\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_email\" \u0026\u0026 reason.contains(\"genérico\")));\n    }\n\n    #[test]\n    fn test_apply_creation_rules_extreme_timezone() {\n        let result = CompanySettingsBusinessRules::apply_creation_rules(\n            \"Admin User\",\n            \"admin@specificcompany.com\",\n            \"Asia/Tokyo\"\n        );\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"default_timezone\" \u0026\u0026 reason.contains(\"muito extremo\")));\n    }\n\n    #[test]\n    fn test_can_remove_config_system_config() {\n        let config = Config::new(\n            \"System Admin\".to_string(),\n            \"admin@system.local\".to_string(),\n            \"UTC\".to_string(),\n        );\n        let result = CompanySettingsBusinessRules::can_remove_config(\u0026config);\n        assert!(matches!(result, Err(CompanySettingsError::OperationNotAllowed { operation, reason }) \n            if operation == \"remove\" \u0026\u0026 reason.contains(\"sistema\")));\n    }\n\n    #[test]\n    fn test_is_timezone_change_compatible() {\n        assert!(CompanySettingsBusinessRules::is_timezone_change_compatible(\"UTC\", \"GMT\"));\n        assert!(CompanySettingsBusinessRules::is_timezone_change_compatible(\"Europe/London\", \"Europe/Paris\"));\n        assert!(!CompanySettingsBusinessRules::is_timezone_change_compatible(\"UTC\", \"America/Sao_Paulo\"));\n    }\n}\n","traces":[{"line":11,"address":[1809364,1809370,1808416],"length":1,"stats":{"Line":5}},{"line":17,"address":[1808519],"length":1,"stats":{"Line":6}},{"line":18,"address":[1808654],"length":1,"stats":{"Line":4}},{"line":19,"address":[1808782],"length":1,"stats":{"Line":2}},{"line":29,"address":[1809311,1809235],"length":1,"stats":{"Line":2}},{"line":30,"address":[1809062],"length":1,"stats":{"Line":1}},{"line":31,"address":[1809170,1809115],"length":1,"stats":{"Line":2}},{"line":32,"address":[1809178],"length":1,"stats":{"Line":1}},{"line":37,"address":[1810175,1810713,1809408],"length":1,"stats":{"Line":6}},{"line":39,"address":[1809467],"length":1,"stats":{"Line":6}},{"line":40,"address":[1810844],"length":1,"stats":{"Line":1}},{"line":41,"address":[1809564],"length":1,"stats":{"Line":1}},{"line":42,"address":[1809621],"length":1,"stats":{"Line":1}},{"line":43,"address":[1810767],"length":1,"stats":{"Line":1}},{"line":48,"address":[1809510],"length":1,"stats":{"Line":5}},{"line":49,"address":[1409520,1409534],"length":1,"stats":{"Line":20}},{"line":51,"address":[1809764],"length":1,"stats":{"Line":2}},{"line":52,"address":[1809982],"length":1,"stats":{"Line":0}},{"line":53,"address":[1809768],"length":1,"stats":{"Line":0}},{"line":54,"address":[1809842],"length":1,"stats":{"Line":0}},{"line":55,"address":[1809905],"length":1,"stats":{"Line":0}},{"line":60,"address":[1810185,1810259,1809809],"length":1,"stats":{"Line":14}},{"line":61,"address":[1810275],"length":1,"stats":{"Line":4}},{"line":62,"address":[1810534],"length":1,"stats":{"Line":1}},{"line":63,"address":[1810221],"length":1,"stats":{"Line":1}},{"line":64,"address":[1810394],"length":1,"stats":{"Line":1}},{"line":65,"address":[1810457],"length":1,"stats":{"Line":1}},{"line":69,"address":[1810350],"length":1,"stats":{"Line":4}},{"line":73,"address":[1811958,1811008,1811952],"length":1,"stats":{"Line":4}},{"line":75,"address":[1811035],"length":1,"stats":{"Line":2}},{"line":76,"address":[1812389],"length":1,"stats":{"Line":1}},{"line":77,"address":[1811172],"length":1,"stats":{"Line":1}},{"line":78,"address":[1811211],"length":1,"stats":{"Line":1}},{"line":79,"address":[1812312],"length":1,"stats":{"Line":1}},{"line":84,"address":[1811057],"length":1,"stats":{"Line":3}},{"line":85,"address":[1811138],"length":1,"stats":{"Line":3}},{"line":86,"address":[1812089],"length":1,"stats":{"Line":1}},{"line":87,"address":[1811441],"length":1,"stats":{"Line":1}},{"line":88,"address":[1811480],"length":1,"stats":{"Line":1}},{"line":89,"address":[1812012],"length":1,"stats":{"Line":1}},{"line":94,"address":[1811236],"length":1,"stats":{"Line":2}},{"line":95,"address":[1811344,1811505],"length":1,"stats":{"Line":4}},{"line":96,"address":[1811537],"length":1,"stats":{"Line":1}},{"line":97,"address":[1811765],"length":1,"stats":{"Line":0}},{"line":98,"address":[1811585],"length":1,"stats":{"Line":0}},{"line":99,"address":[1811622],"length":1,"stats":{"Line":0}},{"line":100,"address":[1811688],"length":1,"stats":{"Line":0}},{"line":105,"address":[1811573],"length":1,"stats":{"Line":2}},{"line":109,"address":[1812544,1813143,1813137],"length":1,"stats":{"Line":1}},{"line":111,"address":[1812571],"length":1,"stats":{"Line":2}},{"line":115,"address":[1812655],"length":1,"stats":{"Line":2}},{"line":121,"address":[1812676],"length":1,"stats":{"Line":2}},{"line":122,"address":[1812724],"length":1,"stats":{"Line":2}},{"line":123,"address":[1812958],"length":1,"stats":{"Line":1}},{"line":124,"address":[1812763],"length":1,"stats":{"Line":1}},{"line":125,"address":[1812802],"length":1,"stats":{"Line":1}},{"line":126,"address":[1812881],"length":1,"stats":{"Line":1}},{"line":130,"address":[1812754],"length":1,"stats":{"Line":1}},{"line":134,"address":[1813168],"length":1,"stats":{"Line":0}},{"line":140,"address":[1813319],"length":1,"stats":{"Line":0}},{"line":141,"address":[1813387],"length":1,"stats":{"Line":0}},{"line":142,"address":[1813456],"length":1,"stats":{"Line":0}},{"line":145,"address":[1813544],"length":1,"stats":{"Line":0}},{"line":149,"address":[1813884,1813584,1813878],"length":1,"stats":{"Line":1}},{"line":152,"address":[1813622],"length":1,"stats":{"Line":1}},{"line":153,"address":[1813777],"length":1,"stats":{"Line":1}},{"line":154,"address":[1813660],"length":1,"stats":{"Line":1}},{"line":155,"address":[1813694],"length":1,"stats":{"Line":1}},{"line":159,"address":[1813647],"length":1,"stats":{"Line":0}},{"line":163,"address":[1814021,1813904,1814027],"length":1,"stats":{"Line":0}},{"line":169,"address":[1813937],"length":1,"stats":{"Line":0}},{"line":170,"address":[1813948],"length":1,"stats":{"Line":0}},{"line":171,"address":[1814083],"length":1,"stats":{"Line":0}},{"line":172,"address":[1813950],"length":1,"stats":{"Line":0}},{"line":173,"address":[1813984],"length":1,"stats":{"Line":0}},{"line":196,"address":[1814192,1815278,1815272],"length":1,"stats":{"Line":1}},{"line":198,"address":[1814803],"length":1,"stats":{"Line":1}},{"line":199,"address":[1814383,1814222],"length":1,"stats":{"Line":1}},{"line":200,"address":[1814445,1814371],"length":1,"stats":{"Line":2}},{"line":201,"address":[1814650,1814589],"length":1,"stats":{"Line":2}},{"line":204,"address":[1814974,1814907],"length":1,"stats":{"Line":2}},{"line":205,"address":[1815144,1815075],"length":1,"stats":{"Line":2}},{"line":206,"address":[1815246],"length":1,"stats":{"Line":1}},{"line":210,"address":[1815096],"length":1,"stats":{"Line":1}}],"covered":64,"coverable":84},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","company_settings","config.rs"],"content":"pub(crate) use std::fmt::Display;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct Config {\n    pub id: Option\u003cString\u003e,\n    pub manager_name: String,\n    pub manager_email: String,\n    pub default_timezone: String,\n    pub company_name: Option\u003cString\u003e,\n    pub work_hours_start: Option\u003cString\u003e,\n    pub work_hours_end: Option\u003cString\u003e,\n    pub work_days: Vec\u003cWorkDay\u003e,\n    pub created_at: Option\u003cchrono::DateTime\u003cchrono::Utc\u003e\u003e,\n    pub updated_at: Option\u003cchrono::DateTime\u003cchrono::Utc\u003e\u003e,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum WorkDay {\n    Monday,\n    Tuesday,\n    Wednesday,\n    Thursday,\n    Friday,\n    Saturday,\n    Sunday,\n}\n\nimpl WorkDay {\n    pub fn from_str(day: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match day.to_lowercase().as_str() {\n            \"monday\" | \"segunda\" | \"seg\" =\u003e Some(WorkDay::Monday),\n            \"tuesday\" | \"terça\" | \"ter\" =\u003e Some(WorkDay::Tuesday),\n            \"wednesday\" | \"quarta\" | \"qua\" =\u003e Some(WorkDay::Wednesday),\n            \"thursday\" | \"quinta\" | \"qui\" =\u003e Some(WorkDay::Thursday),\n            \"friday\" | \"sexta\" | \"sex\" =\u003e Some(WorkDay::Friday),\n            \"saturday\" | \"sábado\" | \"sab\" =\u003e Some(WorkDay::Saturday),\n            \"sunday\" | \"domingo\" | \"dom\" =\u003e Some(WorkDay::Sunday),\n            _ =\u003e None,\n        }\n    }\n\n    pub fn to_string(\u0026self) -\u003e String {\n        match self {\n            WorkDay::Monday =\u003e \"Monday\".to_string(),\n            WorkDay::Tuesday =\u003e \"Tuesday\".to_string(),\n            WorkDay::Wednesday =\u003e \"Wednesday\".to_string(),\n            WorkDay::Thursday =\u003e \"Thursday\".to_string(),\n            WorkDay::Friday =\u003e \"Friday\".to_string(),\n            WorkDay::Saturday =\u003e \"Saturday\".to_string(),\n            WorkDay::Sunday =\u003e \"Sunday\".to_string(),\n        }\n    }\n}\n\nimpl Config {\n    pub fn new(manager_name: String, manager_email: String, default_timezone: String) -\u003e Self {\n        let now = chrono::Utc::now();\n        Self {\n            id: None,\n            manager_name,\n            manager_email,\n            default_timezone,\n            company_name: None,\n            work_hours_start: None,\n            work_hours_end: None,\n            work_days: vec![\n                WorkDay::Monday,\n                WorkDay::Tuesday,\n                WorkDay::Wednesday,\n                WorkDay::Thursday,\n                WorkDay::Friday,\n            ],\n            created_at: Some(now),\n            updated_at: Some(now),\n        }\n    }\n\n    pub fn with_company_name(mut self, company_name: String) -\u003e Self {\n        self.company_name = Some(company_name);\n        self\n    }\n\n    pub fn with_work_hours(mut self, start: String, end: String) -\u003e Self {\n        self.work_hours_start = Some(start);\n        self.work_hours_end = Some(end);\n        self\n    }\n\n    pub fn with_work_days(mut self, work_days: Vec\u003cWorkDay\u003e) -\u003e Self {\n        self.work_days = work_days;\n        self\n    }\n\n    pub fn update_work_days(\u0026mut self, work_days: Vec\u003cWorkDay\u003e) {\n        self.work_days = work_days;\n        self.updated_at = Some(chrono::Utc::now());\n    }\n\n    pub fn is_work_day(\u0026self, day: \u0026WorkDay) -\u003e bool {\n        self.work_days.contains(day)\n    }\n\n    pub fn is_work_hours(\u0026self, time: \u0026str) -\u003e bool {\n        if let (Some(start), Some(end)) = (\u0026self.work_hours_start, \u0026self.work_hours_end) {\n            time \u003e= start.as_str() \u0026\u0026 time \u003c= end.as_str()\n        } else {\n            true // Se não há horário definido, considera sempre horário de trabalho\n        }\n    }\n}\n\nimpl Display for Config {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Config {{ name: {}, email: {}, timezone: {} }}\",\n            self.manager_name, self.manager_email, self.default_timezone\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_config_display() {\n        let config = Config {\n            id: None,\n            manager_name: \"Admin User\".to_string(),\n            manager_email: \"admin@example.com\".to_string(),\n            default_timezone: \"UTC\".to_string(),\n            company_name: None,\n            work_hours_start: None,\n            work_hours_end: None,\n            work_days: vec![],\n            created_at: None,\n            updated_at: None,\n        };\n        let expected = \"Config { name: Admin User, email: admin@example.com, timezone: UTC }\";\n        assert_eq!(config.to_string(), expected);\n    }\n\n    #[test]\n    fn test_work_day_from_str() {\n        assert_eq!(WorkDay::from_str(\"monday\"), Some(WorkDay::Monday));\n        assert_eq!(WorkDay::from_str(\"segunda\"), Some(WorkDay::Monday));\n        assert_eq!(WorkDay::from_str(\"seg\"), Some(WorkDay::Monday));\n        assert_eq!(WorkDay::from_str(\"invalid\"), None);\n    }\n\n    #[test]\n    fn test_work_day_to_string() {\n        assert_eq!(WorkDay::Monday.to_string(), \"Monday\");\n        assert_eq!(WorkDay::Friday.to_string(), \"Friday\");\n    }\n\n    #[test]\n    fn test_config_builder_pattern() {\n        let config = Config::new(\n            \"John Doe\".to_string(),\n            \"john@company.com\".to_string(),\n            \"America/Sao_Paulo\".to_string(),\n        )\n        .with_company_name(\"Tech Corp\".to_string())\n        .with_work_hours(\"09:00\".to_string(), \"18:00\".to_string())\n        .with_work_days(vec![WorkDay::Monday, WorkDay::Tuesday, WorkDay::Wednesday]);\n\n        assert_eq!(config.company_name, Some(\"Tech Corp\".to_string()));\n        assert_eq!(config.work_hours_start, Some(\"09:00\".to_string()));\n        assert_eq!(config.work_hours_end, Some(\"18:00\".to_string()));\n        assert_eq!(config.work_days.len(), 3);\n    }\n\n    #[test]\n    fn test_config_work_day_checks() {\n        let mut config = Config::new(\n            \"Admin\".to_string(),\n            \"admin@company.com\".to_string(),\n            \"UTC\".to_string(),\n        );\n\n        assert!(config.is_work_day(\u0026WorkDay::Monday));\n        assert!(!config.is_work_day(\u0026WorkDay::Sunday));\n\n        config.update_work_days(vec![WorkDay::Monday, WorkDay::Tuesday]);\n        assert!(config.is_work_day(\u0026WorkDay::Monday));\n        assert!(!config.is_work_day(\u0026WorkDay::Wednesday));\n    }\n\n    #[test]\n    fn test_config_work_hours_checks() {\n        let config = Config::new(\n            \"Admin\".to_string(),\n            \"admin@company.com\".to_string(),\n            \"UTC\".to_string(),\n        )\n        .with_work_hours(\"09:00\".to_string(), \"18:00\".to_string());\n\n        assert!(config.is_work_hours(\"10:00\"));\n        assert!(config.is_work_hours(\"18:00\"));\n        assert!(!config.is_work_hours(\"20:00\"));\n    }\n}\n","traces":[{"line":29,"address":[122416,121232,122410],"length":1,"stats":{"Line":1}},{"line":30,"address":[121350,121258],"length":1,"stats":{"Line":2}},{"line":31,"address":[121366],"length":1,"stats":{"Line":1}},{"line":32,"address":[121513],"length":1,"stats":{"Line":1}},{"line":33,"address":[121660],"length":1,"stats":{"Line":1}},{"line":34,"address":[121807],"length":1,"stats":{"Line":1}},{"line":35,"address":[121954],"length":1,"stats":{"Line":1}},{"line":36,"address":[122101],"length":1,"stats":{"Line":1}},{"line":37,"address":[122248],"length":1,"stats":{"Line":1}},{"line":38,"address":[122382],"length":1,"stats":{"Line":1}},{"line":42,"address":[122432],"length":1,"stats":{"Line":1}},{"line":43,"address":[122451],"length":1,"stats":{"Line":1}},{"line":44,"address":[122487],"length":1,"stats":{"Line":1}},{"line":45,"address":[122515],"length":1,"stats":{"Line":0}},{"line":46,"address":[122540],"length":1,"stats":{"Line":0}},{"line":47,"address":[122565],"length":1,"stats":{"Line":0}},{"line":48,"address":[122590],"length":1,"stats":{"Line":1}},{"line":49,"address":[122615],"length":1,"stats":{"Line":0}},{"line":50,"address":[122640],"length":1,"stats":{"Line":0}},{"line":56,"address":[123618,123791,122672],"length":1,"stats":{"Line":1}},{"line":57,"address":[122704],"length":1,"stats":{"Line":2}},{"line":66,"address":[123061,122960],"length":1,"stats":{"Line":3}},{"line":73,"address":[123213],"length":1,"stats":{"Line":1}},{"line":74,"address":[123237],"length":1,"stats":{"Line":2}},{"line":78,"address":[123824,123995],"length":1,"stats":{"Line":1}},{"line":79,"address":[123942,123851],"length":1,"stats":{"Line":2}},{"line":80,"address":[123975],"length":1,"stats":{"Line":1}},{"line":83,"address":[124436,124016],"length":1,"stats":{"Line":1}},{"line":84,"address":[124050],"length":1,"stats":{"Line":1}},{"line":85,"address":[124202],"length":1,"stats":{"Line":1}},{"line":86,"address":[124376],"length":1,"stats":{"Line":1}},{"line":89,"address":[124464,124613],"length":1,"stats":{"Line":1}},{"line":90,"address":[124496,124570],"length":1,"stats":{"Line":2}},{"line":91,"address":[124593],"length":1,"stats":{"Line":1}},{"line":94,"address":[124703,124640],"length":1,"stats":{"Line":1}},{"line":95,"address":[124659,124739],"length":1,"stats":{"Line":2}},{"line":96,"address":[124762],"length":1,"stats":{"Line":1}},{"line":99,"address":[124832],"length":1,"stats":{"Line":1}},{"line":100,"address":[124850],"length":1,"stats":{"Line":1}},{"line":103,"address":[124896],"length":1,"stats":{"Line":1}},{"line":104,"address":[124915,125020],"length":1,"stats":{"Line":1}},{"line":105,"address":[125046],"length":1,"stats":{"Line":1}},{"line":107,"address":[125015],"length":1,"stats":{"Line":0}},{"line":113,"address":[125152],"length":1,"stats":{"Line":1}},{"line":114,"address":[125183],"length":1,"stats":{"Line":1}}],"covered":39,"coverable":45},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","company_settings","errors.rs"],"content":"use crate::domain::shared::errors::{DomainError, DomainErrorKind};\nuse std::error::Error as StdError;\nuse std::fmt;\n\n/// Company settings specific error types\n#[derive(Debug)]\npub enum CompanySettingsError {\n    ConfigurationNotFound {\n        path: String,\n    },\n    ConfigurationInvalid {\n        field: String,\n        value: String,\n        reason: String,\n    },\n    ConfigurationMissing {\n        field: String,\n    },\n    ManagerNotFound {\n        identifier: String,\n    },\n    InvalidManagerData {\n        field: String,\n        reason: String,\n    },\n    RepositoryInitializationFailed {\n        reason: String,\n    },\n    FileSystemError {\n        operation: String,\n        path: String,\n        details: String,\n    },\n    OperationNotAllowed {\n        operation: String,\n        reason: String,\n    },\n}\n\nimpl fmt::Display for CompanySettingsError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            CompanySettingsError::ConfigurationNotFound { path } =\u003e {\n                write!(f, \"Configuration not found at path '{}'\", path)\n            }\n            CompanySettingsError::ConfigurationInvalid { field, value, reason } =\u003e {\n                write!(\n                    f,\n                    \"Invalid configuration for field '{}' with value '{}': {}\",\n                    field, value, reason\n                )\n            }\n            CompanySettingsError::ConfigurationMissing { field } =\u003e {\n                write!(f, \"Missing configuration for field '{}'\", field)\n            }\n            CompanySettingsError::ManagerNotFound { identifier } =\u003e {\n                write!(f, \"Manager not found with identifier '{}'\", identifier)\n            }\n            CompanySettingsError::InvalidManagerData { field, reason } =\u003e {\n                write!(f, \"Invalid manager data for field '{}': {}\", field, reason)\n            }\n            CompanySettingsError::RepositoryInitializationFailed { reason } =\u003e {\n                write!(f, \"Repository initialization failed: {}\", reason)\n            }\n            CompanySettingsError::FileSystemError {\n                operation,\n                path,\n                details,\n            } =\u003e {\n                write!(\n                    f,\n                    \"File system error during {} on path '{}': {}\",\n                    operation, path, details\n                )\n            }\n            CompanySettingsError::OperationNotAllowed { operation, reason } =\u003e {\n                write!(f, \"Operation '{}' not allowed: {}\", operation, reason)\n            }\n        }\n    }\n}\n\nimpl StdError for CompanySettingsError {}\n\nimpl From\u003cCompanySettingsError\u003e for DomainError {\n    fn from(err: CompanySettingsError) -\u003e Self {\n        match err {\n            CompanySettingsError::ConfigurationNotFound { path } =\u003e {\n                DomainError::new(DomainErrorKind::ConfigurationMissing { field: path })\n            }\n            CompanySettingsError::ConfigurationInvalid { field, value, reason } =\u003e {\n                DomainError::new(DomainErrorKind::ConfigurationInvalid { field, value }).with_context(reason)\n            }\n            CompanySettingsError::ConfigurationMissing { field } =\u003e {\n                DomainError::new(DomainErrorKind::ConfigurationMissing { field })\n            }\n            CompanySettingsError::ManagerNotFound { identifier } =\u003e {\n                DomainError::new(DomainErrorKind::ResourceNotFound { code: identifier })\n            }\n            CompanySettingsError::InvalidManagerData { field, reason } =\u003e {\n                DomainError::new(DomainErrorKind::ValidationError { field, message: reason })\n            }\n            CompanySettingsError::RepositoryInitializationFailed { reason } =\u003e {\n                DomainError::new(DomainErrorKind::RepositoryError {\n                    operation: \"initialization\".to_string(),\n                    details: reason,\n                })\n            }\n            CompanySettingsError::OperationNotAllowed { operation, reason } =\u003e {\n                DomainError::new(DomainErrorKind::Generic {\n                    message: format!(\"Operation '{}' not allowed: {}\", operation, reason),\n                })\n            }\n            CompanySettingsError::FileSystemError {\n                operation,\n                path,\n                details,\n            } =\u003e DomainError::new(DomainErrorKind::Io {\n                operation,\n                path: Some(path),\n            })\n            .with_context(details),\n        }\n    }\n}\n\n// Result type for company settings operations\npub type CompanySettingsResult\u003cT\u003e = Result\u003cT, CompanySettingsError\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_configuration_not_found_error_display() {\n        let error = CompanySettingsError::ConfigurationNotFound {\n            path: \"/config/company.yaml\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Configuration not found at path '/config/company.yaml'\"));\n    }\n\n    #[test]\n    fn test_configuration_invalid_error_display() {\n        let error = CompanySettingsError::ConfigurationInvalid {\n            field: \"timezone\".to_string(),\n            value: \"invalid_timezone\".to_string(),\n            reason: \"Timezone must be a valid IANA timezone identifier\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Invalid configuration for field 'timezone'\"));\n        assert!(display.contains(\"with value 'invalid_timezone'\"));\n        assert!(display.contains(\"Timezone must be a valid IANA timezone identifier\"));\n    }\n\n    #[test]\n    fn test_configuration_missing_error_display() {\n        let error = CompanySettingsError::ConfigurationMissing {\n            field: \"company_name\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Missing configuration for field 'company_name'\"));\n    }\n\n    #[test]\n    fn test_manager_not_found_error_display() {\n        let error = CompanySettingsError::ManagerNotFound {\n            identifier: \"john.doe@company.com\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Manager not found with identifier 'john.doe@company.com'\"));\n    }\n\n    #[test]\n    fn test_invalid_manager_data_error_display() {\n        let error = CompanySettingsError::InvalidManagerData {\n            field: \"email\".to_string(),\n            reason: \"Invalid email format\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Invalid manager data for field 'email'\"));\n        assert!(display.contains(\"Invalid email format\"));\n    }\n\n    #[test]\n    fn test_repository_initialization_failed_error_display() {\n        let error = CompanySettingsError::RepositoryInitializationFailed {\n            reason: \"Database connection failed\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Repository initialization failed\"));\n        assert!(display.contains(\"Database connection failed\"));\n    }\n\n    #[test]\n    fn test_file_system_error_display() {\n        let error = CompanySettingsError::FileSystemError {\n            operation: \"read\".to_string(),\n            path: \"/config/settings.yaml\".to_string(),\n            details: \"Permission denied\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"File system error during read\"));\n        assert!(display.contains(\"on path '/config/settings.yaml'\"));\n        assert!(display.contains(\"Permission denied\"));\n    }\n\n    #[test]\n    fn test_error_debug_formatting() {\n        let error = CompanySettingsError::ConfigurationNotFound {\n            path: \"/test/path\".to_string(),\n        };\n        let debug = format!(\"{:?}\", error);\n        assert!(debug.contains(\"ConfigurationNotFound\"));\n        assert!(debug.contains(\"/test/path\"));\n    }\n\n    #[test]\n    fn test_from_company_settings_error_to_domain_error_configuration_not_found() {\n        let company_error = CompanySettingsError::ConfigurationNotFound {\n            path: \"company_name\".to_string(),\n        };\n        let domain_error: DomainError = company_error.into();\n\n        if let DomainErrorKind::ConfigurationMissing { field } = domain_error.kind() {\n            assert_eq!(field, \"company_name\");\n        } else {\n            panic!(\"Expected ConfigurationMissing error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_company_settings_error_to_domain_error_configuration_invalid() {\n        let company_error = CompanySettingsError::ConfigurationInvalid {\n            field: \"timezone\".to_string(),\n            value: \"invalid_timezone\".to_string(),\n            reason: \"Invalid timezone format\".to_string(),\n        };\n        let domain_error: DomainError = company_error.into();\n\n        if let DomainErrorKind::ConfigurationInvalid { field, value } = domain_error.kind() {\n            assert_eq!(field, \"timezone\");\n            assert_eq!(value, \"invalid_timezone\");\n        } else {\n            panic!(\"Expected ConfigurationInvalid error kind\");\n        }\n\n        assert_eq!(domain_error.context(), Some(\u0026\"Invalid timezone format\".to_string()));\n    }\n\n    #[test]\n    fn test_from_company_settings_error_to_domain_error_configuration_missing() {\n        let company_error = CompanySettingsError::ConfigurationMissing {\n            field: \"company_name\".to_string(),\n        };\n        let domain_error: DomainError = company_error.into();\n\n        if let DomainErrorKind::ConfigurationMissing { field } = domain_error.kind() {\n            assert_eq!(field, \"company_name\");\n        } else {\n            panic!(\"Expected ConfigurationMissing error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_company_settings_error_to_domain_error_manager_not_found() {\n        let company_error = CompanySettingsError::ManagerNotFound {\n            identifier: \"john.doe@company.com\".to_string(),\n        };\n        let domain_error: DomainError = company_error.into();\n\n        if let DomainErrorKind::ResourceNotFound { code } = domain_error.kind() {\n            assert_eq!(code, \"john.doe@company.com\");\n        } else {\n            panic!(\"Expected ResourceNotFound error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_company_settings_error_to_domain_error_invalid_manager_data() {\n        let company_error = CompanySettingsError::InvalidManagerData {\n            field: \"email\".to_string(),\n            reason: \"Invalid email format\".to_string(),\n        };\n        let domain_error: DomainError = company_error.into();\n\n        if let DomainErrorKind::ValidationError { field, message } = domain_error.kind() {\n            assert_eq!(field, \"email\");\n            assert_eq!(message, \"Invalid email format\");\n        } else {\n            panic!(\"Expected ValidationError error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_company_settings_error_to_domain_error_repository_initialization_failed() {\n        let company_error = CompanySettingsError::RepositoryInitializationFailed {\n            reason: \"Database connection failed\".to_string(),\n        };\n        let domain_error: DomainError = company_error.into();\n\n        if let DomainErrorKind::RepositoryError { operation, details } = domain_error.kind() {\n            assert_eq!(operation, \"initialization\");\n            assert_eq!(details, \"Database connection failed\");\n        } else {\n            panic!(\"Expected RepositoryError error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_company_settings_error_to_domain_error_file_system_error() {\n        let company_error = CompanySettingsError::FileSystemError {\n            operation: \"read\".to_string(),\n            path: \"/config/settings.yaml\".to_string(),\n            details: \"Permission denied\".to_string(),\n        };\n        let domain_error: DomainError = company_error.into();\n\n        if let DomainErrorKind::Io { operation, path } = domain_error.kind() {\n            assert_eq!(operation, \"read\");\n            assert_eq!(path, \u0026Some(\"/config/settings.yaml\".to_string()));\n        } else {\n            panic!(\"Expected Io error kind\");\n        }\n\n        assert_eq!(domain_error.context(), Some(\u0026\"Permission denied\".to_string()));\n    }\n\n    #[test]\n    fn test_company_settings_result_success() {\n        let result: CompanySettingsResult\u003cString\u003e = Ok(\"success\".to_string());\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"success\");\n    }\n\n    #[test]\n    fn test_company_settings_result_failure() {\n        let result: CompanySettingsResult\u003cString\u003e = Err(CompanySettingsError::ConfigurationNotFound {\n            path: \"/test/path\".to_string(),\n        });\n        assert!(result.is_err());\n\n        if let Err(CompanySettingsError::ConfigurationNotFound { path }) = result {\n            assert_eq!(path, \"/test/path\");\n        } else {\n            panic!(\"Expected ConfigurationNotFound error\");\n        }\n    }\n\n    #[test]\n    fn test_all_error_variants_covered() {\n        // Test that all error variants can be created and converted\n        let errors = vec![\n            CompanySettingsError::ConfigurationNotFound {\n                path: \"test\".to_string(),\n            },\n            CompanySettingsError::ConfigurationInvalid {\n                field: \"test\".to_string(),\n                value: \"test\".to_string(),\n                reason: \"test\".to_string(),\n            },\n            CompanySettingsError::ConfigurationMissing {\n                field: \"test\".to_string(),\n            },\n            CompanySettingsError::ManagerNotFound {\n                identifier: \"test\".to_string(),\n            },\n            CompanySettingsError::InvalidManagerData {\n                field: \"test\".to_string(),\n                reason: \"test\".to_string(),\n            },\n            CompanySettingsError::RepositoryInitializationFailed {\n                reason: \"test\".to_string(),\n            },\n            CompanySettingsError::FileSystemError {\n                operation: \"test\".to_string(),\n                path: \"test\".to_string(),\n                details: \"test\".to_string(),\n            },\n        ];\n\n        for error in errors {\n            let display = format!(\"{}\", error);\n            assert!(!display.is_empty());\n\n            let debug = format!(\"{:?}\", error);\n            assert!(!debug.is_empty());\n\n            let domain_error: DomainError = error.into();\n            // Verificar que a conversão foi bem-sucedida\n            assert!(matches!(domain_error.kind(), _));\n        }\n    }\n}\n","traces":[{"line":41,"address":[2620464],"length":1,"stats":{"Line":1}},{"line":42,"address":[2620497],"length":1,"stats":{"Line":1}},{"line":43,"address":[2620533],"length":1,"stats":{"Line":1}},{"line":44,"address":[2620542],"length":1,"stats":{"Line":2}},{"line":46,"address":[2620632],"length":1,"stats":{"Line":1}},{"line":47,"address":[2620674],"length":1,"stats":{"Line":1}},{"line":53,"address":[2620947],"length":1,"stats":{"Line":1}},{"line":54,"address":[2620959],"length":1,"stats":{"Line":1}},{"line":56,"address":[2621076],"length":1,"stats":{"Line":2}},{"line":57,"address":[2621088],"length":1,"stats":{"Line":2}},{"line":59,"address":[2621205],"length":1,"stats":{"Line":1}},{"line":60,"address":[2621232],"length":1,"stats":{"Line":1}},{"line":62,"address":[2621435],"length":1,"stats":{"Line":1}},{"line":63,"address":[2621447],"length":1,"stats":{"Line":1}},{"line":65,"address":[2621564],"length":1,"stats":{"Line":1}},{"line":70,"address":[2621606],"length":1,"stats":{"Line":1}},{"line":76,"address":[2621879],"length":1,"stats":{"Line":0}},{"line":77,"address":[2621906],"length":1,"stats":{"Line":0}},{"line":86,"address":[3059104,3060462,3060430],"length":1,"stats":{"Line":2}},{"line":87,"address":[3059125],"length":1,"stats":{"Line":2}},{"line":88,"address":[3059189],"length":1,"stats":{"Line":2}},{"line":89,"address":[3059216],"length":1,"stats":{"Line":2}},{"line":91,"address":[3059274],"length":1,"stats":{"Line":1}},{"line":92,"address":[3059351,3060357],"length":1,"stats":{"Line":2}},{"line":94,"address":[3059459],"length":1,"stats":{"Line":1}},{"line":95,"address":[3059495],"length":1,"stats":{"Line":1}},{"line":97,"address":[3059582],"length":1,"stats":{"Line":1}},{"line":98,"address":[3059618],"length":1,"stats":{"Line":1}},{"line":100,"address":[3059705],"length":1,"stats":{"Line":1}},{"line":101,"address":[3059777],"length":1,"stats":{"Line":1}},{"line":103,"address":[3059907],"length":1,"stats":{"Line":1}},{"line":104,"address":[3060551],"length":1,"stats":{"Line":1}},{"line":105,"address":[3059939],"length":1,"stats":{"Line":1}},{"line":106,"address":[3060511],"length":1,"stats":{"Line":1}},{"line":109,"address":[3060195],"length":1,"stats":{"Line":0}},{"line":110,"address":[3061009],"length":1,"stats":{"Line":0}},{"line":111,"address":[3060251,3060861],"length":1,"stats":{"Line":0}},{"line":114,"address":[3059977],"length":1,"stats":{"Line":1}},{"line":120,"address":[3060057],"length":1,"stats":{"Line":1}},{"line":122,"address":[3060677],"length":1,"stats":{"Line":0}}],"covered":34,"coverable":40},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","company_settings","mod.rs"],"content":"pub mod config;\npub mod errors;\npub mod repository;\npub mod validations;\npub mod business_rules;\n\npub use config::Config;\npub use validations::CompanySettingsValidator;\npub use business_rules::CompanySettingsBusinessRules;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","company_settings","repository.rs"],"content":"use crate::domain::{company_settings::config::Config, shared::errors::DomainError};\nuse crate::infrastructure::persistence::manifests::config_manifest::ConfigManifest;\nuse std::path::PathBuf;\n\npub trait ConfigRepository {\n    fn save(\u0026self, config: ConfigManifest, path: PathBuf) -\u003e Result\u003c(), DomainError\u003e;\n    fn create_repository_dir(\u0026self, path: PathBuf) -\u003e Result\u003c(), DomainError\u003e;\n    fn load(\u0026self) -\u003e Result\u003c(Config, PathBuf), DomainError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","company_settings","validations.rs"],"content":"use crate::domain::shared::errors::DomainError;\nuse crate::domain::company_settings::errors::CompanySettingsError;\n\n/// Validações de domínio para configurações da empresa\npub struct CompanySettingsValidator;\n\nimpl CompanySettingsValidator {\n    /// Valida o nome do gerente\n    pub fn validate_manager_name(name: \u0026str) -\u003e Result\u003c(), CompanySettingsError\u003e {\n        if name.trim().is_empty() {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_name\".to_string(),\n                value: name.to_string(),\n                reason: \"Nome do gerente não pode estar vazio\".to_string(),\n            });\n        }\n\n        if name.len() \u003c 2 {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_name\".to_string(),\n                value: name.to_string(),\n                reason: \"Nome do gerente deve ter pelo menos 2 caracteres\".to_string(),\n            });\n        }\n\n        if name.len() \u003e 100 {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_name\".to_string(),\n                value: name.to_string(),\n                reason: \"Nome do gerente não pode exceder 100 caracteres\".to_string(),\n            });\n        }\n\n        // Validar se contém apenas caracteres válidos (letras, espaços, hífens e acentos)\n        if !name.chars().all(|c| c.is_alphabetic() || c.is_whitespace() || c == '-' || c == '\\'') {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_name\".to_string(),\n                value: name.to_string(),\n                reason: \"Nome do gerente contém caracteres inválidos\".to_string(),\n            });\n        }\n\n        Ok(())\n    }\n\n    /// Valida o email do gerente\n    pub fn validate_manager_email(email: \u0026str) -\u003e Result\u003c(), CompanySettingsError\u003e {\n        if email.trim().is_empty() {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_email\".to_string(),\n                value: email.to_string(),\n                reason: \"Email do gerente não pode estar vazio\".to_string(),\n            });\n        }\n\n        // Validação básica de formato de email\n        if !email.contains('@') || !email.contains('.') {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_email\".to_string(),\n                value: email.to_string(),\n                reason: \"Formato de email inválido\".to_string(),\n            });\n        }\n\n        let parts: Vec\u003c\u0026str\u003e = email.split('@').collect();\n        if parts.len() != 2 {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_email\".to_string(),\n                value: email.to_string(),\n                reason: \"Formato de email inválido\".to_string(),\n            });\n        }\n\n        let local_part = parts[0];\n        let domain_part = parts[1];\n\n        if local_part.is_empty() || domain_part.is_empty() {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_email\".to_string(),\n                value: email.to_string(),\n                reason: \"Partes do email não podem estar vazias\".to_string(),\n            });\n        }\n\n        if local_part.len() \u003e 64 || domain_part.len() \u003e 253 {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"manager_email\".to_string(),\n                value: email.to_string(),\n                reason: \"Email muito longo\".to_string(),\n            });\n        }\n\n        Ok(())\n    }\n\n    /// Valida o fuso horário padrão\n    pub fn validate_default_timezone(timezone: \u0026str) -\u003e Result\u003c(), CompanySettingsError\u003e {\n        if timezone.trim().is_empty() {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"default_timezone\".to_string(),\n                value: timezone.to_string(),\n                reason: \"Fuso horário padrão não pode estar vazio\".to_string(),\n            });\n        }\n\n        // Lista de fusos horários válidos comuns\n        let valid_timezones = [\n            \"UTC\", \"GMT\", \"EST\", \"CST\", \"MST\", \"PST\",\n            \"America/New_York\", \"America/Chicago\", \"America/Denver\", \"America/Los_Angeles\",\n            \"America/Sao_Paulo\", \"America/Argentina/Buenos_Aires\", \"America/Mexico_City\",\n            \"Europe/London\", \"Europe/Paris\", \"Europe/Berlin\", \"Europe/Rome\", \"Europe/Madrid\",\n            \"Asia/Shanghai\", \"Asia/Singapore\", \"Asia/Dubai\",\n            \"Australia/Sydney\", \"Australia/Melbourne\"\n        ];\n\n        if !valid_timezones.contains(\u0026timezone) {\n            return Err(CompanySettingsError::ConfigurationInvalid {\n                field: \"default_timezone\".to_string(),\n                value: timezone.to_string(),\n                reason: format!(\"Fuso horário '{}' não é suportado\", timezone),\n            });\n        }\n\n        Ok(())\n    }\n\n    /// Valida todas as configurações da empresa\n    pub fn validate_all_config(\n        manager_name: \u0026str,\n        manager_email: \u0026str,\n        default_timezone: \u0026str,\n    ) -\u003e Result\u003c(), CompanySettingsError\u003e {\n        Self::validate_manager_name(manager_name)?;\n        Self::validate_manager_email(manager_email)?;\n        Self::validate_default_timezone(default_timezone)?;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validate_manager_name_success() {\n        assert!(CompanySettingsValidator::validate_manager_name(\"John Doe\").is_ok());\n        assert!(CompanySettingsValidator::validate_manager_name(\"Maria José\").is_ok());\n        assert!(CompanySettingsValidator::validate_manager_name(\"Jean-Pierre\").is_ok());\n    }\n\n    #[test]\n    fn test_validate_manager_name_empty() {\n        let result = CompanySettingsValidator::validate_manager_name(\"\");\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_name\" \u0026\u0026 reason.contains(\"vazio\")));\n    }\n\n    #[test]\n    fn test_validate_manager_name_too_short() {\n        let result = CompanySettingsValidator::validate_manager_name(\"A\");\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_name\" \u0026\u0026 reason.contains(\"2 caracteres\")));\n    }\n\n    #[test]\n    fn test_validate_manager_name_too_long() {\n        let long_name = \"A\".repeat(101);\n        let result = CompanySettingsValidator::validate_manager_name(\u0026long_name);\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_name\" \u0026\u0026 reason.contains(\"100 caracteres\")));\n    }\n\n    #[test]\n    fn test_validate_manager_name_invalid_chars() {\n        let result = CompanySettingsValidator::validate_manager_name(\"John123\");\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_name\" \u0026\u0026 reason.contains(\"caracteres inválidos\")));\n    }\n\n    #[test]\n    fn test_validate_manager_email_success() {\n        assert!(CompanySettingsValidator::validate_manager_email(\"john@example.com\").is_ok());\n        assert!(CompanySettingsValidator::validate_manager_email(\"maria.jose@empresa.com.br\").is_ok());\n        assert!(CompanySettingsValidator::validate_manager_email(\"user+tag@domain.org\").is_ok());\n    }\n\n    #[test]\n    fn test_validate_manager_email_empty() {\n        let result = CompanySettingsValidator::validate_manager_email(\"\");\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_email\" \u0026\u0026 reason.contains(\"vazio\")));\n    }\n\n    #[test]\n    fn test_validate_manager_email_no_at() {\n        let result = CompanySettingsValidator::validate_manager_email(\"johnexample.com\");\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_email\" \u0026\u0026 reason.contains(\"Formato de email inválido\")));\n    }\n\n    #[test]\n    fn test_validate_manager_email_no_dot() {\n        let result = CompanySettingsValidator::validate_manager_email(\"john@example\");\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"manager_email\" \u0026\u0026 reason.contains(\"Formato de email inválido\")));\n    }\n\n    #[test]\n    fn test_validate_default_timezone_success() {\n        assert!(CompanySettingsValidator::validate_default_timezone(\"UTC\").is_ok());\n        assert!(CompanySettingsValidator::validate_default_timezone(\"America/Sao_Paulo\").is_ok());\n        assert!(CompanySettingsValidator::validate_default_timezone(\"Europe/London\").is_ok());\n    }\n\n    #[test]\n    fn test_validate_default_timezone_empty() {\n        let result = CompanySettingsValidator::validate_default_timezone(\"\");\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"default_timezone\" \u0026\u0026 reason.contains(\"vazio\")));\n    }\n\n    #[test]\n    fn test_validate_default_timezone_invalid() {\n        let result = CompanySettingsValidator::validate_default_timezone(\"Invalid/Timezone\");\n        assert!(matches!(result, Err(CompanySettingsError::ConfigurationInvalid { field, reason, value: _ }) \n            if field == \"default_timezone\" \u0026\u0026 reason.contains(\"não é suportado\")));\n    }\n\n    #[test]\n    fn test_validate_all_config_success() {\n        let result = CompanySettingsValidator::validate_all_config(\n            \"John Doe\",\n            \"john@example.com\",\n            \"UTC\"\n        );\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_validate_all_config_failure() {\n        let result = CompanySettingsValidator::validate_all_config(\n            \"\",\n            \"invalid-email\",\n            \"Invalid/Timezone\"\n        );\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":9,"address":[3086048,3086801,3086807],"length":1,"stats":{"Line":2}},{"line":10,"address":[3086107],"length":1,"stats":{"Line":2}},{"line":11,"address":[3087538],"length":1,"stats":{"Line":1}},{"line":12,"address":[3086150],"length":1,"stats":{"Line":1}},{"line":13,"address":[3086207],"length":1,"stats":{"Line":1}},{"line":14,"address":[3087461],"length":1,"stats":{"Line":2}},{"line":18,"address":[3086137],"length":1,"stats":{"Line":1}},{"line":19,"address":[3087238],"length":1,"stats":{"Line":1}},{"line":20,"address":[3086237],"length":1,"stats":{"Line":1}},{"line":21,"address":[3086294],"length":1,"stats":{"Line":1}},{"line":22,"address":[3087161],"length":1,"stats":{"Line":1}},{"line":26,"address":[3086224],"length":1,"stats":{"Line":1}},{"line":27,"address":[3086938],"length":1,"stats":{"Line":1}},{"line":28,"address":[3086351],"length":1,"stats":{"Line":1}},{"line":29,"address":[3086408],"length":1,"stats":{"Line":1}},{"line":30,"address":[3086861],"length":1,"stats":{"Line":1}},{"line":35,"address":[2243084,2243056],"length":1,"stats":{"Line":7}},{"line":36,"address":[3086614],"length":1,"stats":{"Line":1}},{"line":37,"address":[3086415],"length":1,"stats":{"Line":1}},{"line":38,"address":[3086472],"length":1,"stats":{"Line":1}},{"line":39,"address":[3086537],"length":1,"stats":{"Line":1}},{"line":43,"address":[3086481],"length":1,"stats":{"Line":1}},{"line":47,"address":[3088411,3088417,3087696],"length":1,"stats":{"Line":1}},{"line":48,"address":[3087773],"length":1,"stats":{"Line":2}},{"line":49,"address":[3090044],"length":1,"stats":{"Line":1}},{"line":50,"address":[3087830],"length":1,"stats":{"Line":1}},{"line":51,"address":[3087893],"length":1,"stats":{"Line":1}},{"line":52,"address":[3089964],"length":1,"stats":{"Line":1}},{"line":57,"address":[3087986,3087809],"length":1,"stats":{"Line":3}},{"line":58,"address":[3088221],"length":1,"stats":{"Line":2}},{"line":59,"address":[3087900],"length":1,"stats":{"Line":1}},{"line":60,"address":[3087963],"length":1,"stats":{"Line":2}},{"line":61,"address":[3088141],"length":1,"stats":{"Line":2}},{"line":65,"address":[3088019],"length":1,"stats":{"Line":1}},{"line":66,"address":[3088476,3088078],"length":1,"stats":{"Line":2}},{"line":67,"address":[3089741],"length":1,"stats":{"Line":0}},{"line":68,"address":[3088517],"length":1,"stats":{"Line":0}},{"line":69,"address":[3089598],"length":1,"stats":{"Line":0}},{"line":70,"address":[3089661],"length":1,"stats":{"Line":0}},{"line":74,"address":[3088482,3088556],"length":1,"stats":{"Line":2}},{"line":75,"address":[3088589],"length":1,"stats":{"Line":1}},{"line":77,"address":[3088753,3088673],"length":1,"stats":{"Line":2}},{"line":78,"address":[3089403],"length":1,"stats":{"Line":0}},{"line":79,"address":[3088715],"length":1,"stats":{"Line":0}},{"line":80,"address":[3089260],"length":1,"stats":{"Line":0}},{"line":81,"address":[3089323],"length":1,"stats":{"Line":0}},{"line":85,"address":[3088769,3088850],"length":1,"stats":{"Line":2}},{"line":86,"address":[3089051],"length":1,"stats":{"Line":0}},{"line":87,"address":[3088814],"length":1,"stats":{"Line":0}},{"line":88,"address":[3088908],"length":1,"stats":{"Line":0}},{"line":89,"address":[3088971],"length":1,"stats":{"Line":0}},{"line":93,"address":[3088866],"length":1,"stats":{"Line":2}},{"line":97,"address":[3091485,3091479,3090224],"length":1,"stats":{"Line":2}},{"line":98,"address":[3090251],"length":1,"stats":{"Line":3}},{"line":99,"address":[3091616],"length":1,"stats":{"Line":1}},{"line":100,"address":[3090936],"length":1,"stats":{"Line":1}},{"line":101,"address":[3090975],"length":1,"stats":{"Line":1}},{"line":102,"address":[3091539],"length":1,"stats":{"Line":1}},{"line":107,"address":[3090285],"length":1,"stats":{"Line":2}},{"line":116,"address":[3090906],"length":1,"stats":{"Line":2}},{"line":117,"address":[3091292],"length":1,"stats":{"Line":1}},{"line":118,"address":[3091000],"length":1,"stats":{"Line":1}},{"line":119,"address":[3091039],"length":1,"stats":{"Line":1}},{"line":120,"address":[3091187,3091122],"length":1,"stats":{"Line":2}},{"line":124,"address":[3091066],"length":1,"stats":{"Line":1}},{"line":128,"address":[3091776],"length":1,"stats":{"Line":2}},{"line":133,"address":[3091868],"length":1,"stats":{"Line":2}},{"line":134,"address":[3091987],"length":1,"stats":{"Line":1}},{"line":135,"address":[3092114],"length":1,"stats":{"Line":1}},{"line":136,"address":[3092234],"length":1,"stats":{"Line":1}}],"covered":58,"coverable":70},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","mod.rs"],"content":"pub mod company_settings;\npub mod project_management;\npub mod resource_management;\npub mod shared;\npub mod task_management;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","project_management","any_project.rs"],"content":"use super::{\n    super::task_management::any_task::AnyTask,\n    project::Project,\n    state::{Cancelled, Completed, InProgress, Planned},\n    vacation_rules::VacationRules,\n};\nuse chrono::NaiveDate;\nuse serde::Serialize;\nuse std::collections::{HashMap, HashSet, VecDeque};\n\n/// An enum to represent a Project in any of its possible states.\n#[derive(Debug, Clone, Serialize)]\n#[serde(tag = \"status\")]\npub enum AnyProject {\n    Planned(Project\u003cPlanned\u003e),\n    InProgress(Project\u003cInProgress\u003e),\n    Completed(Project\u003cCompleted\u003e),\n    Cancelled(Project\u003cCancelled\u003e),\n}\n\nimpl AnyProject {\n    pub fn name(\u0026self) -\u003e \u0026str {\n        match self {\n            AnyProject::Planned(p) =\u003e \u0026p.name,\n            AnyProject::InProgress(p) =\u003e \u0026p.name,\n            AnyProject::Completed(p) =\u003e \u0026p.name,\n            AnyProject::Cancelled(p) =\u003e \u0026p.name,\n        }\n    }\n\n    pub fn code(\u0026self) -\u003e \u0026str {\n        match self {\n            AnyProject::Planned(p) =\u003e \u0026p.code,\n            AnyProject::InProgress(p) =\u003e \u0026p.code,\n            AnyProject::Completed(p) =\u003e \u0026p.code,\n            AnyProject::Cancelled(p) =\u003e \u0026p.code,\n        }\n    }\n\n    pub fn description(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        match self {\n            AnyProject::Planned(p) =\u003e p.description.as_ref(),\n            AnyProject::InProgress(p) =\u003e p.description.as_ref(),\n            AnyProject::Completed(p) =\u003e p.description.as_ref(),\n            AnyProject::Cancelled(p) =\u003e p.description.as_ref(),\n        }\n    }\n\n    pub fn timezone(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        match self {\n            AnyProject::Planned(p) =\u003e p.timezone.as_ref(),\n            AnyProject::InProgress(p) =\u003e p.timezone.as_ref(),\n            AnyProject::Completed(p) =\u003e p.timezone.as_ref(),\n            AnyProject::Cancelled(p) =\u003e p.timezone.as_ref(),\n        }\n    }\n\n    pub fn vacation_rules(\u0026self) -\u003e Option\u003c\u0026VacationRules\u003e {\n        match self {\n            AnyProject::Planned(p) =\u003e p.vacation_rules.as_ref(),\n            AnyProject::InProgress(p) =\u003e p.vacation_rules.as_ref(),\n            AnyProject::Completed(p) =\u003e p.vacation_rules.as_ref(),\n            AnyProject::Cancelled(p) =\u003e p.vacation_rules.as_ref(),\n        }\n    }\n\n    pub fn tasks(\u0026self) -\u003e \u0026HashMap\u003cString, AnyTask\u003e {\n        match self {\n            AnyProject::Planned(p) =\u003e \u0026p.tasks,\n            AnyProject::InProgress(p) =\u003e \u0026p.tasks,\n            AnyProject::Completed(p) =\u003e \u0026p.tasks,\n            AnyProject::Cancelled(p) =\u003e \u0026p.tasks,\n        }\n    }\n\n    // Adiciona método para iterador zero-copy\n    pub fn tasks_iter(\u0026self) -\u003e impl Iterator\u003cItem = (\u0026String, \u0026AnyTask)\u003e {\n        match self {\n            AnyProject::Planned(p) =\u003e p.tasks.iter(),\n            AnyProject::InProgress(p) =\u003e p.tasks.iter(),\n            AnyProject::Completed(p) =\u003e p.tasks.iter(),\n            AnyProject::Cancelled(p) =\u003e p.tasks.iter(),\n        }\n    }\n\n    // Adiciona método para obter apenas os códigos das tarefas\n    pub fn task_codes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        match self {\n            AnyProject::Planned(p) =\u003e p.tasks.keys(),\n            AnyProject::InProgress(p) =\u003e p.tasks.keys(),\n            AnyProject::Completed(p) =\u003e p.tasks.keys(),\n            AnyProject::Cancelled(p) =\u003e p.tasks.keys(),\n        }\n    }\n\n    pub fn add_task(\u0026mut self, task: AnyTask) {\n        let tasks = match self {\n            AnyProject::Planned(p) =\u003e \u0026mut p.tasks,\n            AnyProject::InProgress(p) =\u003e \u0026mut p.tasks,\n            AnyProject::Completed(p) =\u003e \u0026mut p.tasks,\n            AnyProject::Cancelled(p) =\u003e \u0026mut p.tasks,\n        };\n        tasks.insert(task.code().to_string(), task);\n    }\n\n    pub fn assign_resource_to_task(\u0026mut self, task_code: \u0026str, resource_codes: \u0026[\u0026str]) -\u003e Result\u003c(), String\u003e {\n        let tasks_map = match self {\n            AnyProject::Planned(p) =\u003e \u0026mut p.tasks,\n            AnyProject::InProgress(p) =\u003e \u0026mut p.tasks,\n            AnyProject::Completed(_) =\u003e return Err(\"Cannot modify tasks in a completed project.\".to_string()),\n            AnyProject::Cancelled(_) =\u003e return Err(\"Cannot modify tasks in a cancelled project.\".to_string()),\n        };\n\n        let task = tasks_map\n            .get_mut(task_code)\n            .ok_or_else(|| format!(\"Task '{task_code}' not found in project.\"))?;\n\n        // Logic to update assignees, handling duplicates\n        let mut current_assignees: HashSet\u003cString\u003e = match task {\n            AnyTask::Planned(t) =\u003e t.assigned_resources.iter().cloned().collect(),\n            AnyTask::InProgress(t) =\u003e t.assigned_resources.iter().cloned().collect(),\n            AnyTask::Blocked(t) =\u003e t.assigned_resources.iter().cloned().collect(),\n            AnyTask::Completed(_) =\u003e return Err(\"Cannot assign resources to a completed task.\".to_string()),\n            AnyTask::Cancelled(_) =\u003e return Err(\"Cannot assign resources to a cancelled task.\".to_string()),\n        };\n\n        for code in resource_codes {\n            current_assignees.insert(code.to_string());\n        }\n\n        let new_assignees: Vec\u003cString\u003e = current_assignees.into_iter().collect();\n\n        // Re-assign the updated list\n        match task {\n            AnyTask::Planned(t) =\u003e t.assigned_resources = new_assignees,\n            AnyTask::InProgress(t) =\u003e t.assigned_resources = new_assignees,\n            AnyTask::Blocked(t) =\u003e t.assigned_resources = new_assignees,\n            _ =\u003e {} // Other states already returned an error\n        }\n\n        Ok(())\n    }\n\n    pub fn add_dependency_to_task(\u0026mut self, task_code: \u0026str, dependency_code: \u0026str) -\u003e Result\u003cAnyTask, String\u003e {\n        let tasks_map = match self {\n            AnyProject::Planned(p) =\u003e \u0026mut p.tasks,\n            AnyProject::InProgress(p) =\u003e \u0026mut p.tasks,\n            AnyProject::Completed(_) =\u003e return Err(\"Cannot modify tasks in a completed project.\".to_string()),\n            AnyProject::Cancelled(_) =\u003e return Err(\"Cannot modify tasks in a cancelled project.\".to_string()),\n        };\n\n        if !tasks_map.contains_key(dependency_code) {\n            return Err(format!(\"Dependency task '{dependency_code}' not found in project.\"));\n        }\n\n        let task = tasks_map\n            .get_mut(task_code)\n            .ok_or_else(|| format!(\"Task '{task_code}' not found in project.\"))?;\n\n        let dependencies = match task {\n            AnyTask::Planned(t) =\u003e \u0026mut t.dependencies,\n            AnyTask::InProgress(t) =\u003e \u0026mut t.dependencies,\n            AnyTask::Blocked(t) =\u003e \u0026mut t.dependencies,\n            AnyTask::Completed(_) =\u003e return Err(\"Cannot add dependency to a completed task.\".to_string()),\n            AnyTask::Cancelled(_) =\u003e return Err(\"Cannot add dependency to a cancelled task.\".to_string()),\n        };\n\n        if !dependencies.contains(\u0026dependency_code.to_string()) {\n            dependencies.push(dependency_code.to_string());\n        }\n\n        Ok(task.clone())\n    }\n\n    pub fn remove_dependency_from_task(\u0026mut self, task_code: \u0026str, dependency_code: \u0026str) -\u003e Result\u003cAnyTask, String\u003e {\n        let tasks_map = match self {\n            AnyProject::Planned(p) =\u003e \u0026mut p.tasks,\n            AnyProject::InProgress(p) =\u003e \u0026mut p.tasks,\n            AnyProject::Completed(_) =\u003e return Err(\"Cannot modify tasks in a completed project.\".to_string()),\n            AnyProject::Cancelled(_) =\u003e return Err(\"Cannot modify tasks in a cancelled project.\".to_string()),\n        };\n\n        let task = tasks_map\n            .get_mut(task_code)\n            .ok_or_else(|| format!(\"Task '{task_code}' not found in project.\"))?;\n\n        let dependencies = match task {\n            AnyTask::Planned(t) =\u003e \u0026mut t.dependencies,\n            AnyTask::InProgress(t) =\u003e \u0026mut t.dependencies,\n            AnyTask::Blocked(t) =\u003e \u0026mut t.dependencies,\n            AnyTask::Completed(_) =\u003e return Err(\"Cannot modify dependencies of a completed task.\".to_string()),\n            AnyTask::Cancelled(_) =\u003e return Err(\"Cannot modify dependencies of a cancelled task.\".to_string()),\n        };\n\n        // Remove the dependency if it exists\n        dependencies.retain(|dep| dep != dependency_code);\n\n        Ok(task.clone())\n    }\n\n    pub fn update_task(\n        \u0026mut self,\n        task_code: \u0026str,\n        name: Option\u003cString\u003e,\n        description: Option\u003cString\u003e,\n        start_date: Option\u003cNaiveDate\u003e,\n        due_date: Option\u003cNaiveDate\u003e,\n    ) -\u003e Result\u003c(), String\u003e {\n        let tasks_map = match self {\n            AnyProject::Planned(p) =\u003e \u0026mut p.tasks,\n            AnyProject::InProgress(p) =\u003e \u0026mut p.tasks,\n            AnyProject::Completed(_) =\u003e return Err(\"Cannot modify tasks in a completed project.\".to_string()),\n            AnyProject::Cancelled(_) =\u003e return Err(\"Cannot modify tasks in a cancelled project.\".to_string()),\n        };\n\n        let task = tasks_map\n            .get_mut(task_code)\n            .ok_or_else(|| format!(\"Task '{task_code}' not found in project.\"))?;\n\n        macro_rules! update_field {\n            ($task_struct:expr, $field:ident, $value:expr) =\u003e {\n                if let Some(val) = $value {\n                    $task_struct.$field = val;\n                }\n            };\n        }\n\n        macro_rules! update_optional_field {\n            ($task_struct:expr, $field:ident, $value:expr) =\u003e {\n                if let Some(val) = $value {\n                    $task_struct.$field = Some(val);\n                }\n            };\n        }\n\n        match task {\n            AnyTask::Planned(t) =\u003e {\n                update_field!(t, name, name);\n                update_optional_field!(t, description, description);\n                update_field!(t, start_date, start_date);\n                update_field!(t, due_date, due_date);\n            }\n            AnyTask::InProgress(t) =\u003e {\n                update_field!(t, name, name);\n                update_optional_field!(t, description, description);\n                update_field!(t, start_date, start_date);\n                update_field!(t, due_date, due_date);\n            }\n            AnyTask::Blocked(t) =\u003e {\n                update_field!(t, name, name);\n                update_optional_field!(t, description, description);\n                update_field!(t, start_date, start_date);\n                update_field!(t, due_date, due_date);\n            }\n            AnyTask::Completed(_) =\u003e return Err(\"Cannot modify a completed task.\".to_string()),\n            AnyTask::Cancelled(_) =\u003e return Err(\"Cannot modify a cancelled task.\".to_string()),\n        }\n\n        Ok(())\n    }\n\n    pub fn cancel_task(\u0026mut self, task_code: \u0026str) -\u003e Result\u003c(), String\u003e {\n        let tasks_map = match self {\n            AnyProject::Planned(p) =\u003e \u0026mut p.tasks,\n            AnyProject::InProgress(p) =\u003e \u0026mut p.tasks,\n            AnyProject::Completed(_) =\u003e return Err(\"Cannot cancel tasks in a completed project.\".to_string()),\n            AnyProject::Cancelled(_) =\u003e return Err(\"Cannot cancel tasks in a cancelled project.\".to_string()),\n        };\n\n        // Take the task out of the map to be able to consume it in the state transition\n        let task = tasks_map\n            .remove(task_code)\n            .ok_or_else(|| format!(\"Task '{task_code}' not found in project.\"))?;\n\n        let cancelled_task: AnyTask = match task {\n            AnyTask::Planned(t) =\u003e t.cancel().into(),\n            AnyTask::InProgress(t) =\u003e t.cancel().into(),\n            AnyTask::Blocked(t) =\u003e t.cancel().into(),\n            AnyTask::Completed(t) =\u003e {\n                // Cannot cancel a completed task, so we put it back and return an error.\n                let original_task = t.into();\n                tasks_map.insert(task_code.to_string(), original_task);\n                return Err(\"Cannot cancel a completed task.\".to_string());\n            }\n            AnyTask::Cancelled(t) =\u003e {\n                // Task is already cancelled, no action needed. Just put it back.\n                let original_task = t.into();\n                tasks_map.insert(task_code.to_string(), original_task);\n                return Ok(());\n            }\n        };\n\n        tasks_map.insert(task_code.to_string(), cancelled_task);\n\n        Ok(())\n    }\n    pub fn set_name(\u0026mut self, name: String) {\n        match self {\n            AnyProject::Planned(p) =\u003e p.name = name,\n            AnyProject::InProgress(p) =\u003e p.name = name,\n            AnyProject::Completed(p) =\u003e p.name = name,\n            AnyProject::Cancelled(p) =\u003e p.name = name,\n        }\n    }\n\n    pub fn set_description(\u0026mut self, description: Option\u003cString\u003e) {\n        match self {\n            AnyProject::Planned(p) =\u003e p.description = description,\n            AnyProject::InProgress(p) =\u003e p.description = description,\n            AnyProject::Completed(p) =\u003e p.description = description,\n            AnyProject::Cancelled(p) =\u003e p.description = description,\n        }\n    }\n\n    pub fn status(\u0026self) -\u003e \u0026str {\n        // Otimizado: removido 'static desnecessário\n        match self {\n            AnyProject::Planned(_) =\u003e \"Planned\",\n            AnyProject::InProgress(_) =\u003e \"InProgress\",\n            AnyProject::Completed(_) =\u003e \"Completed\",\n            AnyProject::Cancelled(_) =\u003e \"Cancelled\",\n        }\n    }\n\n    pub fn reschedule_dependents_of(\u0026mut self, updated_task_code: \u0026str) -\u003e Result\u003c(), String\u003e {\n        let tasks_map = match self {\n            AnyProject::Planned(p) =\u003e \u0026mut p.tasks,\n            AnyProject::InProgress(p) =\u003e \u0026mut p.tasks,\n            _ =\u003e return Ok(()), // No-op for projects that can't be modified.\n        };\n\n        let mut queue = VecDeque::new();\n        queue.push_back(updated_task_code.to_string());\n\n        // A basic cycle detection; if we see the same task too many times, something is wrong.\n        // A better implementation would be in LinkTaskUseCase.\n        let mut processed_count = HashMap::new();\n\n        while let Some(current_code) = queue.pop_front() {\n            let count = processed_count.entry(current_code.clone()).or_insert(0);\n            *count += 1;\n            if *count \u003e tasks_map.len() {\n                return Err(format!(\"Circular dependency detected involving task '{current_code}'\"));\n            }\n\n            let new_start_date_for_dependents = if let Some(current_task) = tasks_map.get(\u0026current_code) {\n                *current_task.due_date() + chrono::Duration::days(1)\n            } else {\n                continue; // Task might not exist, skip.\n            };\n\n            // Collect codes to avoid borrowing issues.\n            let dependent_codes: Vec\u003cString\u003e = tasks_map\n                .values()\n                .filter(|task| {\n                    let deps = match *task {\n                        AnyTask::Planned(t) =\u003e \u0026t.dependencies,\n                        AnyTask::InProgress(t) =\u003e \u0026t.dependencies,\n                        AnyTask::Blocked(t) =\u003e \u0026t.dependencies,\n                        AnyTask::Completed(t) =\u003e \u0026t.dependencies,\n                        AnyTask::Cancelled(t) =\u003e \u0026t.dependencies,\n                    };\n                    deps.contains(\u0026current_code)\n                })\n                .map(|task| task.code().to_string())\n                .collect();\n\n            for code in \u0026dependent_codes {\n                if let Some(dependent_task) = tasks_map.get_mut(code) {\n                    // Get mutable references to start_date and due_date\n                    let (start_date, due_date) = match dependent_task {\n                        AnyTask::Planned(t) =\u003e (\u0026mut t.start_date, \u0026mut t.due_date),\n                        AnyTask::InProgress(t) =\u003e (\u0026mut t.start_date, \u0026mut t.due_date),\n                        AnyTask::Blocked(t) =\u003e (\u0026mut t.start_date, \u0026mut t.due_date),\n                        // Cannot reschedule tasks in a final state.\n                        _ =\u003e continue,\n                    };\n\n                    let duration = *due_date - *start_date;\n                    *start_date = new_start_date_for_dependents;\n                    *due_date = *start_date + duration;\n                }\n\n                queue.push_back(code.clone());\n            }\n        }\n\n        Ok(())\n    }\n    pub fn cancel(self) -\u003e Result\u003cAnyProject, String\u003e {\n        let cancelled_project = match self {\n            AnyProject::Planned(p) =\u003e p.cancel().into(),\n            AnyProject::InProgress(p) =\u003e p.cancel().into(),\n            AnyProject::Completed(_) =\u003e return Err(\"Cannot cancel a completed project.\".to_string()),\n            AnyProject::Cancelled(_) =\u003e return Err(\"Project is already cancelled.\".to_string()),\n        };\n        Ok(cancelled_project)\n    }\n}\n\nimpl From\u003cProject\u003cPlanned\u003e\u003e for AnyProject {\n    fn from(project: Project\u003cPlanned\u003e) -\u003e Self {\n        AnyProject::Planned(project)\n    }\n}\n\nimpl From\u003cProject\u003cInProgress\u003e\u003e for AnyProject {\n    fn from(project: Project\u003cInProgress\u003e) -\u003e Self {\n        AnyProject::InProgress(project)\n    }\n}\n\nimpl From\u003cProject\u003cCompleted\u003e\u003e for AnyProject {\n    fn from(project: Project\u003cCompleted\u003e) -\u003e Self {\n        AnyProject::Completed(project)\n    }\n}\n\nimpl From\u003cProject\u003cCancelled\u003e\u003e for AnyProject {\n    fn from(project: Project\u003cCancelled\u003e) -\u003e Self {\n        AnyProject::Cancelled(project)\n    }\n}\n","traces":[{"line":22,"address":[793200],"length":1,"stats":{"Line":1}},{"line":23,"address":[793378,793213],"length":1,"stats":{"Line":2}},{"line":24,"address":[793248],"length":1,"stats":{"Line":1}},{"line":25,"address":[793282],"length":1,"stats":{"Line":1}},{"line":26,"address":[793316],"length":1,"stats":{"Line":0}},{"line":27,"address":[793350],"length":1,"stats":{"Line":0}},{"line":31,"address":[793408],"length":1,"stats":{"Line":1}},{"line":32,"address":[793570,793421],"length":1,"stats":{"Line":2}},{"line":33,"address":[793456],"length":1,"stats":{"Line":1}},{"line":34,"address":[793486],"length":1,"stats":{"Line":1}},{"line":35,"address":[793516],"length":1,"stats":{"Line":0}},{"line":36,"address":[793546],"length":1,"stats":{"Line":1}},{"line":40,"address":[793600],"length":1,"stats":{"Line":1}},{"line":41,"address":[793614],"length":1,"stats":{"Line":1}},{"line":42,"address":[793650],"length":1,"stats":{"Line":1}},{"line":43,"address":[793681],"length":1,"stats":{"Line":0}},{"line":44,"address":[793712],"length":1,"stats":{"Line":0}},{"line":45,"address":[793743],"length":1,"stats":{"Line":0}},{"line":49,"address":[793792],"length":1,"stats":{"Line":1}},{"line":50,"address":[793806],"length":1,"stats":{"Line":1}},{"line":51,"address":[793842],"length":1,"stats":{"Line":1}},{"line":52,"address":[793873],"length":1,"stats":{"Line":1}},{"line":53,"address":[793904],"length":1,"stats":{"Line":0}},{"line":54,"address":[793935],"length":1,"stats":{"Line":0}},{"line":58,"address":[793984],"length":1,"stats":{"Line":1}},{"line":59,"address":[793998],"length":1,"stats":{"Line":2}},{"line":60,"address":[794034],"length":1,"stats":{"Line":0}},{"line":61,"address":[794067],"length":1,"stats":{"Line":2}},{"line":62,"address":[794100],"length":1,"stats":{"Line":0}},{"line":63,"address":[794133],"length":1,"stats":{"Line":0}},{"line":67,"address":[794176],"length":1,"stats":{"Line":1}},{"line":68,"address":[794323,794186],"length":1,"stats":{"Line":2}},{"line":69,"address":[794222],"length":1,"stats":{"Line":2}},{"line":70,"address":[794249],"length":1,"stats":{"Line":1}},{"line":71,"address":[794276],"length":1,"stats":{"Line":0}},{"line":72,"address":[794303],"length":1,"stats":{"Line":0}},{"line":77,"address":[794336],"length":1,"stats":{"Line":0}},{"line":78,"address":[794359],"length":1,"stats":{"Line":0}},{"line":79,"address":[794399],"length":1,"stats":{"Line":0}},{"line":80,"address":[794431],"length":1,"stats":{"Line":0}},{"line":81,"address":[794463],"length":1,"stats":{"Line":0}},{"line":82,"address":[794495],"length":1,"stats":{"Line":0}},{"line":87,"address":[794528],"length":1,"stats":{"Line":0}},{"line":88,"address":[794551],"length":1,"stats":{"Line":0}},{"line":89,"address":[794591],"length":1,"stats":{"Line":0}},{"line":90,"address":[794623],"length":1,"stats":{"Line":0}},{"line":91,"address":[794655],"length":1,"stats":{"Line":0}},{"line":92,"address":[794687],"length":1,"stats":{"Line":0}},{"line":96,"address":[794720,795125,795100],"length":1,"stats":{"Line":2}},{"line":97,"address":[794745],"length":1,"stats":{"Line":3}},{"line":98,"address":[794797],"length":1,"stats":{"Line":3}},{"line":99,"address":[794827],"length":1,"stats":{"Line":1}},{"line":100,"address":[794857],"length":1,"stats":{"Line":0}},{"line":101,"address":[794887],"length":1,"stats":{"Line":0}},{"line":103,"address":[794915,794993],"length":1,"stats":{"Line":6}},{"line":106,"address":[797242,795136,797210],"length":1,"stats":{"Line":1}},{"line":107,"address":[795205],"length":1,"stats":{"Line":1}},{"line":108,"address":[795257],"length":1,"stats":{"Line":1}},{"line":109,"address":[795293],"length":1,"stats":{"Line":0}},{"line":110,"address":[795324],"length":1,"stats":{"Line":0}},{"line":111,"address":[795395],"length":1,"stats":{"Line":0}},{"line":114,"address":[795466,795624,795513],"length":1,"stats":{"Line":2}},{"line":115,"address":[795474],"length":1,"stats":{"Line":1}},{"line":116,"address":[795576,795495],"length":1,"stats":{"Line":1}},{"line":119,"address":[795670],"length":1,"stats":{"Line":1}},{"line":120,"address":[795733],"length":1,"stats":{"Line":1}},{"line":121,"address":[795812],"length":1,"stats":{"Line":0}},{"line":122,"address":[795891],"length":1,"stats":{"Line":0}},{"line":123,"address":[795961],"length":1,"stats":{"Line":0}},{"line":124,"address":[796032],"length":1,"stats":{"Line":0}},{"line":127,"address":[796185,796113],"length":1,"stats":{"Line":2}},{"line":128,"address":[796285,797178],"length":1,"stats":{"Line":2}},{"line":131,"address":[796307],"length":1,"stats":{"Line":1}},{"line":134,"address":[796422],"length":1,"stats":{"Line":1}},{"line":135,"address":[796542,796779],"length":1,"stats":{"Line":1}},{"line":136,"address":[796893,796625],"length":1,"stats":{"Line":0}},{"line":137,"address":[797007,796708],"length":1,"stats":{"Line":0}},{"line":141,"address":[796505],"length":1,"stats":{"Line":1}},{"line":144,"address":[797264,798614,798620],"length":1,"stats":{"Line":1}},{"line":145,"address":[797314],"length":1,"stats":{"Line":1}},{"line":146,"address":[797350],"length":1,"stats":{"Line":1}},{"line":147,"address":[797386],"length":1,"stats":{"Line":0}},{"line":148,"address":[797417],"length":1,"stats":{"Line":0}},{"line":149,"address":[797502],"length":1,"stats":{"Line":0}},{"line":152,"address":[797587],"length":1,"stats":{"Line":1}},{"line":153,"address":[797618],"length":1,"stats":{"Line":0}},{"line":156,"address":[797967,797841,797797],"length":1,"stats":{"Line":2}},{"line":157,"address":[797805],"length":1,"stats":{"Line":1}},{"line":158,"address":[797919,797823],"length":1,"stats":{"Line":1}},{"line":160,"address":[798010],"length":1,"stats":{"Line":1}},{"line":161,"address":[798073],"length":1,"stats":{"Line":1}},{"line":162,"address":[798107],"length":1,"stats":{"Line":0}},{"line":163,"address":[798141],"length":1,"stats":{"Line":0}},{"line":164,"address":[798166],"length":1,"stats":{"Line":0}},{"line":165,"address":[798251],"length":1,"stats":{"Line":0}},{"line":168,"address":[798336,798554],"length":1,"stats":{"Line":1}},{"line":169,"address":[798489],"length":1,"stats":{"Line":1}},{"line":172,"address":[798573],"length":1,"stats":{"Line":1}},{"line":175,"address":[798640],"length":1,"stats":{"Line":1}},{"line":176,"address":[798690],"length":1,"stats":{"Line":1}},{"line":177,"address":[798726],"length":1,"stats":{"Line":1}},{"line":178,"address":[798759],"length":1,"stats":{"Line":0}},{"line":179,"address":[798787],"length":1,"stats":{"Line":0}},{"line":180,"address":[798860],"length":1,"stats":{"Line":0}},{"line":183,"address":[798977,799088,798936],"length":1,"stats":{"Line":2}},{"line":184,"address":[798941],"length":1,"stats":{"Line":1}},{"line":185,"address":[798959,799040],"length":1,"stats":{"Line":1}},{"line":187,"address":[799133],"length":1,"stats":{"Line":1}},{"line":188,"address":[799195],"length":1,"stats":{"Line":1}},{"line":189,"address":[799228],"length":1,"stats":{"Line":0}},{"line":190,"address":[799261],"length":1,"stats":{"Line":0}},{"line":191,"address":[799286],"length":1,"stats":{"Line":0}},{"line":192,"address":[799371],"length":1,"stats":{"Line":0}},{"line":196,"address":[799453],"length":1,"stats":{"Line":3}},{"line":198,"address":[799475],"length":1,"stats":{"Line":1}},{"line":201,"address":[802482,799536,802466],"length":1,"stats":{"Line":2}},{"line":209,"address":[799600],"length":1,"stats":{"Line":2}},{"line":210,"address":[799668],"length":1,"stats":{"Line":2}},{"line":211,"address":[799698],"length":1,"stats":{"Line":0}},{"line":212,"address":[802341,799723],"length":1,"stats":{"Line":0}},{"line":213,"address":[802377,799754],"length":1,"stats":{"Line":0}},{"line":216,"address":[799788,800003,799922,802334],"length":1,"stats":{"Line":4}},{"line":217,"address":[799793],"length":1,"stats":{"Line":2}},{"line":218,"address":[799899,799971],"length":1,"stats":{"Line":2}},{"line":222,"address":[801176,802064,800981,801287,801988,800158,801507,800379,801432,801719,801834,800576,801471,800225,800688,800284,800836,802027,800875],"length":1,"stats":{"Line":8}},{"line":223,"address":[801446,800850,801615,801553,801073,802002,802058,801012,801501,800902,800410,800472],"length":1,"stats":{"Line":2}},{"line":230,"address":[801734,800454,801056,800826,801423,801597,801190,800591,801978],"length":1,"stats":{"Line":1}},{"line":231,"address":[801856,801308,801221,801765,800710,800622],"length":1,"stats":{"Line":0}},{"line":236,"address":[800049],"length":1,"stats":{"Line":2}},{"line":237,"address":[800117],"length":1,"stats":{"Line":2}},{"line":238,"address":[800134],"length":1,"stats":{"Line":2}},{"line":239,"address":[800430],"length":1,"stats":{"Line":1}},{"line":240,"address":[800669],"length":1,"stats":{"Line":1}},{"line":241,"address":[800856],"length":1,"stats":{"Line":2}},{"line":243,"address":[800185],"length":1,"stats":{"Line":0}},{"line":244,"address":[800201],"length":1,"stats":{"Line":0}},{"line":245,"address":[801032],"length":1,"stats":{"Line":0}},{"line":246,"address":[801268],"length":1,"stats":{"Line":0}},{"line":247,"address":[801452],"length":1,"stats":{"Line":0}},{"line":249,"address":[800252],"length":1,"stats":{"Line":0}},{"line":250,"address":[800260],"length":1,"stats":{"Line":0}},{"line":251,"address":[801573],"length":1,"stats":{"Line":0}},{"line":252,"address":[801815],"length":1,"stats":{"Line":0}},{"line":253,"address":[802008],"length":1,"stats":{"Line":0}},{"line":255,"address":[800301,802241],"length":1,"stats":{"Line":0}},{"line":256,"address":[800335,802297],"length":1,"stats":{"Line":0}},{"line":259,"address":[800918],"length":1,"stats":{"Line":1}},{"line":262,"address":[802512,804127,804775],"length":1,"stats":{"Line":1}},{"line":263,"address":[802582],"length":1,"stats":{"Line":1}},{"line":264,"address":[802691],"length":1,"stats":{"Line":1}},{"line":265,"address":[802730],"length":1,"stats":{"Line":0}},{"line":266,"address":[802761],"length":1,"stats":{"Line":0}},{"line":267,"address":[802835],"length":1,"stats":{"Line":0}},{"line":271,"address":[802975,803089,802909],"length":1,"stats":{"Line":2}},{"line":272,"address":[802917],"length":1,"stats":{"Line":1}},{"line":273,"address":[803041,802946],"length":1,"stats":{"Line":1}},{"line":275,"address":[803224],"length":1,"stats":{"Line":1}},{"line":276,"address":[803726,803287],"length":1,"stats":{"Line":2}},{"line":277,"address":[803812,803353],"length":1,"stats":{"Line":0}},{"line":278,"address":[803419,803852],"length":1,"stats":{"Line":0}},{"line":279,"address":[803485],"length":1,"stats":{"Line":0}},{"line":281,"address":[803533,804133],"length":1,"stats":{"Line":0}},{"line":282,"address":[804141,804230],"length":1,"stats":{"Line":0}},{"line":283,"address":[804321],"length":1,"stats":{"Line":0}},{"line":285,"address":[803558],"length":1,"stats":{"Line":0}},{"line":287,"address":[804434,803606],"length":1,"stats":{"Line":0}},{"line":288,"address":[804531,804442],"length":1,"stats":{"Line":0}},{"line":289,"address":[804628],"length":1,"stats":{"Line":0}},{"line":293,"address":[803933,803764],"length":1,"stats":{"Line":2}},{"line":295,"address":[804032],"length":1,"stats":{"Line":1}},{"line":297,"address":[804864,805163],"length":1,"stats":{"Line":1}},{"line":298,"address":[804883],"length":1,"stats":{"Line":1}},{"line":299,"address":[805084,804919],"length":1,"stats":{"Line":1}},{"line":300,"address":[805183,804959],"length":1,"stats":{"Line":0}},{"line":301,"address":[805269,804999],"length":1,"stats":{"Line":0}},{"line":302,"address":[805039,805361],"length":1,"stats":{"Line":0}},{"line":306,"address":[805755,805456],"length":1,"stats":{"Line":1}},{"line":307,"address":[805475],"length":1,"stats":{"Line":1}},{"line":308,"address":[805511,805676],"length":1,"stats":{"Line":1}},{"line":309,"address":[805551,805775],"length":1,"stats":{"Line":0}},{"line":310,"address":[805861,805591],"length":1,"stats":{"Line":0}},{"line":311,"address":[805953,805631],"length":1,"stats":{"Line":0}},{"line":315,"address":[806048],"length":1,"stats":{"Line":1}},{"line":317,"address":[806053],"length":1,"stats":{"Line":1}},{"line":318,"address":[806084],"length":1,"stats":{"Line":0}},{"line":319,"address":[806107],"length":1,"stats":{"Line":0}},{"line":320,"address":[806130],"length":1,"stats":{"Line":0}},{"line":321,"address":[806153],"length":1,"stats":{"Line":1}},{"line":325,"address":[806192,808003,808254],"length":1,"stats":{"Line":1}},{"line":326,"address":[806263],"length":1,"stats":{"Line":1}},{"line":327,"address":[806331],"length":1,"stats":{"Line":1}},{"line":328,"address":[806367],"length":1,"stats":{"Line":0}},{"line":329,"address":[806305],"length":1,"stats":{"Line":0}},{"line":332,"address":[806401],"length":1,"stats":{"Line":1}},{"line":333,"address":[806422,806481],"length":1,"stats":{"Line":2}},{"line":337,"address":[806519],"length":1,"stats":{"Line":1}},{"line":339,"address":[806544,806588],"length":1,"stats":{"Line":2}},{"line":340,"address":[806781,806657],"length":1,"stats":{"Line":2}},{"line":341,"address":[806831,806904],"length":1,"stats":{"Line":1}},{"line":342,"address":[806940,806870],"length":1,"stats":{"Line":2}},{"line":343,"address":[808009,806976],"length":1,"stats":{"Line":0}},{"line":346,"address":[806945,807014],"length":1,"stats":{"Line":2}},{"line":347,"address":[807108,807069],"length":1,"stats":{"Line":2}},{"line":353,"address":[807170],"length":1,"stats":{"Line":1}},{"line":355,"address":[807217],"length":1,"stats":{"Line":2}},{"line":356,"address":[1055687],"length":1,"stats":{"Line":1}},{"line":357,"address":[1055755],"length":1,"stats":{"Line":1}},{"line":358,"address":[1055783],"length":1,"stats":{"Line":0}},{"line":359,"address":[1055811],"length":1,"stats":{"Line":0}},{"line":360,"address":[1055835],"length":1,"stats":{"Line":0}},{"line":361,"address":[1055863],"length":1,"stats":{"Line":0}},{"line":363,"address":[1055884],"length":1,"stats":{"Line":1}},{"line":365,"address":[807240],"length":1,"stats":{"Line":3}},{"line":368,"address":[807353,807270],"length":1,"stats":{"Line":2}},{"line":369,"address":[807458,807963,807524],"length":1,"stats":{"Line":3}},{"line":371,"address":[807842,807584],"length":1,"stats":{"Line":2}},{"line":372,"address":[807700],"length":1,"stats":{"Line":1}},{"line":373,"address":[807751],"length":1,"stats":{"Line":0}},{"line":374,"address":[807802],"length":1,"stats":{"Line":0}},{"line":379,"address":[807884],"length":1,"stats":{"Line":1}},{"line":380,"address":[807937],"length":1,"stats":{"Line":1}},{"line":381,"address":[807939],"length":1,"stats":{"Line":1}},{"line":384,"address":[807666,807968],"length":1,"stats":{"Line":2}},{"line":388,"address":[808221],"length":1,"stats":{"Line":1}},{"line":390,"address":[808856,808272],"length":1,"stats":{"Line":1}},{"line":391,"address":[808294],"length":1,"stats":{"Line":1}},{"line":392,"address":[808556,808330],"length":1,"stats":{"Line":2}},{"line":393,"address":[808389,808663],"length":1,"stats":{"Line":0}},{"line":394,"address":[808443,808720],"length":1,"stats":{"Line":0}},{"line":395,"address":[808477,808784],"length":1,"stats":{"Line":0}},{"line":397,"address":[808624],"length":1,"stats":{"Line":1}},{"line":402,"address":[808880],"length":1,"stats":{"Line":5}},{"line":403,"address":[808897],"length":1,"stats":{"Line":2}},{"line":408,"address":[808944],"length":1,"stats":{"Line":1}},{"line":409,"address":[808961],"length":1,"stats":{"Line":1}},{"line":414,"address":[809008],"length":1,"stats":{"Line":0}},{"line":415,"address":[809025],"length":1,"stats":{"Line":0}},{"line":420,"address":[809072],"length":1,"stats":{"Line":1}},{"line":421,"address":[809089],"length":1,"stats":{"Line":1}}],"covered":136,"coverable":239},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","project_management","builder.rs"],"content":"use crate::domain::{\n    project_management::{project::Project, state::Planned, vacation_rules::VacationRules},\n    shared::errors::{DomainError, DomainErrorKind},\n    task_management::any_task::AnyTask,\n};\nuse std::collections::HashMap;\nuse uuid7::{Uuid, uuid7};\n\n// Type states for the builder pattern\npub struct New;\npub struct WithName;\npub struct WithCode;\npub struct WithDates;\npub struct Ready;\n\n/// Builder for the `Project` struct using the typestate pattern.\n///\n/// This builder provides a more ergonomic and type-safe way to construct a `Project` instance,\n/// ensuring all required fields are provided before a project can be built.\n#[derive(Debug)]\npub struct ProjectBuilder\u003cState\u003e {\n    id: Uuid,\n    code: Option\u003cString\u003e,\n    name: Option\u003cString\u003e,\n    description: Option\u003cString\u003e,\n    start_date: Option\u003cString\u003e,\n    end_date: Option\u003cString\u003e,\n    vacation_rules: Option\u003cVacationRules\u003e,\n    timezone: Option\u003cString\u003e,\n    tasks: HashMap\u003cString, AnyTask\u003e,\n    _state: std::marker::PhantomData\u003cState\u003e,\n}\n\nimpl ProjectBuilder\u003cNew\u003e {\n    /// Creates a new `ProjectBuilder` with a required name.\n    pub fn new(name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            id: uuid7(),\n            name: Some(name.into()),\n            code: None,\n            description: None,\n            start_date: None,\n            end_date: None,\n            vacation_rules: None,\n            timezone: None,\n            tasks: HashMap::new(),\n            _state: std::marker::PhantomData,\n        }\n    }\n}\n\nimpl ProjectBuilder\u003cWithName\u003e {\n    /// Sets the code for the project.\n    pub fn code(self, code: impl Into\u003cString\u003e) -\u003e ProjectBuilder\u003cWithCode\u003e {\n        ProjectBuilder {\n            id: self.id,\n            code: Some(code.into()),\n            name: self.name,\n            description: self.description,\n            start_date: self.start_date,\n            end_date: self.end_date,\n            vacation_rules: self.vacation_rules,\n            timezone: self.timezone,\n            tasks: self.tasks,\n            _state: std::marker::PhantomData,\n        }\n    }\n}\n\nimpl ProjectBuilder\u003cWithCode\u003e {\n    /// Sets the description for the project.\n    pub fn description(mut self, description: impl Into\u003cString\u003e) -\u003e Self {\n        self.description = Some(description.into());\n        self\n    }\n\n    /// Sets the start date for the project.\n    pub fn start_date(mut self, start_date: impl Into\u003cString\u003e) -\u003e Self {\n        self.start_date = Some(start_date.into());\n        self\n    }\n\n    /// Sets the end date for the project.\n    pub fn end_date(self, end_date: impl Into\u003cString\u003e) -\u003e ProjectBuilder\u003cWithDates\u003e {\n        ProjectBuilder {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            start_date: self.start_date,\n            end_date: Some(end_date.into()),\n            vacation_rules: self.vacation_rules,\n            timezone: self.timezone,\n            tasks: self.tasks,\n            _state: std::marker::PhantomData,\n        }\n    }\n}\n\nimpl ProjectBuilder\u003cWithDates\u003e {\n    /// Sets the vacation rules for the project.\n    pub fn vacation_rules(mut self, vacation_rules: VacationRules) -\u003e Self {\n        self.vacation_rules = Some(vacation_rules);\n        self\n    }\n\n    /// Sets the timezone for the project.\n    pub fn timezone(mut self, timezone: impl Into\u003cString\u003e) -\u003e Self {\n        self.timezone = Some(timezone.into());\n        self\n    }\n\n    /// Adds a task to the project.\n    pub fn add_task(mut self, task: AnyTask) -\u003e Self {\n        self.tasks.insert(task.code().to_string(), task);\n        self\n    }\n\n    /// Validates the project configuration and builds the `Project` instance.\n    pub fn build(self) -\u003e Result\u003cProject\u003cPlanned\u003e, DomainError\u003e {\n        // Validate required fields\n        let code = self.code.ok_or_else(|| {\n            DomainError::new(DomainErrorKind::ValidationError {\n                field: \"code\".to_string(),\n                message: \"Project code is required\".to_string(),\n            })\n        })?;\n\n        let name = self.name.ok_or_else(|| {\n            DomainError::new(DomainErrorKind::ValidationError {\n                field: \"name\".to_string(),\n                message: \"Project name is required\".to_string(),\n            })\n        })?;\n\n        // Validate dates if both are provided\n        if let (Some(start), Some(end)) = (\u0026self.start_date, \u0026self.end_date)\n            \u0026\u0026 start \u003e end\n        {\n            return Err(DomainError::new(DomainErrorKind::ProjectInvalidState {\n                current: \"invalid_dates\".to_string(),\n                expected: \"start_date \u003c end_date\".to_string(),\n            })\n            .with_context(\"Start date must be before end date\"));\n        }\n\n        Ok(Project {\n            id: self.id,\n            code,\n            name,\n            description: self.description,\n            start_date: self.start_date,\n            end_date: self.end_date,\n            vacation_rules: self.vacation_rules,\n            timezone: self.timezone,\n            tasks: self.tasks,\n            state: Planned,\n        })\n    }\n}\n\n// Convenience methods for backward compatibility and simpler use cases\nimpl ProjectBuilder\u003cNew\u003e {\n    /// Legacy method for backward compatibility.\n    /// Prefer using the typestate pattern: new() -\u003e code() -\u003e end_date() -\u003e build()\n    pub fn code(mut self, code: String) -\u003e Self {\n        self.code = Some(code);\n        self\n    }\n\n    /// Legacy method for backward compatibility.\n    pub fn description(mut self, description: Option\u003cString\u003e) -\u003e Self {\n        self.description = description;\n        self\n    }\n\n    /// Legacy method for backward compatibility.\n    pub fn start_date(mut self, start_date: String) -\u003e Self {\n        self.start_date = Some(start_date);\n        self\n    }\n\n    /// Legacy method for backward compatibility.\n    pub fn end_date(mut self, end_date: String) -\u003e Self {\n        self.end_date = Some(end_date);\n        self\n    }\n\n    /// Legacy method for backward compatibility.\n    pub fn vacation_rules(mut self, vacation_rules: VacationRules) -\u003e Self {\n        self.vacation_rules = Some(vacation_rules);\n        self\n    }\n\n    /// Legacy method for backward compatibility.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the name is not set, which should not happen if `new()` is used.\n    pub fn build(self) -\u003e Project\u003cPlanned\u003e {\n        // For legacy compatibility, we'll create a simple project without validation\n        Project {\n            id: self.id,\n            code: self.code.expect(\"Project code must be set\"),\n            name: self.name.expect(\"Project name must be set\"),\n            description: self.description,\n            start_date: self.start_date,\n            end_date: self.end_date,\n            vacation_rules: self.vacation_rules,\n            timezone: self.timezone,\n            tasks: self.tasks,\n            state: Planned,\n        }\n    }\n}\n","traces":[{"line":36,"address":[2020485,2019760,2020369],"length":1,"stats":{"Line":5}},{"line":38,"address":[2019782],"length":1,"stats":{"Line":5}},{"line":39,"address":[2019860],"length":1,"stats":{"Line":5}},{"line":46,"address":[2020009],"length":1,"stats":{"Line":5}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[251664,251852],"length":1,"stats":{"Line":0}},{"line":103,"address":[251691,251800],"length":1,"stats":{"Line":0}},{"line":104,"address":[251832],"length":1,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[251872,252161],"length":1,"stats":{"Line":0}},{"line":115,"address":[252003,251907],"length":1,"stats":{"Line":0}},{"line":116,"address":[252114],"length":1,"stats":{"Line":0}},{"line":120,"address":[254248,252192,254674],"length":1,"stats":{"Line":0}},{"line":122,"address":[2020741,2020528,2020735],"length":1,"stats":{"Line":0}},{"line":123,"address":[2020643],"length":1,"stats":{"Line":0}},{"line":124,"address":[2020544],"length":1,"stats":{"Line":0}},{"line":125,"address":[2020580],"length":1,"stats":{"Line":0}},{"line":129,"address":[2020975,2020768,2020981],"length":1,"stats":{"Line":0}},{"line":130,"address":[2020883],"length":1,"stats":{"Line":0}},{"line":131,"address":[2020784],"length":1,"stats":{"Line":0}},{"line":132,"address":[2020820],"length":1,"stats":{"Line":0}},{"line":137,"address":[253759,252907],"length":1,"stats":{"Line":0}},{"line":138,"address":[253791,253874],"length":1,"stats":{"Line":0}},{"line":140,"address":[254128,253989],"length":1,"stats":{"Line":0}},{"line":141,"address":[253883],"length":1,"stats":{"Line":0}},{"line":142,"address":[253914],"length":1,"stats":{"Line":0}},{"line":144,"address":[254088],"length":1,"stats":{"Line":0}},{"line":147,"address":[253345],"length":1,"stats":{"Line":0}},{"line":148,"address":[253023],"length":1,"stats":{"Line":0}},{"line":149,"address":[253053],"length":1,"stats":{"Line":0}},{"line":150,"address":[253092],"length":1,"stats":{"Line":0}},{"line":151,"address":[253140],"length":1,"stats":{"Line":0}},{"line":152,"address":[253176],"length":1,"stats":{"Line":0}},{"line":153,"address":[253212],"length":1,"stats":{"Line":0}},{"line":154,"address":[253248],"length":1,"stats":{"Line":0}},{"line":155,"address":[253278],"length":1,"stats":{"Line":0}},{"line":156,"address":[253320],"length":1,"stats":{"Line":0}},{"line":166,"address":[254832,254988],"length":1,"stats":{"Line":5}},{"line":167,"address":[254859,254942],"length":1,"stats":{"Line":10}},{"line":168,"address":[254968],"length":1,"stats":{"Line":5}},{"line":172,"address":[255161,255008],"length":1,"stats":{"Line":2}},{"line":173,"address":[255040,255118],"length":1,"stats":{"Line":3}},{"line":174,"address":[255141],"length":1,"stats":{"Line":1}},{"line":178,"address":[255184,255346],"length":1,"stats":{"Line":0}},{"line":179,"address":[255299,255211],"length":1,"stats":{"Line":0}},{"line":180,"address":[255326],"length":1,"stats":{"Line":0}},{"line":184,"address":[255538,255376],"length":1,"stats":{"Line":3}},{"line":185,"address":[255491,255403],"length":1,"stats":{"Line":6}},{"line":186,"address":[255518],"length":1,"stats":{"Line":3}},{"line":190,"address":[255756,255568],"length":1,"stats":{"Line":1}},{"line":191,"address":[255704,255595],"length":1,"stats":{"Line":2}},{"line":192,"address":[255736],"length":1,"stats":{"Line":1}},{"line":200,"address":[255776,256555,256699],"length":1,"stats":{"Line":2}},{"line":203,"address":[255798],"length":1,"stats":{"Line":2}},{"line":204,"address":[255826],"length":1,"stats":{"Line":2}},{"line":205,"address":[255929],"length":1,"stats":{"Line":2}},{"line":206,"address":[256050],"length":1,"stats":{"Line":2}},{"line":207,"address":[256086],"length":1,"stats":{"Line":2}},{"line":208,"address":[256122],"length":1,"stats":{"Line":1}},{"line":209,"address":[256158],"length":1,"stats":{"Line":4}},{"line":210,"address":[256188],"length":1,"stats":{"Line":1}},{"line":211,"address":[256230],"length":1,"stats":{"Line":4}}],"covered":26,"coverable":89},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","project_management","errors.rs"],"content":"use crate::domain::shared::errors::{DomainError, DomainErrorKind};\nuse std::error::Error as StdError;\nuse std::fmt;\n\n/// Project-specific error types\n#[derive(Debug)]\npub enum ProjectError {\n    NotFound { code: String },\n    AlreadyExists { code: String },\n    InvalidState { current: String, expected: String },\n    ValidationFailed { details: Vec\u003cString\u003e },\n    ModificationNotAllowed { state: String },\n    InvalidDates { reason: String },\n    InvalidCode { code: String, reason: String },\n}\n\nimpl fmt::Display for ProjectError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            ProjectError::NotFound { code } =\u003e {\n                write!(f, \"Project with code '{}' not found\", code)\n            }\n            ProjectError::AlreadyExists { code } =\u003e {\n                write!(f, \"Project with code '{}' already exists\", code)\n            }\n            ProjectError::InvalidState { current, expected } =\u003e {\n                write!(f, \"Project is in invalid state '{}', expected '{}'\", current, expected)\n            }\n            ProjectError::ValidationFailed { details } =\u003e {\n                write!(f, \"Project validation failed: {}\", details.join(\", \"))\n            }\n            ProjectError::ModificationNotAllowed { state } =\u003e {\n                write!(f, \"Cannot modify project in state '{}'\", state)\n            }\n            ProjectError::InvalidDates { reason } =\u003e {\n                write!(f, \"Project dates are invalid: {}\", reason)\n            }\n            ProjectError::InvalidCode { code, reason } =\u003e {\n                write!(f, \"Project code '{}' is invalid: {}\", code, reason)\n            }\n        }\n    }\n}\n\nimpl StdError for ProjectError {}\n\nimpl From\u003cProjectError\u003e for DomainError {\n    fn from(err: ProjectError) -\u003e Self {\n        match err {\n            ProjectError::NotFound { code } =\u003e DomainError::new(DomainErrorKind::ProjectNotFound { code }),\n            ProjectError::AlreadyExists { code } =\u003e DomainError::new(DomainErrorKind::ProjectAlreadyExists { code }),\n            ProjectError::InvalidState { current, expected } =\u003e {\n                DomainError::new(DomainErrorKind::ProjectInvalidState { current, expected })\n            }\n            ProjectError::ValidationFailed { details } =\u003e {\n                DomainError::new(DomainErrorKind::ProjectValidationFailed { details })\n            }\n            ProjectError::ModificationNotAllowed { state } =\u003e DomainError::new(DomainErrorKind::ProjectInvalidState {\n                current: state,\n                expected: \"modifiable state\".to_string(),\n            }),\n            ProjectError::InvalidDates { reason } =\u003e DomainError::new(DomainErrorKind::ValidationError {\n                field: \"dates\".to_string(),\n                message: reason,\n            }),\n            ProjectError::InvalidCode { code, reason } =\u003e DomainError::new(DomainErrorKind::ValidationError {\n                field: \"code\".to_string(),\n                message: format!(\"Code '{}' is invalid: {}\", code, reason),\n            }),\n        }\n    }\n}\n\n// Result type for project operations\npub type ProjectResult\u003cT\u003e = Result\u003cT, ProjectError\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_project_error_not_found_display() {\n        let error = ProjectError::NotFound { code: \"PROJ-001\".to_string() };\n        let expected = \"Project with code 'PROJ-001' not found\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_project_error_already_exists_display() {\n        let error = ProjectError::AlreadyExists { code: \"PROJ-002\".to_string() };\n        let expected = \"Project with code 'PROJ-002' already exists\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_project_error_invalid_state_display() {\n        let error = ProjectError::InvalidState { \n            current: \"Completed\".to_string(), \n            expected: \"In Progress\".to_string() \n        };\n        let expected = \"Project is in invalid state 'Completed', expected 'In Progress'\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_project_error_validation_failed_display() {\n        let error = ProjectError::ValidationFailed { \n            details: vec![\"Name is required\".to_string(), \"Code is invalid\".to_string()] \n        };\n        let expected = \"Project validation failed: Name is required, Code is invalid\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_project_error_modification_not_allowed_display() {\n        let error = ProjectError::ModificationNotAllowed { state: \"Completed\".to_string() };\n        let expected = \"Cannot modify project in state 'Completed'\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_project_error_invalid_dates_display() {\n        let error = ProjectError::InvalidDates { reason: \"End date before start date\".to_string() };\n        let expected = \"Project dates are invalid: End date before start date\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_project_error_invalid_code_display() {\n        let error = ProjectError::InvalidCode { \n            code: \"INVALID\".to_string(), \n            reason: \"Contains invalid characters\".to_string() \n        };\n        let expected = \"Project code 'INVALID' is invalid: Contains invalid characters\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_project_error_debug_formatting() {\n        let error = ProjectError::NotFound { code: \"PROJ-001\".to_string() };\n        let debug_str = format!(\"{:?}\", error);\n        assert!(debug_str.contains(\"NotFound\"));\n        assert!(debug_str.contains(\"PROJ-001\"));\n    }\n\n    #[test]\n    fn test_from_project_error_to_domain_error_not_found() {\n        let project_error = ProjectError::NotFound { code: \"PROJ-001\".to_string() };\n        let domain_error: DomainError = project_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ProjectNotFound { code } =\u003e {\n                assert_eq!(code, \"PROJ-001\");\n            }\n            _ =\u003e panic!(\"Expected ProjectNotFound error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_project_error_to_domain_error_already_exists() {\n        let project_error = ProjectError::AlreadyExists { code: \"PROJ-002\".to_string() };\n        let domain_error: DomainError = project_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ProjectAlreadyExists { code } =\u003e {\n                assert_eq!(code, \"PROJ-002\");\n            }\n            _ =\u003e panic!(\"Expected ProjectAlreadyExists error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_project_error_to_domain_error_invalid_state() {\n        let project_error = ProjectError::InvalidState { \n            current: \"Completed\".to_string(), \n            expected: \"In Progress\".to_string() \n        };\n        let domain_error: DomainError = project_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ProjectInvalidState { current, expected } =\u003e {\n                assert_eq!(current, \"Completed\");\n                assert_eq!(expected, \"In Progress\");\n            }\n            _ =\u003e panic!(\"Expected ProjectInvalidState error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_project_error_to_domain_error_validation_failed() {\n        let project_error = ProjectError::ValidationFailed { \n            details: vec![\"Name is required\".to_string(), \"Code is invalid\".to_string()] \n        };\n        let domain_error: DomainError = project_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ProjectValidationFailed { details } =\u003e {\n                assert_eq!(details.len(), 2);\n                assert!(details.contains(\u0026\"Name is required\".to_string()));\n                assert!(details.contains(\u0026\"Code is invalid\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected ProjectValidationFailed error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_project_error_to_domain_error_modification_not_allowed() {\n        let project_error = ProjectError::ModificationNotAllowed { state: \"Completed\".to_string() };\n        let domain_error: DomainError = project_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ProjectInvalidState { current, expected } =\u003e {\n                assert_eq!(current, \"Completed\");\n                assert_eq!(expected, \"modifiable state\");\n            }\n            _ =\u003e panic!(\"Expected ProjectInvalidState error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_project_error_to_domain_error_invalid_dates() {\n        let project_error = ProjectError::InvalidDates { \n            reason: \"End date before start date\".to_string() \n        };\n        let domain_error: DomainError = project_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ValidationError { field, message } =\u003e {\n                assert_eq!(field, \"dates\");\n                assert_eq!(message, \"End date before start date\");\n            }\n            _ =\u003e panic!(\"Expected ValidationError error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_project_error_to_domain_error_invalid_code() {\n        let project_error = ProjectError::InvalidCode { \n            code: \"INVALID\".to_string(), \n            reason: \"Contains invalid characters\".to_string() \n        };\n        let domain_error: DomainError = project_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ValidationError { field, message } =\u003e {\n                assert_eq!(field, \"code\");\n                assert_eq!(message, \"Code 'INVALID' is invalid: Contains invalid characters\");\n            }\n            _ =\u003e panic!(\"Expected ValidationError error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_project_result_success() {\n        let result: ProjectResult\u003cString\u003e = Ok(\"Success\".to_string());\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"Success\");\n    }\n\n    #[test]\n    fn test_project_result_failure() {\n        let result: ProjectResult\u003cString\u003e = Err(ProjectError::NotFound { code: \"PROJ-001\".to_string() });\n        assert!(result.is_err());\n        \n        match result {\n            Err(ProjectError::NotFound { code }) =\u003e {\n                assert_eq!(code, \"PROJ-001\");\n            }\n            _ =\u003e panic!(\"Expected NotFound error\"),\n        }\n    }\n\n    #[test]\n    fn test_all_error_variants_covered() {\n        // Test that all ProjectError variants can be created and converted\n        let errors = vec![\n            ProjectError::NotFound { code: \"TEST\".to_string() },\n            ProjectError::AlreadyExists { code: \"TEST\".to_string() },\n            ProjectError::InvalidState { \n                current: \"TEST\".to_string(), \n                expected: \"TEST\".to_string() \n            },\n            ProjectError::ValidationFailed { \n                details: vec![\"TEST\".to_string()] \n            },\n            ProjectError::ModificationNotAllowed { state: \"TEST\".to_string() },\n            ProjectError::InvalidDates { reason: \"TEST\".to_string() },\n            ProjectError::InvalidCode { \n                code: \"TEST\".to_string(), \n                reason: \"TEST\".to_string() \n            },\n        ];\n\n        for error in errors {\n            let domain_error: DomainError = error.into();\n            assert!(domain_error.to_string().len() \u003e 0);\n        }\n    }\n}\n","traces":[{"line":18,"address":[2806864,2808124,2808130],"length":1,"stats":{"Line":1}},{"line":19,"address":[2806897],"length":1,"stats":{"Line":2}},{"line":20,"address":[2806933],"length":1,"stats":{"Line":1}},{"line":21,"address":[2806942],"length":1,"stats":{"Line":1}},{"line":23,"address":[2807035],"length":1,"stats":{"Line":1}},{"line":24,"address":[2807047],"length":1,"stats":{"Line":1}},{"line":26,"address":[2807164],"length":1,"stats":{"Line":1}},{"line":27,"address":[2807191],"length":1,"stats":{"Line":1}},{"line":29,"address":[2807394],"length":1,"stats":{"Line":1}},{"line":30,"address":[2807406,2807977],"length":1,"stats":{"Line":1}},{"line":32,"address":[2807485],"length":1,"stats":{"Line":1}},{"line":33,"address":[2807497],"length":1,"stats":{"Line":1}},{"line":35,"address":[2807614],"length":1,"stats":{"Line":1}},{"line":36,"address":[2807626],"length":1,"stats":{"Line":1}},{"line":38,"address":[2807743],"length":1,"stats":{"Line":1}},{"line":39,"address":[2807770],"length":1,"stats":{"Line":1}},{"line":48,"address":[3062195,3061152],"length":1,"stats":{"Line":1}},{"line":49,"address":[3061174],"length":1,"stats":{"Line":2}},{"line":50,"address":[3061223],"length":1,"stats":{"Line":1}},{"line":51,"address":[3061314],"length":1,"stats":{"Line":1}},{"line":52,"address":[3061432],"length":1,"stats":{"Line":1}},{"line":53,"address":[3061504],"length":1,"stats":{"Line":2}},{"line":55,"address":[3061640],"length":1,"stats":{"Line":1}},{"line":56,"address":[3061676],"length":1,"stats":{"Line":1}},{"line":58,"address":[3062069,3061759],"length":1,"stats":{"Line":2}},{"line":59,"address":[3061783],"length":1,"stats":{"Line":1}},{"line":60,"address":[3061815],"length":1,"stats":{"Line":1}},{"line":62,"address":[3061854,3062297],"length":1,"stats":{"Line":2}},{"line":63,"address":[3061886],"length":1,"stats":{"Line":1}},{"line":64,"address":[3062257],"length":1,"stats":{"Line":1}},{"line":66,"address":[3061925,3062715],"length":1,"stats":{"Line":2}},{"line":67,"address":[3061973],"length":1,"stats":{"Line":1}},{"line":68,"address":[3062475,3062567],"length":1,"stats":{"Line":2}}],"covered":33,"coverable":33},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","project_management","layoff_period.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::fmt::{Debug, Display};\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]\npub struct LayoffPeriod {\n    pub start_date: String,\n    pub end_date: String,\n}\n\nimpl Display for LayoffPeriod {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"LayoffPeriod {{ start_date: {}, end_date: {} }}\",\n            self.start_date, self.end_date\n        )\n    }\n}\n","traces":[{"line":11,"address":[2030448],"length":1,"stats":{"Line":0}},{"line":12,"address":[2030478],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","project_management","mod.rs"],"content":"pub mod any_project;\npub mod builder;\npub mod errors;\npub mod layoff_period;\npub mod project;\npub mod repository;\npub mod state;\npub mod vacation_rules;\n\npub use any_project::AnyProject;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","project_management","project.rs"],"content":"use super::super::task_management::any_task::AnyTask;\nuse super::state::{Cancelled, Completed, InProgress, Planned, ProjectState};\nuse crate::domain::project_management::vacation_rules::VacationRules;\nuse serde::Serialize;\nuse std::collections::HashMap;\nuse std::fmt::{Debug, Display};\nuse uuid7::Uuid;\n\n#[derive(Debug, Clone, PartialEq, Serialize)]\npub struct Project\u003cS: ProjectState\u003e {\n    pub id: Uuid,\n    pub code: String,\n    pub name: String,\n    pub description: Option\u003cString\u003e,\n    pub start_date: Option\u003cString\u003e,\n    pub end_date: Option\u003cString\u003e,\n    pub vacation_rules: Option\u003cVacationRules\u003e,\n    pub timezone: Option\u003cString\u003e,\n    pub tasks: HashMap\u003cString, AnyTask\u003e,\n    pub state: S,\n}\n\nimpl\u003cS: ProjectState\u003e Display for Project\u003cS\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Project {{ id: {:?}, code: {}, name: {}, status: {:?} }}\",\n            self.id, self.code, self.name, self.state\n        )\n    }\n}\n\nimpl Project\u003cPlanned\u003e {\n    #[allow(dead_code)]\n    pub fn start(self) -\u003e Project\u003cInProgress\u003e {\n        Project {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            start_date: self.start_date,\n            end_date: self.end_date,\n            vacation_rules: self.vacation_rules,\n            timezone: self.timezone,\n            tasks: self.tasks,\n            state: InProgress,\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn cancel(self) -\u003e Project\u003cCancelled\u003e {\n        Project {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            start_date: self.start_date,\n            end_date: self.end_date,\n            vacation_rules: self.vacation_rules,\n            timezone: self.timezone,\n            tasks: self.tasks,\n            state: Cancelled,\n        }\n    }\n}\n\nimpl Project\u003cInProgress\u003e {\n    #[allow(dead_code)]\n    pub fn complete(self) -\u003e Project\u003cCompleted\u003e {\n        Project {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            start_date: self.start_date,\n            end_date: self.end_date,\n            vacation_rules: self.vacation_rules,\n            timezone: self.timezone,\n            tasks: self.tasks,\n            state: Completed,\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn cancel(self) -\u003e Project\u003cCancelled\u003e {\n        Project {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            start_date: self.start_date,\n            end_date: self.end_date,\n            vacation_rules: self.vacation_rules,\n            timezone: self.timezone,\n            tasks: self.tasks,\n            state: Cancelled,\n        }\n    }\n}\n\n// Common methods for all Project states\nimpl\u003cS: ProjectState\u003e Project\u003cS\u003e {\n    // Getters\n    pub fn code(\u0026self) -\u003e \u0026str {\n        \u0026self.code\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    pub fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.description.as_deref()\n    }\n\n    pub fn start_date(\u0026self) -\u003e \u0026str {\n        self.start_date.as_deref().unwrap_or(\"\")\n    }\n\n    pub fn end_date(\u0026self) -\u003e \u0026str {\n        self.end_date.as_deref().unwrap_or(\"\")\n    }\n\n    // --- Zero-copy accessors ---\n\n    pub fn tasks_iter(\u0026self) -\u003e impl Iterator\u003cItem = (\u0026String, \u0026AnyTask)\u003e {\n        self.tasks.iter()\n    }\n\n    pub fn task_codes(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.tasks.keys()\n    }\n\n    pub fn tasks(\u0026self) -\u003e \u0026HashMap\u003cString, AnyTask\u003e {\n        \u0026self.tasks\n    }\n\n    pub fn vacation_rules(\u0026self) -\u003e Option\u003c\u0026VacationRules\u003e {\n        self.vacation_rules.as_ref()\n    }\n\n    pub fn timezone(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.timezone.as_deref()\n    }\n\n    // Validation methods\n    pub fn is_code_valid(\u0026self) -\u003e bool {\n        !self.code.trim().is_empty()\n    }\n\n    pub fn is_name_valid(\u0026self) -\u003e bool {\n        !self.name.trim().is_empty()\n    }\n\n    pub fn is_date_range_valid(\u0026self) -\u003e bool {\n        if let (Some(start), Some(end)) = (\u0026self.start_date, \u0026self.end_date)\n            \u0026\u0026 let (Ok(start_date), Ok(end_date)) = (\n                chrono::NaiveDate::parse_from_str(start, \"%Y-%m-%d\"),\n                chrono::NaiveDate::parse_from_str(end, \"%Y-%m-%d\"),\n            )\n        {\n            return start_date \u003c= end_date;\n        }\n        false\n    }\n\n    pub fn validate(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n        let mut errors = Vec::new();\n\n        if !self.is_code_valid() {\n            errors.push(\"Project code cannot be empty\".to_string());\n        }\n\n        if !self.is_name_valid() {\n            errors.push(\"Project name cannot be empty\".to_string());\n        }\n\n        if !self.is_date_range_valid() {\n            errors.push(\"Project end date must be after start date\".to_string());\n        }\n\n        Ok(errors)\n    }\n}\n\n// Transition trait for state changes\npub trait Transition {\n    type NextState: ProjectState;\n    fn transition(self) -\u003e Project\u003cSelf::NextState\u003e;\n}\n\nimpl Transition for Project\u003cPlanned\u003e {\n    type NextState = InProgress;\n\n    fn transition(self) -\u003e Project\u003cInProgress\u003e {\n        Project {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            start_date: self.start_date,\n            end_date: self.end_date,\n            vacation_rules: self.vacation_rules,\n            timezone: self.timezone,\n            tasks: self.tasks,\n            state: InProgress,\n        }\n    }\n}\n\nimpl Transition for Project\u003cInProgress\u003e {\n    type NextState = Completed;\n\n    fn transition(self) -\u003e Project\u003cCompleted\u003e {\n        Project {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            start_date: self.start_date,\n            end_date: self.end_date,\n            vacation_rules: self.vacation_rules,\n            timezone: self.timezone,\n            tasks: self.tasks,\n            state: Completed,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_project_creation_with_valid_data() {\n        let project = Project::\u003cPlanned\u003e {\n            id: uuid7::uuid7(),\n            code: \"PROJ-001\".to_string(),\n            name: \"Test Project\".to_string(),\n            description: Some(\"A test project\".to_string()),\n            start_date: Some(\"2024-01-01\".to_string()),\n            end_date: Some(\"2024-12-31\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: Planned,\n        };\n\n        assert_eq!(project.code(), \"PROJ-001\");\n        assert_eq!(project.name(), \"Test Project\");\n        assert_eq!(project.description(), Some(\"A test project\"));\n        assert_eq!(project.start_date(), \"2024-01-01\");\n        assert_eq!(project.end_date(), \"2024-12-31\");\n    }\n\n    #[test]\n    fn test_project_state_transitions() {\n        let project = Project::\u003cPlanned\u003e {\n            id: uuid7::uuid7(),\n            code: \"PROJ-001\".to_string(),\n            name: \"Test Project\".to_string(),\n            description: None,\n            start_date: Some(\"2024-01-01\".to_string()),\n            end_date: Some(\"2024-12-31\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: Planned,\n        };\n\n        // Transition from Planned to InProgress\n        let in_progress_project: Project\u003cInProgress\u003e = project.transition();\n        assert!(matches!(in_progress_project.state, InProgress));\n\n        // Transition from InProgress to Completed\n        let in_progress_project = Project::\u003cInProgress\u003e {\n            id: uuid7::uuid7(),\n            code: \"PROJ-001\".to_string(),\n            name: \"Test Project\".to_string(),\n            description: None,\n            start_date: Some(\"2024-01-01\".to_string()),\n            end_date: Some(\"2024-12-31\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: InProgress,\n        };\n\n        let completed_project: Project\u003cCompleted\u003e = in_progress_project.transition();\n        assert!(matches!(completed_project.state, Completed));\n    }\n\n    #[test]\n    fn test_project_validation_dates() {\n        // Valid date range\n        let valid_project = Project::\u003cPlanned\u003e {\n            id: uuid7::uuid7(),\n            code: \"PROJ-001\".to_string(),\n            name: \"Test Project\".to_string(),\n            description: None,\n            start_date: Some(\"2024-01-01\".to_string()),\n            end_date: Some(\"2024-12-31\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: Planned,\n        };\n\n        assert!(valid_project.is_date_range_valid());\n\n        // Invalid date range (end before start)\n        let invalid_project = Project::\u003cPlanned\u003e {\n            id: uuid7::uuid7(),\n            code: \"PROJ-002\".to_string(),\n            name: \"Invalid Project\".to_string(),\n            description: None,\n            start_date: Some(\"2024-12-31\".to_string()),\n            end_date: Some(\"2024-01-01\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: Planned,\n        };\n\n        assert!(!invalid_project.is_date_range_valid());\n    }\n\n    #[test]\n    fn test_project_code_validation() {\n        // Valid code format\n        let valid_project = Project::\u003cPlanned\u003e {\n            id: uuid7::uuid7(),\n            code: \"PROJ-001\".to_string(),\n            name: \"Test Project\".to_string(),\n            description: None,\n            start_date: Some(\"2024-01-01\".to_string()),\n            end_date: Some(\"2024-12-31\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: Planned,\n        };\n\n        assert!(valid_project.is_code_valid());\n\n        // Invalid code (empty)\n        let invalid_project = Project::\u003cPlanned\u003e {\n            id: uuid7::uuid7(),\n            code: \"\".to_string(),\n            name: \"Test Project\".to_string(),\n            description: None,\n            start_date: Some(\"2024-01-01\".to_string()),\n            end_date: Some(\"2024-12-31\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: Planned,\n        };\n\n        assert!(!invalid_project.is_code_valid());\n    }\n\n    #[test]\n    fn test_project_name_validation() {\n        // Valid name\n        let valid_project = Project::\u003cPlanned\u003e {\n            id: uuid7::uuid7(),\n            code: \"PROJ-001\".to_string(),\n            name: \"Test Project\".to_string(),\n            description: None,\n            start_date: Some(\"2024-01-01\".to_string()),\n            end_date: Some(\"2024-12-31\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: Planned,\n        };\n\n        assert!(valid_project.is_name_valid());\n\n        // Invalid name (empty)\n        let invalid_project = Project::\u003cPlanned\u003e {\n            id: uuid7::uuid7(),\n            code: \"PROJ-001\".to_string(),\n            name: \"\".to_string(),\n            description: None,\n            start_date: Some(\"2024-01-01\".to_string()),\n            end_date: Some(\"2024-12-31\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: Planned,\n        };\n\n        assert!(!invalid_project.is_name_valid());\n    }\n\n    #[test]\n    fn test_project_comprehensive_validation() {\n        let valid_project = Project::\u003cPlanned\u003e {\n            id: uuid7::uuid7(),\n            code: \"PROJ-001\".to_string(),\n            name: \"Test Project\".to_string(),\n            description: Some(\"A comprehensive test project\".to_string()),\n            start_date: Some(\"2024-01-01\".to_string()),\n            end_date: Some(\"2024-12-31\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: Planned,\n        };\n\n        let validation_result = valid_project.validate();\n        assert!(validation_result.is_ok());\n        assert_eq!(validation_result.unwrap().len(), 0); // No validation errors\n\n        let invalid_project = Project::\u003cPlanned\u003e {\n            id: uuid7::uuid7(),\n            code: \"\".to_string(),\n            name: \"\".to_string(),\n            description: None,\n            start_date: Some(\"2024-12-31\".to_string()),\n            end_date: Some(\"2024-01-01\".to_string()),\n            vacation_rules: Some(VacationRules::default()),\n            timezone: Some(\"UTC\".to_string()),\n            tasks: HashMap::new(),\n            state: Planned,\n        };\n\n        let validation_result = invalid_project.validate();\n        assert!(validation_result.is_ok());\n        let errors = validation_result.unwrap();\n        assert!(!errors.is_empty()); // Should have validation errors\n        assert!(errors.iter().any(|e| e.contains(\"code\")));\n        assert!(errors.iter().any(|e| e.contains(\"name\")));\n        assert!(errors.iter().any(|e| e.contains(\"date\")));\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[1382864],"length":1,"stats":{"Line":1}},{"line":37,"address":[1382886],"length":1,"stats":{"Line":1}},{"line":38,"address":[1382910],"length":1,"stats":{"Line":1}},{"line":39,"address":[1382936],"length":1,"stats":{"Line":1}},{"line":40,"address":[1382963],"length":1,"stats":{"Line":1}},{"line":41,"address":[1382990],"length":1,"stats":{"Line":1}},{"line":42,"address":[1383023],"length":1,"stats":{"Line":1}},{"line":43,"address":[1383059],"length":1,"stats":{"Line":1}},{"line":44,"address":[1383089],"length":1,"stats":{"Line":1}},{"line":45,"address":[1383131],"length":1,"stats":{"Line":1}},{"line":51,"address":[1383456],"length":1,"stats":{"Line":1}},{"line":53,"address":[1383478],"length":1,"stats":{"Line":1}},{"line":54,"address":[1383502],"length":1,"stats":{"Line":1}},{"line":55,"address":[1383528],"length":1,"stats":{"Line":1}},{"line":56,"address":[1383555],"length":1,"stats":{"Line":1}},{"line":57,"address":[1383582],"length":1,"stats":{"Line":1}},{"line":58,"address":[1383615],"length":1,"stats":{"Line":1}},{"line":59,"address":[1383651],"length":1,"stats":{"Line":1}},{"line":60,"address":[1383681],"length":1,"stats":{"Line":1}},{"line":61,"address":[1383723],"length":1,"stats":{"Line":1}},{"line":69,"address":[1384048],"length":1,"stats":{"Line":0}},{"line":71,"address":[1384070],"length":1,"stats":{"Line":0}},{"line":72,"address":[1384094],"length":1,"stats":{"Line":0}},{"line":73,"address":[1384120],"length":1,"stats":{"Line":0}},{"line":74,"address":[1384147],"length":1,"stats":{"Line":0}},{"line":75,"address":[1384174],"length":1,"stats":{"Line":0}},{"line":76,"address":[1384207],"length":1,"stats":{"Line":0}},{"line":77,"address":[1384243],"length":1,"stats":{"Line":0}},{"line":78,"address":[1384273],"length":1,"stats":{"Line":0}},{"line":79,"address":[1384315],"length":1,"stats":{"Line":0}},{"line":85,"address":[1384640],"length":1,"stats":{"Line":0}},{"line":87,"address":[1384662],"length":1,"stats":{"Line":0}},{"line":88,"address":[1384686],"length":1,"stats":{"Line":0}},{"line":89,"address":[1384712],"length":1,"stats":{"Line":0}},{"line":90,"address":[1384739],"length":1,"stats":{"Line":0}},{"line":91,"address":[1384766],"length":1,"stats":{"Line":0}},{"line":92,"address":[1384799],"length":1,"stats":{"Line":0}},{"line":93,"address":[1384835],"length":1,"stats":{"Line":0}},{"line":94,"address":[1384865],"length":1,"stats":{"Line":0}},{"line":95,"address":[1384907],"length":1,"stats":{"Line":0}},{"line":104,"address":[1205952],"length":1,"stats":{"Line":1}},{"line":105,"address":[1205957],"length":1,"stats":{"Line":1}},{"line":108,"address":[1205968],"length":1,"stats":{"Line":1}},{"line":109,"address":[1205973],"length":1,"stats":{"Line":1}},{"line":112,"address":[1205984],"length":1,"stats":{"Line":1}},{"line":113,"address":[1205989],"length":1,"stats":{"Line":1}},{"line":116,"address":[1206016],"length":1,"stats":{"Line":1}},{"line":117,"address":[1206021],"length":1,"stats":{"Line":1}},{"line":120,"address":[1206064],"length":1,"stats":{"Line":1}},{"line":121,"address":[1206069],"length":1,"stats":{"Line":1}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[1206112],"length":1,"stats":{"Line":1}},{"line":148,"address":[1206117],"length":1,"stats":{"Line":1}},{"line":151,"address":[1206160],"length":1,"stats":{"Line":1}},{"line":152,"address":[1206165],"length":1,"stats":{"Line":1}},{"line":155,"address":[1206208],"length":1,"stats":{"Line":1}},{"line":156,"address":[1206217,1206322],"length":1,"stats":{"Line":2}},{"line":157,"address":[1206440],"length":1,"stats":{"Line":1}},{"line":158,"address":[1206347],"length":1,"stats":{"Line":1}},{"line":159,"address":[1206396],"length":1,"stats":{"Line":1}},{"line":162,"address":[1206518],"length":1,"stats":{"Line":1}},{"line":164,"address":[1206312],"length":1,"stats":{"Line":0}},{"line":167,"address":[1207000,1207006,1206560],"length":1,"stats":{"Line":1}},{"line":168,"address":[1206590],"length":1,"stats":{"Line":1}},{"line":170,"address":[1206665,1206609],"length":1,"stats":{"Line":2}},{"line":171,"address":[1206715,1206671],"length":1,"stats":{"Line":2}},{"line":174,"address":[1206704,1206749],"length":1,"stats":{"Line":2}},{"line":175,"address":[1206799,1206755],"length":1,"stats":{"Line":2}},{"line":178,"address":[1206788,1206833],"length":1,"stats":{"Line":2}},{"line":179,"address":[1206967,1206839],"length":1,"stats":{"Line":2}},{"line":182,"address":[1206877],"length":1,"stats":{"Line":1}},{"line":195,"address":[1385232],"length":1,"stats":{"Line":1}},{"line":197,"address":[1385254],"length":1,"stats":{"Line":1}},{"line":198,"address":[1385278],"length":1,"stats":{"Line":1}},{"line":199,"address":[1385304],"length":1,"stats":{"Line":1}},{"line":200,"address":[1385331],"length":1,"stats":{"Line":1}},{"line":201,"address":[1385358],"length":1,"stats":{"Line":1}},{"line":202,"address":[1385391],"length":1,"stats":{"Line":1}},{"line":203,"address":[1385427],"length":1,"stats":{"Line":1}},{"line":204,"address":[1385457],"length":1,"stats":{"Line":1}},{"line":205,"address":[1385499],"length":1,"stats":{"Line":1}},{"line":214,"address":[1385824],"length":1,"stats":{"Line":1}},{"line":216,"address":[1385846],"length":1,"stats":{"Line":1}},{"line":217,"address":[1385870],"length":1,"stats":{"Line":1}},{"line":218,"address":[1385896],"length":1,"stats":{"Line":1}},{"line":219,"address":[1385923],"length":1,"stats":{"Line":1}},{"line":220,"address":[1385950],"length":1,"stats":{"Line":1}},{"line":221,"address":[1385983],"length":1,"stats":{"Line":1}},{"line":222,"address":[1386019],"length":1,"stats":{"Line":1}},{"line":223,"address":[1386049],"length":1,"stats":{"Line":1}},{"line":224,"address":[1386091],"length":1,"stats":{"Line":1}}],"covered":69,"coverable":104},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","project_management","repository.rs"],"content":"use crate::domain::project_management::AnyProject;\nuse crate::domain::shared::errors::DomainError;\n\npub trait ProjectRepository {\n    fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e;\n    fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e;\n    fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e;\n    fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e;\n    fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","project_management","state.rs"],"content":"use serde::Serialize;\n\n/// A marker trait for all project states.\npub trait ProjectState: Sized + std::fmt::Debug {}\n\n/// State for a project that has been planned but not yet started.\n#[derive(Debug, Clone, Serialize)]\npub struct Planned;\nimpl ProjectState for Planned {}\n\n/// State for a project that is currently in progress.\n#[derive(Debug, Clone, Serialize)]\npub struct InProgress;\nimpl ProjectState for InProgress {}\n\n/// State for a project that has been completed.\n#[derive(Debug, Clone, Serialize)]\npub struct Completed;\nimpl ProjectState for Completed {}\n\n/// State for a project that has been cancelled.\n#[derive(Debug, Clone, Serialize)]\npub struct Cancelled;\nimpl ProjectState for Cancelled {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","project_management","vacation_rules.rs"],"content":"use crate::domain::project_management::layoff_period::LayoffPeriod;\nuse serde::{Deserialize, Serialize};\nuse std::fmt::Display;\n\n#[derive(Clone, Debug, PartialEq, Serialize, Deserialize, Default)]\npub struct VacationRules {\n    pub max_concurrent_vacations: Option\u003cu32\u003e,\n    pub allow_layoff_vacations: Option\u003cbool\u003e,\n    pub require_layoff_vacation_period: Option\u003cbool\u003e,\n    pub layoff_periods: Option\u003cVec\u003cLayoffPeriod\u003e\u003e,\n}\n\nimpl Display for VacationRules {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"VacationRules {{ max_concurrent_vacations: {:?}, allow_layoff_vacations: {:?}, require_layoff_vacation_period: {:?}, layoff_periods: {:?} }}\",\n            self.max_concurrent_vacations,\n            self.allow_layoff_vacations,\n            self.require_layoff_vacation_period,\n            self.layoff_periods\n        )\n    }\n}\n","traces":[{"line":14,"address":[674864],"length":1,"stats":{"Line":0}},{"line":15,"address":[674891],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","resource_management","any_resource.rs"],"content":"use super::{\n    resource::{Period, Resource, TimeOffEntry},\n    state::{Assigned, Available, Inactive},\n};\nuse serde::Serialize;\nuse uuid7::Uuid;\n\n/// An enum to represent a Resource in any of its possible states.\n#[derive(Debug, Clone, Serialize)]\n#[serde(tag = \"state\")]\npub enum AnyResource {\n    Available(Resource\u003cAvailable\u003e),\n    Assigned(Resource\u003cAssigned\u003e),\n    Inactive(Resource\u003cInactive\u003e),\n}\n\nimpl AnyResource {\n    #[allow(dead_code)]\n    pub fn id(\u0026self) -\u003e \u0026Uuid {\n        match self {\n            AnyResource::Available(r) =\u003e \u0026r.id,\n            AnyResource::Assigned(r) =\u003e \u0026r.id,\n            AnyResource::Inactive(r) =\u003e \u0026r.id,\n        }\n    }\n\n    pub fn code(\u0026self) -\u003e \u0026str {\n        match self {\n            AnyResource::Available(r) =\u003e \u0026r.code,\n            AnyResource::Assigned(r) =\u003e \u0026r.code,\n            AnyResource::Inactive(r) =\u003e \u0026r.code,\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026str {\n        match self {\n            AnyResource::Available(r) =\u003e \u0026r.name,\n            AnyResource::Assigned(r) =\u003e \u0026r.name,\n            AnyResource::Inactive(r) =\u003e \u0026r.name,\n        }\n    }\n\n    pub fn resource_type(\u0026self) -\u003e \u0026str {\n        match self {\n            AnyResource::Available(r) =\u003e \u0026r.resource_type,\n            AnyResource::Assigned(r) =\u003e \u0026r.resource_type,\n            AnyResource::Inactive(r) =\u003e \u0026r.resource_type,\n        }\n    }\n\n    pub fn vacations(\u0026self) -\u003e Option\u003c\u0026[Period]\u003e {\n        // Otimizado: retorna slice em vez de \u0026Vec\n        match self {\n            AnyResource::Available(r) =\u003e r.vacations.as_deref(),\n            AnyResource::Assigned(r) =\u003e r.vacations.as_deref(),\n            AnyResource::Inactive(r) =\u003e r.vacations.as_deref(),\n        }\n    }\n\n    pub fn time_off_balance(\u0026self) -\u003e u32 {\n        match self {\n            AnyResource::Available(r) =\u003e r.time_off_balance,\n            AnyResource::Assigned(r) =\u003e r.time_off_balance,\n            AnyResource::Inactive(r) =\u003e r.time_off_balance,\n        }\n    }\n\n    pub fn email(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        // Otimizado: retorna \u0026str em vez de \u0026String\n        match self {\n            AnyResource::Available(r) =\u003e r.email.as_deref(),\n            AnyResource::Assigned(r) =\u003e r.email.as_deref(),\n            AnyResource::Inactive(r) =\u003e r.email.as_deref(),\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn status(\u0026self) -\u003e \u0026str {\n        // Otimizado: removido 'static desnecessário\n        match self {\n            AnyResource::Available(_) =\u003e \"Available\",\n            AnyResource::Assigned(_) =\u003e \"Assigned\",\n            AnyResource::Inactive(_) =\u003e \"Inactive\",\n        }\n    }\n\n    // --- Zero-copy accessors ---\n\n    pub fn vacations_iter(\u0026self) -\u003e Option\u003cimpl Iterator\u003cItem = \u0026Period\u003e\u003e {\n        self.vacations().map(|v| v.iter())\n    }\n\n    pub fn time_off_history_iter(\u0026self) -\u003e Option\u003cimpl Iterator\u003cItem = \u0026TimeOffEntry\u003e\u003e {\n        match self {\n            AnyResource::Available(r) =\u003e r.time_off_history.as_deref().map(|h| h.iter()),\n            AnyResource::Assigned(r) =\u003e r.time_off_history.as_deref().map(|h| h.iter()),\n            AnyResource::Inactive(r) =\u003e r.time_off_history.as_deref().map(|h| h.iter()),\n        }\n    }\n\n    // --- State Transitions ---\n\n    pub fn deactivate(self) -\u003e Result\u003cAnyResource, String\u003e {\n        let inactive_resource = match self {\n            AnyResource::Available(r) =\u003e r.deactivate().into(),\n            AnyResource::Assigned(r) =\u003e r.deactivate().into(),\n            AnyResource::Inactive(_) =\u003e return Err(\"Resource is already inactive.\".to_string()),\n        };\n        Ok(inactive_resource)\n    }\n\n    // --- Setters for updating fields ---\n\n    pub fn set_name(\u0026mut self, name: String) {\n        match self {\n            AnyResource::Available(r) =\u003e r.name = name,\n            AnyResource::Assigned(r) =\u003e r.name = name,\n            AnyResource::Inactive(r) =\u003e r.name = name,\n        }\n    }\n\n    pub fn set_email(\u0026mut self, email: Option\u003cString\u003e) {\n        match self {\n            AnyResource::Available(r) =\u003e r.email = email,\n            AnyResource::Assigned(r) =\u003e r.email = email,\n            AnyResource::Inactive(r) =\u003e r.email = email,\n        }\n    }\n\n    pub fn set_resource_type(\u0026mut self, resource_type: String) {\n        match self {\n            AnyResource::Available(r) =\u003e r.resource_type = resource_type,\n            AnyResource::Assigned(r) =\u003e r.resource_type = resource_type,\n            AnyResource::Inactive(r) =\u003e r.resource_type = resource_type,\n        }\n    }\n}\n\nimpl From\u003cResource\u003cAvailable\u003e\u003e for AnyResource {\n    fn from(resource: Resource\u003cAvailable\u003e) -\u003e Self {\n        AnyResource::Available(resource)\n    }\n}\n\nimpl From\u003cResource\u003cAssigned\u003e\u003e for AnyResource {\n    fn from(resource: Resource\u003cAssigned\u003e) -\u003e Self {\n        AnyResource::Assigned(resource)\n    }\n}\n\nimpl From\u003cResource\u003cInactive\u003e\u003e for AnyResource {\n    fn from(resource: Resource\u003cInactive\u003e) -\u003e Self {\n        AnyResource::Inactive(resource)\n    }\n}\n","traces":[{"line":19,"address":[1798928],"length":1,"stats":{"Line":0}},{"line":20,"address":[1799074,1798938],"length":1,"stats":{"Line":0}},{"line":21,"address":[1799004],"length":1,"stats":{"Line":0}},{"line":22,"address":[1799031],"length":1,"stats":{"Line":0}},{"line":23,"address":[1799054],"length":1,"stats":{"Line":0}},{"line":27,"address":[1799088],"length":1,"stats":{"Line":1}},{"line":28,"address":[1799102,1799250],"length":1,"stats":{"Line":2}},{"line":29,"address":[1799168],"length":1,"stats":{"Line":1}},{"line":30,"address":[1799199],"length":1,"stats":{"Line":0}},{"line":31,"address":[1799226],"length":1,"stats":{"Line":1}},{"line":35,"address":[1799280],"length":1,"stats":{"Line":1}},{"line":36,"address":[1799454,1799294],"length":1,"stats":{"Line":2}},{"line":37,"address":[1799360],"length":1,"stats":{"Line":1}},{"line":38,"address":[1799395],"length":1,"stats":{"Line":0}},{"line":39,"address":[1799426],"length":1,"stats":{"Line":0}},{"line":43,"address":[1799472],"length":1,"stats":{"Line":1}},{"line":44,"address":[1799646,1799486],"length":1,"stats":{"Line":2}},{"line":45,"address":[1799552],"length":1,"stats":{"Line":1}},{"line":46,"address":[1799587],"length":1,"stats":{"Line":0}},{"line":47,"address":[1799618],"length":1,"stats":{"Line":0}},{"line":51,"address":[1799664],"length":1,"stats":{"Line":1}},{"line":53,"address":[1799678],"length":1,"stats":{"Line":1}},{"line":54,"address":[1799744],"length":1,"stats":{"Line":1}},{"line":55,"address":[1799779],"length":1,"stats":{"Line":0}},{"line":56,"address":[1799810],"length":1,"stats":{"Line":0}},{"line":60,"address":[1799856],"length":1,"stats":{"Line":5}},{"line":61,"address":[1799866],"length":1,"stats":{"Line":1}},{"line":62,"address":[1799932],"length":1,"stats":{"Line":6}},{"line":63,"address":[1799961],"length":1,"stats":{"Line":0}},{"line":64,"address":[1799983],"length":1,"stats":{"Line":0}},{"line":68,"address":[1800016],"length":1,"stats":{"Line":1}},{"line":70,"address":[1800030],"length":1,"stats":{"Line":1}},{"line":71,"address":[1800096],"length":1,"stats":{"Line":1}},{"line":72,"address":[1800132],"length":1,"stats":{"Line":0}},{"line":73,"address":[1800164],"length":1,"stats":{"Line":0}},{"line":78,"address":[1800208],"length":1,"stats":{"Line":1}},{"line":80,"address":[1800213],"length":1,"stats":{"Line":1}},{"line":81,"address":[1800274],"length":1,"stats":{"Line":0}},{"line":82,"address":[1800297],"length":1,"stats":{"Line":0}},{"line":83,"address":[1800320],"length":1,"stats":{"Line":1}},{"line":89,"address":[1800352],"length":1,"stats":{"Line":0}},{"line":90,"address":[750752,750766],"length":1,"stats":{"Line":0}},{"line":93,"address":[1800384],"length":1,"stats":{"Line":0}},{"line":94,"address":[1800398],"length":1,"stats":{"Line":0}},{"line":95,"address":[750798,750784],"length":1,"stats":{"Line":0}},{"line":96,"address":[750816,750830],"length":1,"stats":{"Line":0}},{"line":97,"address":[750862,750848],"length":1,"stats":{"Line":0}},{"line":103,"address":[1800624,1801235],"length":1,"stats":{"Line":1}},{"line":104,"address":[1800646],"length":1,"stats":{"Line":1}},{"line":105,"address":[1800929,1800712],"length":1,"stats":{"Line":2}},{"line":106,"address":[1800796,1801067],"length":1,"stats":{"Line":0}},{"line":107,"address":[1801134,1800821],"length":1,"stats":{"Line":0}},{"line":109,"address":[1800997],"length":1,"stats":{"Line":1}},{"line":114,"address":[1801537,1801264],"length":1,"stats":{"Line":1}},{"line":115,"address":[1801283],"length":1,"stats":{"Line":1}},{"line":116,"address":[1801458,1801349],"length":1,"stats":{"Line":1}},{"line":117,"address":[1801557,1801386],"length":1,"stats":{"Line":0}},{"line":118,"address":[1801414,1801642],"length":1,"stats":{"Line":0}},{"line":122,"address":[1801728,1802001],"length":1,"stats":{"Line":1}},{"line":123,"address":[1801747],"length":1,"stats":{"Line":1}},{"line":124,"address":[1801813,1801922],"length":1,"stats":{"Line":1}},{"line":125,"address":[1802021,1801850],"length":1,"stats":{"Line":0}},{"line":126,"address":[1802106,1801878],"length":1,"stats":{"Line":0}},{"line":130,"address":[1802192,1802465],"length":1,"stats":{"Line":0}},{"line":131,"address":[1802211],"length":1,"stats":{"Line":0}},{"line":132,"address":[1802277,1802386],"length":1,"stats":{"Line":0}},{"line":133,"address":[1802314,1802485],"length":1,"stats":{"Line":0}},{"line":134,"address":[1802342,1802570],"length":1,"stats":{"Line":0}},{"line":140,"address":[1802656],"length":1,"stats":{"Line":7}},{"line":141,"address":[1802673],"length":1,"stats":{"Line":10}},{"line":146,"address":[1802720],"length":1,"stats":{"Line":0}},{"line":147,"address":[1802728],"length":1,"stats":{"Line":0}},{"line":152,"address":[1802752],"length":1,"stats":{"Line":1}},{"line":153,"address":[1802769],"length":1,"stats":{"Line":1}}],"covered":36,"coverable":74},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","resource_management","errors.rs"],"content":"use crate::domain::shared::errors::{DomainError, DomainErrorKind};\nuse std::error::Error as StdError;\nuse std::fmt;\n\n/// Resource-specific error types\n#[derive(Debug)]\npub enum ResourceError {\n    NotFound { code: String },\n    AlreadyExists { code: String },\n    InvalidState { current: String, expected: String },\n    ValidationFailed { details: Vec\u003cString\u003e },\n    ModificationNotAllowed { state: String },\n    InvalidEmail { email: String, reason: String },\n    InvalidName { name: String, reason: String },\n    InvalidCode { code: String, reason: String },\n    DeactivationFailed { reason: String },\n}\n\nimpl fmt::Display for ResourceError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            ResourceError::NotFound { code } =\u003e {\n                write!(f, \"Resource with code '{}' not found\", code)\n            }\n            ResourceError::AlreadyExists { code } =\u003e {\n                write!(f, \"Resource with code '{}' already exists\", code)\n            }\n            ResourceError::InvalidState { current, expected } =\u003e {\n                write!(f, \"Resource is in invalid state '{}', expected '{}'\", current, expected)\n            }\n            ResourceError::ValidationFailed { details } =\u003e {\n                write!(f, \"Resource validation failed: {}\", details.join(\", \"))\n            }\n            ResourceError::ModificationNotAllowed { state } =\u003e {\n                write!(f, \"Cannot modify resource in state '{}'\", state)\n            }\n            ResourceError::InvalidEmail { email, reason } =\u003e {\n                write!(f, \"Invalid email '{}': {}\", email, reason)\n            }\n            ResourceError::InvalidName { name, reason } =\u003e {\n                write!(f, \"Invalid name '{}': {}\", name, reason)\n            }\n            ResourceError::InvalidCode { code, reason } =\u003e {\n                write!(f, \"Resource code '{}' is invalid: {}\", code, reason)\n            }\n            ResourceError::DeactivationFailed { reason } =\u003e {\n                write!(f, \"Resource deactivation failed: {}\", reason)\n            }\n        }\n    }\n}\n\nimpl StdError for ResourceError {}\n\nimpl From\u003cResourceError\u003e for DomainError {\n    fn from(err: ResourceError) -\u003e Self {\n        match err {\n            ResourceError::NotFound { code } =\u003e DomainError::new(DomainErrorKind::ResourceNotFound { code }),\n            ResourceError::AlreadyExists { code } =\u003e DomainError::new(DomainErrorKind::ResourceAlreadyExists { code }),\n            ResourceError::InvalidState { current, expected } =\u003e {\n                DomainError::new(DomainErrorKind::ResourceInvalidState { current, expected })\n            }\n            ResourceError::ValidationFailed { details } =\u003e {\n                DomainError::new(DomainErrorKind::ResourceValidationFailed { details })\n            }\n            ResourceError::ModificationNotAllowed { state } =\u003e {\n                DomainError::new(DomainErrorKind::ResourceInvalidState {\n                    current: state,\n                    expected: \"modifiable state\".to_string(),\n                })\n            }\n            ResourceError::InvalidEmail { email, reason } =\u003e DomainError::new(DomainErrorKind::ValidationError {\n                field: \"email\".to_string(),\n                message: format!(\"Email '{}' is invalid: {}\", email, reason),\n            }),\n            ResourceError::InvalidName { name, reason } =\u003e DomainError::new(DomainErrorKind::ValidationError {\n                field: \"name\".to_string(),\n                message: format!(\"Name '{}' is invalid: {}\", name, reason),\n            }),\n            ResourceError::InvalidCode { code, reason } =\u003e DomainError::new(DomainErrorKind::ValidationError {\n                field: \"code\".to_string(),\n                message: format!(\"Code '{}' is invalid: {}\", code, reason),\n            }),\n            ResourceError::DeactivationFailed { reason } =\u003e DomainError::new(DomainErrorKind::ResourceInvalidState {\n                current: \"active\".to_string(),\n                expected: \"deactivated\".to_string(),\n            })\n            .with_context(reason),\n        }\n    }\n}\n\n// Result type for resource operations\npub type ResourceResult\u003cT\u003e = Result\u003cT, ResourceError\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_resource_error_not_found_display() {\n        let error = ResourceError::NotFound { code: \"RES-001\".to_string() };\n        let expected = \"Resource with code 'RES-001' not found\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_error_already_exists_display() {\n        let error = ResourceError::AlreadyExists { code: \"RES-002\".to_string() };\n        let expected = \"Resource with code 'RES-002' already exists\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_error_invalid_state_display() {\n        let error = ResourceError::InvalidState { \n            current: \"Inactive\".to_string(), \n            expected: \"Active\".to_string() \n        };\n        let expected = \"Resource is in invalid state 'Inactive', expected 'Active'\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_error_validation_failed_display() {\n        let error = ResourceError::ValidationFailed { \n            details: vec![\"Name is required\".to_string(), \"Email is invalid\".to_string()] \n        };\n        let expected = \"Resource validation failed: Name is required, Email is invalid\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_error_modification_not_allowed_display() {\n        let error = ResourceError::ModificationNotAllowed { state: \"Inactive\".to_string() };\n        let expected = \"Cannot modify resource in state 'Inactive'\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_error_invalid_email_display() {\n        let error = ResourceError::InvalidEmail { \n            email: \"invalid-email\".to_string(), \n            reason: \"Missing @ symbol\".to_string() \n        };\n        let expected = \"Invalid email 'invalid-email': Missing @ symbol\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_error_invalid_name_display() {\n        let error = ResourceError::InvalidName { \n            name: \"123\".to_string(), \n            reason: \"Contains numbers\".to_string() \n        };\n        let expected = \"Invalid name '123': Contains numbers\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_error_invalid_code_display() {\n        let error = ResourceError::InvalidCode { \n            code: \"INVALID\".to_string(), \n            reason: \"Contains invalid characters\".to_string() \n        };\n        let expected = \"Resource code 'INVALID' is invalid: Contains invalid characters\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_error_deactivation_failed_display() {\n        let error = ResourceError::DeactivationFailed { \n            reason: \"Resource has active assignments\".to_string() \n        };\n        let expected = \"Resource deactivation failed: Resource has active assignments\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_error_debug_formatting() {\n        let error = ResourceError::NotFound { code: \"RES-001\".to_string() };\n        let debug_str = format!(\"{:?}\", error);\n        assert!(debug_str.contains(\"NotFound\"));\n        assert!(debug_str.contains(\"RES-001\"));\n    }\n\n    #[test]\n    fn test_from_resource_error_to_domain_error_not_found() {\n        let resource_error = ResourceError::NotFound { code: \"RES-001\".to_string() };\n        let domain_error: DomainError = resource_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ResourceNotFound { code } =\u003e {\n                assert_eq!(code, \"RES-001\");\n            }\n            _ =\u003e panic!(\"Expected ResourceNotFound error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_resource_error_to_domain_error_already_exists() {\n        let resource_error = ResourceError::AlreadyExists { code: \"RES-002\".to_string() };\n        let domain_error: DomainError = resource_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ResourceAlreadyExists { code } =\u003e {\n                assert_eq!(code, \"RES-002\");\n            }\n            _ =\u003e panic!(\"Expected ResourceAlreadyExists error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_resource_error_to_domain_error_invalid_state() {\n        let resource_error = ResourceError::InvalidState { \n            current: \"Inactive\".to_string(), \n            expected: \"Active\".to_string() \n        };\n        let domain_error: DomainError = resource_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ResourceInvalidState { current, expected } =\u003e {\n                assert_eq!(current, \"Inactive\");\n                assert_eq!(expected, \"Active\");\n            }\n            _ =\u003e panic!(\"Expected ResourceInvalidState error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_resource_error_to_domain_error_validation_failed() {\n        let resource_error = ResourceError::ValidationFailed { \n            details: vec![\"Name is required\".to_string(), \"Email is invalid\".to_string()] \n        };\n        let domain_error: DomainError = resource_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ResourceValidationFailed { details } =\u003e {\n                assert_eq!(details.len(), 2);\n                assert!(details.contains(\u0026\"Name is required\".to_string()));\n                assert!(details.contains(\u0026\"Email is invalid\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected ResourceValidationFailed error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_resource_error_to_domain_error_modification_not_allowed() {\n        let resource_error = ResourceError::ModificationNotAllowed { state: \"Inactive\".to_string() };\n        let domain_error: DomainError = resource_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ResourceInvalidState { current, expected } =\u003e {\n                assert_eq!(current, \"Inactive\");\n                assert_eq!(expected, \"modifiable state\");\n            }\n            _ =\u003e panic!(\"Expected ResourceInvalidState error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_resource_error_to_domain_error_invalid_email() {\n        let resource_error = ResourceError::InvalidEmail { \n            email: \"invalid-email\".to_string(), \n            reason: \"Missing @ symbol\".to_string() \n        };\n        let domain_error: DomainError = resource_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ValidationError { field, message } =\u003e {\n                assert_eq!(field, \"email\");\n                assert_eq!(message, \"Email 'invalid-email' is invalid: Missing @ symbol\");\n            }\n            _ =\u003e panic!(\"Expected ValidationError error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_resource_error_to_domain_error_invalid_name() {\n        let resource_error = ResourceError::InvalidName { \n            name: \"123\".to_string(), \n            reason: \"Contains numbers\".to_string() \n        };\n        let domain_error: DomainError = resource_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ValidationError { field, message } =\u003e {\n                assert_eq!(field, \"name\");\n                assert_eq!(message, \"Name '123' is invalid: Contains numbers\");\n            }\n            _ =\u003e panic!(\"Expected ValidationError error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_resource_error_to_domain_error_invalid_code() {\n        let resource_error = ResourceError::InvalidCode { \n            code: \"INVALID\".to_string(), \n            reason: \"Contains invalid characters\".to_string() \n        };\n        let domain_error: DomainError = resource_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ValidationError { field, message } =\u003e {\n                assert_eq!(field, \"code\");\n                assert_eq!(message, \"Code 'INVALID' is invalid: Contains invalid characters\");\n            }\n            _ =\u003e panic!(\"Expected ValidationError error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_resource_error_to_domain_error_deactivation_failed() {\n        let resource_error = ResourceError::DeactivationFailed { \n            reason: \"Resource has active assignments\".to_string() \n        };\n        let domain_error: DomainError = resource_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ResourceInvalidState { current, expected } =\u003e {\n                assert_eq!(current, \"active\");\n                assert_eq!(expected, \"deactivated\");\n            }\n            _ =\u003e panic!(\"Expected ResourceInvalidState error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_resource_result_success() {\n        let result: ResourceResult\u003cString\u003e = Ok(\"Success\".to_string());\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"Success\");\n    }\n\n    #[test]\n    fn test_resource_result_failure() {\n        let result: ResourceResult\u003cString\u003e = Err(ResourceError::NotFound { code: \"RES-001\".to_string() });\n        assert!(result.is_err());\n        \n        match result {\n            Err(ResourceError::NotFound { code }) =\u003e {\n                assert_eq!(code, \"RES-001\");\n            }\n            _ =\u003e panic!(\"Expected NotFound error\"),\n        }\n    }\n\n    #[test]\n    fn test_all_error_variants_covered() {\n        // Test that all ResourceError variants can be created and converted\n        let errors = vec![\n            ResourceError::NotFound { code: \"TEST\".to_string() },\n            ResourceError::AlreadyExists { code: \"TEST\".to_string() },\n            ResourceError::InvalidState { \n                current: \"TEST\".to_string(), \n                expected: \"TEST\".to_string() \n            },\n            ResourceError::ValidationFailed { \n                details: vec![\"TEST\".to_string()] \n            },\n            ResourceError::ModificationNotAllowed { state: \"TEST\".to_string() },\n            ResourceError::InvalidEmail { \n                email: \"TEST\".to_string(), \n                reason: \"TEST\".to_string() \n            },\n            ResourceError::InvalidName { \n                name: \"TEST\".to_string(), \n                reason: \"TEST\".to_string() \n            },\n            ResourceError::InvalidCode { \n                code: \"TEST\".to_string(), \n                reason: \"TEST\".to_string() \n            },\n            ResourceError::DeactivationFailed { reason: \"TEST\".to_string() },\n        ];\n\n        for error in errors {\n            let domain_error: DomainError = error.into();\n            assert!(domain_error.to_string().len() \u003e 0);\n        }\n    }\n}\n","traces":[{"line":20,"address":[2874341,2874347,2872624],"length":1,"stats":{"Line":1}},{"line":21,"address":[2872657],"length":1,"stats":{"Line":1}},{"line":22,"address":[2872693],"length":1,"stats":{"Line":1}},{"line":23,"address":[2872702],"length":1,"stats":{"Line":1}},{"line":25,"address":[2872795],"length":1,"stats":{"Line":1}},{"line":26,"address":[2872807],"length":1,"stats":{"Line":1}},{"line":28,"address":[2872924],"length":1,"stats":{"Line":1}},{"line":29,"address":[2872951],"length":1,"stats":{"Line":1}},{"line":31,"address":[2873154],"length":1,"stats":{"Line":1}},{"line":32,"address":[2873166,2874194],"length":1,"stats":{"Line":1}},{"line":34,"address":[2873245],"length":1,"stats":{"Line":1}},{"line":35,"address":[2873257],"length":1,"stats":{"Line":1}},{"line":37,"address":[2873374],"length":1,"stats":{"Line":1}},{"line":38,"address":[2873401],"length":1,"stats":{"Line":1}},{"line":40,"address":[2873604],"length":1,"stats":{"Line":1}},{"line":41,"address":[2873631],"length":1,"stats":{"Line":1}},{"line":43,"address":[2873834],"length":1,"stats":{"Line":1}},{"line":44,"address":[2873861],"length":1,"stats":{"Line":1}},{"line":46,"address":[2874061],"length":1,"stats":{"Line":1}},{"line":47,"address":[2874073],"length":1,"stats":{"Line":1}},{"line":56,"address":[3062896,3064113],"length":1,"stats":{"Line":1}},{"line":57,"address":[3062918],"length":1,"stats":{"Line":1}},{"line":58,"address":[3062967],"length":1,"stats":{"Line":1}},{"line":59,"address":[3063058],"length":1,"stats":{"Line":1}},{"line":60,"address":[3063176],"length":1,"stats":{"Line":1}},{"line":61,"address":[3063248],"length":1,"stats":{"Line":2}},{"line":63,"address":[3063384],"length":1,"stats":{"Line":1}},{"line":64,"address":[3063420],"length":1,"stats":{"Line":1}},{"line":66,"address":[3063503],"length":1,"stats":{"Line":1}},{"line":67,"address":[3063987],"length":1,"stats":{"Line":1}},{"line":68,"address":[3063527],"length":1,"stats":{"Line":1}},{"line":69,"address":[3063559],"length":1,"stats":{"Line":1}},{"line":72,"address":[3064424,3063598],"length":1,"stats":{"Line":2}},{"line":73,"address":[3063646],"length":1,"stats":{"Line":1}},{"line":74,"address":[3064184,3064276],"length":1,"stats":{"Line":2}},{"line":76,"address":[3063685,3064889],"length":1,"stats":{"Line":2}},{"line":77,"address":[3063733],"length":1,"stats":{"Line":1}},{"line":78,"address":[3064649,3064741],"length":1,"stats":{"Line":2}},{"line":80,"address":[3065354,3063772],"length":1,"stats":{"Line":2}},{"line":81,"address":[3063820],"length":1,"stats":{"Line":1}},{"line":82,"address":[3065206,3065114],"length":1,"stats":{"Line":2}},{"line":84,"address":[3065640,3063859],"length":1,"stats":{"Line":2}},{"line":85,"address":[3063891],"length":1,"stats":{"Line":1}},{"line":86,"address":[3065568],"length":1,"stats":{"Line":1}},{"line":88,"address":[3065744,3065527],"length":1,"stats":{"Line":1}}],"covered":45,"coverable":45},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","resource_management","mod.rs"],"content":"pub mod any_resource;\npub mod errors;\npub mod repository;\npub mod resource;\npub mod state;\n\npub use any_resource::AnyResource;\npub use resource::{Period, PeriodType};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","resource_management","repository.rs"],"content":"use crate::domain::resource_management::AnyResource;\nuse crate::domain::shared::errors::DomainError;\nuse chrono::{DateTime, Local};\n\npub trait ResourceRepository {\n    fn save(\u0026self, resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e;\n    fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e;\n    fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e;\n    fn save_time_off(\n        \u0026self,\n        resource_name: \u0026str,\n        hours: u32,\n        date: \u0026str,\n        description: Option\u003cString\u003e,\n    ) -\u003e Result\u003cAnyResource, DomainError\u003e;\n    fn save_vacation(\n        \u0026self,\n        resource_name: \u0026str,\n        start_date: \u0026str,\n        end_date: \u0026str,\n        is_time_off_compensation: bool,\n        compensated_hours: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cAnyResource, DomainError\u003e;\n    fn check_if_layoff_period(\u0026self, start_date: \u0026DateTime\u003cLocal\u003e, end_date: \u0026DateTime\u003cLocal\u003e) -\u003e bool;\n    fn get_next_code(\u0026self, resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","resource_management","resource.rs"],"content":"use super::state::{Assigned, Available, Inactive, ResourceState};\nuse chrono::{DateTime, Local};\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\nuse std::fmt::Display;\nuse uuid7::{Uuid, uuid7};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct TimeOffEntry {\n    pub date: DateTime\u003cLocal\u003e,\n    pub hours: u32,\n    pub description: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Period {\n    pub start_date: DateTime\u003cLocal\u003e,\n    pub end_date: DateTime\u003cLocal\u003e,\n    pub approved: bool,\n    pub period_type: PeriodType,\n    pub is_time_off_compensation: bool,\n    pub compensated_hours: Option\u003cu32\u003e,\n    pub is_layoff: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub enum PeriodType {\n    Vacation,\n    TimeOff,\n    BirthdayBreak,\n    DayOff,\n    SickLeave,\n    PersonalLeave,\n    TimeOffCompensation,\n}\n\nimpl fmt::Display for PeriodType {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            PeriodType::Vacation =\u003e write!(f, \"Vacation\"),\n            PeriodType::TimeOff =\u003e write!(f, \"TimeOff\"),\n            PeriodType::BirthdayBreak =\u003e write!(f, \"BirthdayBreak\"),\n            PeriodType::DayOff =\u003e write!(f, \"DayOff\"),\n            PeriodType::SickLeave =\u003e write!(f, \"SickLeave\"),\n            PeriodType::PersonalLeave =\u003e write!(f, \"PersonalLeave\"),\n            PeriodType::TimeOffCompensation =\u003e write!(f, \"TimeOffCompensation\"),\n        }\n    }\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct ProjectAssignment {\n    pub project_id: String,\n    pub start_date: DateTime\u003cLocal\u003e,\n    pub end_date: DateTime\u003cLocal\u003e,\n    pub allocation_percentage: u8,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Resource\u003cS: ResourceState\u003e {\n    pub id: Uuid,\n    pub code: String,\n    pub name: String,\n    pub email: Option\u003cString\u003e,\n    pub resource_type: String,\n    pub vacations: Option\u003cVec\u003cPeriod\u003e\u003e,\n    pub time_off_balance: u32,\n    pub time_off_history: Option\u003cVec\u003cTimeOffEntry\u003e\u003e,\n    pub state: S,\n}\n\nimpl Resource\u003cAvailable\u003e {\n    pub fn new(\n        code: String,\n        name: String,\n        email: Option\u003cString\u003e,\n        resource_type: String,\n        vacations: Option\u003cVec\u003cPeriod\u003e\u003e,\n        time_off_balance: u32,\n    ) -\u003e Self {\n        Self {\n            id: uuid7(),\n            code,\n            name,\n            email,\n            resource_type,\n            vacations,\n            time_off_balance,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn assign_to_project(self, assignment: ProjectAssignment) -\u003e Resource\u003cAssigned\u003e {\n        Resource {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            email: self.email,\n            resource_type: self.resource_type,\n            vacations: self.vacations,\n            time_off_balance: self.time_off_balance,\n            time_off_history: self.time_off_history,\n            state: Assigned {\n                project_assignments: vec![assignment],\n            },\n        }\n    }\n\n    #[allow(dead_code)]\n    pub fn deactivate(self) -\u003e Resource\u003cInactive\u003e {\n        Resource {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            email: self.email,\n            resource_type: self.resource_type,\n            vacations: self.vacations,\n            time_off_balance: self.time_off_balance,\n            time_off_history: self.time_off_history,\n            state: Inactive,\n        }\n    }\n}\n\nimpl Resource\u003cAssigned\u003e {\n    #[allow(dead_code)]\n    pub fn assign_to_another_project(mut self, assignment: ProjectAssignment) -\u003e Self {\n        self.state.project_assignments.push(assignment);\n        self\n    }\n\n    #[allow(dead_code)]\n    pub fn deactivate(self) -\u003e Resource\u003cInactive\u003e {\n        Resource {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            email: self.email,\n            resource_type: self.resource_type,\n            vacations: self.vacations,\n            time_off_balance: self.time_off_balance,\n            time_off_history: self.time_off_history,\n            state: Inactive,\n        }\n    }\n}\n\nimpl\u003cS: ResourceState\u003e Display for Resource\u003cS\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Resource {{ id: {:?}, code: {}, name: {}, email: {:?}, resource_type: {}, vacations: {:?}, time_off_balance: {}, state: {:?} }}\",\n            self.id,\n            self.code,\n            self.name,\n            self.email,\n            self.resource_type,\n            self.vacations,\n            self.time_off_balance,\n            self.state\n        )\n    }\n}\n\n// Common methods for all Resource states\nimpl\u003cS: ResourceState\u003e Resource\u003cS\u003e {\n    // Getters\n    pub fn code(\u0026self) -\u003e \u0026str {\n        \u0026self.code\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    pub fn email(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.email.as_deref()\n    }\n\n    // --- Zero-copy accessors ---\n\n    pub fn resource_type(\u0026self) -\u003e \u0026str {\n        \u0026self.resource_type\n    }\n\n    pub fn vacations(\u0026self) -\u003e Option\u003c\u0026[Period]\u003e {\n        self.vacations.as_deref()\n    }\n\n    pub fn time_off_history(\u0026self) -\u003e Option\u003c\u0026[TimeOffEntry]\u003e {\n        self.time_off_history.as_deref()\n    }\n\n    pub fn time_off_balance(\u0026self) -\u003e u32 {\n        self.time_off_balance\n    }\n\n    pub fn vacations_iter(\u0026self) -\u003e Option\u003cimpl Iterator\u003cItem = \u0026Period\u003e\u003e {\n        self.vacations().map(|v| v.iter())\n    }\n\n    pub fn time_off_history_iter(\u0026self) -\u003e Option\u003cimpl Iterator\u003cItem = \u0026TimeOffEntry\u003e\u003e {\n        self.time_off_history().map(|h| h.iter())\n    }\n\n    // Validation methods\n    pub fn is_code_valid(\u0026self) -\u003e bool {\n        !self.code.trim().is_empty()\n    }\n\n    pub fn is_name_valid(\u0026self) -\u003e bool {\n        !self.name.trim().is_empty()\n    }\n\n    pub fn is_email_valid(\u0026self) -\u003e bool {\n        if let Some(email) = \u0026self.email {\n            // Simple email validation - check for @ and basic format\n            email.contains('@') \u0026\u0026 email.contains('.') \u0026\u0026 email.len() \u003e 5\n        } else {\n            true // No email is valid\n        }\n    }\n\n    pub fn validate(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n        let mut errors = Vec::new();\n\n        if !self.is_code_valid() {\n            errors.push(\"Resource code cannot be empty\".to_string());\n        }\n\n        if !self.is_name_valid() {\n            errors.push(\"Resource name cannot be empty\".to_string());\n        }\n\n        if !self.is_email_valid() {\n            errors.push(\"Resource email format is invalid\".to_string());\n        }\n\n        Ok(errors)\n    }\n}\n\n// Transition trait for state changes\npub trait Transition {\n    type NextState: ResourceState;\n    fn transition(self) -\u003e Resource\u003cSelf::NextState\u003e;\n}\n\nimpl Transition for Resource\u003cAvailable\u003e {\n    type NextState = Inactive;\n\n    fn transition(self) -\u003e Resource\u003cInactive\u003e {\n        Resource {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            email: self.email,\n            resource_type: self.resource_type,\n            vacations: self.vacations,\n            time_off_balance: self.time_off_balance,\n            time_off_history: self.time_off_history,\n            state: Inactive,\n        }\n    }\n}\n\nimpl Transition for Resource\u003cInactive\u003e {\n    type NextState = Available;\n\n    fn transition(self) -\u003e Resource\u003cAvailable\u003e {\n        Resource {\n            id: self.id,\n            code: self.code,\n            name: self.name,\n            email: self.email,\n            resource_type: self.resource_type,\n            vacations: self.vacations,\n            time_off_balance: self.time_off_balance,\n            time_off_history: self.time_off_history,\n            state: Available,\n        }\n    }\n}\n\nimpl Display for Period {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Period {{ start_date: {}, end_date: {}, approved: {}, period_type: {}, is_time_off_compensation: {}, compensated_hours: {:?}, is_layoff: {} }}\",\n            self.start_date,\n            self.end_date,\n            self.approved,\n            self.period_type,\n            self.is_time_off_compensation,\n            self.compensated_hours,\n            self.is_layoff\n        )\n    }\n}\n\nimpl Display for ProjectAssignment {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"ProjectAssignment: {{ project_id: {}, start_date: {}, end_date: {} }}\",\n            self.project_id, self.start_date, self.end_date\n        )\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::{DateTime, Local, TimeZone};\n    use uuid7::uuid7;\n\n    // Helper to create a DateTime\u003cLocal\u003e for tests\n    fn dt(year: i32, month: u32, day: u32) -\u003e DateTime\u003cLocal\u003e {\n        Local.with_ymd_and_hms(year, month, day, 0, 0, 0).unwrap()\n    }\n\n    #[test]\n    fn test_period_type_display() {\n        assert_eq!(PeriodType::Vacation.to_string(), \"Vacation\");\n        assert_eq!(PeriodType::TimeOff.to_string(), \"TimeOff\");\n        assert_eq!(PeriodType::BirthdayBreak.to_string(), \"BirthdayBreak\");\n        assert_eq!(PeriodType::DayOff.to_string(), \"DayOff\");\n        assert_eq!(PeriodType::SickLeave.to_string(), \"SickLeave\");\n        assert_eq!(PeriodType::PersonalLeave.to_string(), \"PersonalLeave\");\n        assert_eq!(PeriodType::TimeOffCompensation.to_string(), \"TimeOffCompensation\");\n    }\n\n    #[test]\n    fn test_period_display() {\n        let period = Period {\n            start_date: dt(2025, 1, 1),\n            end_date: dt(2025, 1, 10),\n            approved: true,\n            period_type: PeriodType::Vacation,\n            is_time_off_compensation: false,\n            compensated_hours: None,\n            is_layoff: false,\n        };\n        let expected = format!(\n            \"Period {{ start_date: {}, end_date: {}, approved: true, period_type: Vacation, is_time_off_compensation: false, compensated_hours: None, is_layoff: false }}\",\n            dt(2025, 1, 1),\n            dt(2025, 1, 10)\n        );\n        assert_eq!(period.to_string(), expected);\n    }\n\n    #[test]\n    fn test_project_assignment_display() {\n        let assignment = ProjectAssignment {\n            project_id: \"PROJ-R-US\".to_string(),\n            start_date: dt(2025, 2, 1),\n            end_date: dt(2025, 8, 1),\n            allocation_percentage: 100,\n        };\n        let expected = format!(\n            \"ProjectAssignment: {{ project_id: PROJ-R-US, start_date: {}, end_date: {} }}\",\n            dt(2025, 2, 1),\n            dt(2025, 8, 1)\n        );\n        assert_eq!(assignment.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_display() {\n        let id = uuid7();\n        let resource = Resource {\n            id,\n            code: \"dev-7\".to_string(),\n            name: \"James\".to_string(),\n            email: Some(\"james@test.com\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: None,\n            time_off_balance: 40,\n            time_off_history: None,\n            state: Available,\n        };\n        let expected = format!(\n            \"Resource {{ id: {id:?}, code: dev-7, name: James, email: Some(\\\"james@test.com\\\"), resource_type: Developer, vacations: None, time_off_balance: 40, state: Available }}\"\n        );\n        assert_eq!(resource.to_string(), expected);\n    }\n\n    #[test]\n    fn test_resource_state_transition_to_assigned() {\n        let resource = Resource::new(\n            \"qa-1\".to_string(),\n            \"Tester\".to_string(),\n            None,\n            \"QA\".to_string(),\n            None,\n            40,\n        );\n\n        let assignment = ProjectAssignment {\n            project_id: \"PROJ-1\".to_string(),\n            start_date: dt(2025, 1, 1),\n            end_date: dt(2025, 6, 1),\n            allocation_percentage: 100,\n        };\n\n        let assigned_resource = resource.assign_to_project(assignment.clone());\n\n        assert_eq!(assigned_resource.state.project_assignments.len(), 1);\n        assert_eq!(assigned_resource.state.project_assignments[0], assignment);\n\n        let another_assignment = ProjectAssignment {\n            project_id: \"PROJ-2\".to_string(),\n            start_date: dt(2025, 7, 1),\n            end_date: dt(2025, 12, 1),\n            allocation_percentage: 50,\n        };\n\n        let multi_assigned_resource = assigned_resource.assign_to_another_project(another_assignment.clone());\n        assert_eq!(multi_assigned_resource.state.project_assignments.len(), 2);\n    }\n\n    #[test]\n    fn test_resource_creation_with_valid_data() {\n        let resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"RES-001\".to_string(),\n            name: \"John Doe\".to_string(),\n            email: Some(\"john.doe@example.com\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        assert_eq!(resource.code(), \"RES-001\");\n        assert_eq!(resource.name(), \"John Doe\");\n        assert_eq!(resource.email(), Some(\"john.doe@example.com\"));\n        assert!(resource.is_code_valid());\n        assert!(resource.is_name_valid());\n        assert!(resource.is_email_valid());\n    }\n\n    #[test]\n    fn test_resource_code_validation() {\n        // Valid code\n        let valid_resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"RES-001\".to_string(),\n            name: \"Test Resource\".to_string(),\n            email: Some(\"test@example.com\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        assert!(valid_resource.is_code_valid());\n\n        // Invalid code (empty)\n        let invalid_resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"\".to_string(),\n            name: \"Test Resource\".to_string(),\n            email: Some(\"test@example.com\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        assert!(!invalid_resource.is_code_valid());\n    }\n\n    #[test]\n    fn test_resource_name_validation() {\n        // Valid name\n        let valid_resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"RES-001\".to_string(),\n            name: \"John Doe\".to_string(),\n            email: Some(\"john@example.com\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        assert!(valid_resource.is_name_valid());\n\n        // Invalid name (empty)\n        let invalid_resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"RES-001\".to_string(),\n            name: \"\".to_string(),\n            email: Some(\"john@example.com\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        assert!(!invalid_resource.is_name_valid());\n    }\n\n    #[test]\n    fn test_resource_email_validation() {\n        // Valid email\n        let valid_resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"RES-001\".to_string(),\n            name: \"John Doe\".to_string(),\n            email: Some(\"john.doe@example.com\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        assert!(valid_resource.is_email_valid());\n\n        // Invalid email format\n        let invalid_resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"RES-001\".to_string(),\n            name: \"John Doe\".to_string(),\n            email: Some(\"invalid-email\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        assert!(!invalid_resource.is_email_valid());\n\n        // No email (should be valid)\n        let no_email_resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"RES-001\".to_string(),\n            name: \"John Doe\".to_string(),\n            email: None,\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        assert!(no_email_resource.is_email_valid());\n    }\n\n    #[test]\n    fn test_resource_comprehensive_validation() {\n        let valid_resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"RES-001\".to_string(),\n            name: \"John Doe\".to_string(),\n            email: Some(\"john.doe@example.com\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        let validation_result = valid_resource.validate();\n        assert!(validation_result.is_ok());\n        assert_eq!(validation_result.unwrap().len(), 0); // No validation errors\n\n        let invalid_resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"\".to_string(),\n            name: \"\".to_string(),\n            email: Some(\"invalid-email\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        let validation_result = invalid_resource.validate();\n        assert!(validation_result.is_ok());\n        let errors = validation_result.unwrap();\n        assert!(!errors.is_empty()); // Should have validation errors\n        assert!(errors.iter().any(|e| e.contains(\"code\")));\n        assert!(errors.iter().any(|e| e.contains(\"name\")));\n        assert!(errors.iter().any(|e| e.contains(\"email\")));\n    }\n\n    #[test]\n    fn test_resource_state_transitions() {\n        let available_resource = Resource::\u003cAvailable\u003e {\n            id: uuid7(),\n            code: \"RES-001\".to_string(),\n            name: \"John Doe\".to_string(),\n            email: Some(\"john@example.com\".to_string()),\n            resource_type: \"Developer\".to_string(),\n            vacations: Some(Vec::new()),\n            time_off_balance: 160,\n            time_off_history: Some(Vec::new()),\n            state: Available,\n        };\n\n        // Transition from Available to Inactive\n        let inactive_resource: Resource\u003cInactive\u003e = available_resource.deactivate();\n        assert!(matches!(inactive_resource.state, Inactive));\n\n        // Note: We don't have a direct transition from Inactive to Available\n        // This would need to be implemented if needed\n    }\n}\n","traces":[{"line":38,"address":[1700928],"length":1,"stats":{"Line":1}},{"line":39,"address":[1700955],"length":1,"stats":{"Line":2}},{"line":40,"address":[1700986],"length":1,"stats":{"Line":2}},{"line":41,"address":[1701029],"length":1,"stats":{"Line":1}},{"line":42,"address":[1701072],"length":1,"stats":{"Line":1}},{"line":43,"address":[1701115],"length":1,"stats":{"Line":1}},{"line":44,"address":[1701164],"length":1,"stats":{"Line":1}},{"line":45,"address":[1701210],"length":1,"stats":{"Line":1}},{"line":46,"address":[1701256],"length":1,"stats":{"Line":1}},{"line":73,"address":[1701328,1702048,1702234],"length":1,"stats":{"Line":7}},{"line":82,"address":[1701380],"length":1,"stats":{"Line":7}},{"line":89,"address":[1701695,1701756],"length":1,"stats":{"Line":14}},{"line":95,"address":[1703156,1702272,1703055],"length":1,"stats":{"Line":1}},{"line":97,"address":[1702298],"length":1,"stats":{"Line":1}},{"line":98,"address":[1702326],"length":1,"stats":{"Line":1}},{"line":99,"address":[1702343],"length":1,"stats":{"Line":1}},{"line":100,"address":[1702361],"length":1,"stats":{"Line":1}},{"line":101,"address":[1702385],"length":1,"stats":{"Line":1}},{"line":102,"address":[1702409],"length":1,"stats":{"Line":1}},{"line":103,"address":[1702433],"length":1,"stats":{"Line":1}},{"line":104,"address":[1702443],"length":1,"stats":{"Line":1}},{"line":105,"address":[1702721],"length":1,"stats":{"Line":1}},{"line":112,"address":[1703184],"length":1,"stats":{"Line":1}},{"line":114,"address":[1703191],"length":1,"stats":{"Line":1}},{"line":115,"address":[1703215],"length":1,"stats":{"Line":1}},{"line":116,"address":[1703241],"length":1,"stats":{"Line":1}},{"line":117,"address":[1703268],"length":1,"stats":{"Line":1}},{"line":118,"address":[1703295],"length":1,"stats":{"Line":1}},{"line":119,"address":[1703322],"length":1,"stats":{"Line":1}},{"line":120,"address":[1703348],"length":1,"stats":{"Line":1}},{"line":121,"address":[1703354],"length":1,"stats":{"Line":1}},{"line":129,"address":[1703600,1703716],"length":1,"stats":{"Line":1}},{"line":130,"address":[1703640],"length":1,"stats":{"Line":1}},{"line":131,"address":[1703696],"length":1,"stats":{"Line":1}},{"line":135,"address":[1703744],"length":1,"stats":{"Line":0}},{"line":137,"address":[1703772],"length":1,"stats":{"Line":0}},{"line":138,"address":[1703796],"length":1,"stats":{"Line":0}},{"line":139,"address":[1703822],"length":1,"stats":{"Line":0}},{"line":140,"address":[1703849],"length":1,"stats":{"Line":0}},{"line":141,"address":[1703876],"length":1,"stats":{"Line":0}},{"line":142,"address":[1703906],"length":1,"stats":{"Line":0}},{"line":143,"address":[1703948],"length":1,"stats":{"Line":0}},{"line":144,"address":[1703954],"length":1,"stats":{"Line":0}},{"line":151,"address":[1122944],"length":1,"stats":{"Line":1}},{"line":152,"address":[1122974],"length":1,"stats":{"Line":1}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[1123520],"length":1,"stats":{"Line":1}},{"line":171,"address":[1123525],"length":1,"stats":{"Line":1}},{"line":174,"address":[1123536],"length":1,"stats":{"Line":1}},{"line":175,"address":[1123541],"length":1,"stats":{"Line":1}},{"line":178,"address":[1123552],"length":1,"stats":{"Line":1}},{"line":179,"address":[1123557],"length":1,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[1123584],"length":1,"stats":{"Line":1}},{"line":210,"address":[1123589],"length":1,"stats":{"Line":1}},{"line":213,"address":[1123632],"length":1,"stats":{"Line":1}},{"line":214,"address":[1123637],"length":1,"stats":{"Line":2}},{"line":217,"address":[1123680],"length":1,"stats":{"Line":1}},{"line":218,"address":[1123689,1123777],"length":1,"stats":{"Line":2}},{"line":220,"address":[1123779,1123744],"length":1,"stats":{"Line":2}},{"line":222,"address":[1123772],"length":1,"stats":{"Line":1}},{"line":226,"address":[1124296,1123856,1124302],"length":1,"stats":{"Line":1}},{"line":227,"address":[1123886],"length":1,"stats":{"Line":1}},{"line":229,"address":[1123905,1123961],"length":1,"stats":{"Line":2}},{"line":230,"address":[1123967,1124011],"length":1,"stats":{"Line":2}},{"line":233,"address":[1124045,1124000],"length":1,"stats":{"Line":2}},{"line":234,"address":[1124051,1124095],"length":1,"stats":{"Line":2}},{"line":237,"address":[1124084,1124129],"length":1,"stats":{"Line":2}},{"line":238,"address":[1124263,1124135],"length":1,"stats":{"Line":2}},{"line":241,"address":[1124173],"length":1,"stats":{"Line":1}},{"line":254,"address":[1704240],"length":1,"stats":{"Line":0}},{"line":256,"address":[1704247],"length":1,"stats":{"Line":0}},{"line":257,"address":[1704271],"length":1,"stats":{"Line":0}},{"line":258,"address":[1704297],"length":1,"stats":{"Line":0}},{"line":259,"address":[1704324],"length":1,"stats":{"Line":0}},{"line":260,"address":[1704351],"length":1,"stats":{"Line":0}},{"line":261,"address":[1704378],"length":1,"stats":{"Line":0}},{"line":262,"address":[1704404],"length":1,"stats":{"Line":0}},{"line":263,"address":[1704410],"length":1,"stats":{"Line":0}},{"line":272,"address":[1704656],"length":1,"stats":{"Line":0}},{"line":274,"address":[1704663],"length":1,"stats":{"Line":0}},{"line":275,"address":[1704687],"length":1,"stats":{"Line":0}},{"line":276,"address":[1704713],"length":1,"stats":{"Line":0}},{"line":277,"address":[1704740],"length":1,"stats":{"Line":0}},{"line":278,"address":[1704767],"length":1,"stats":{"Line":0}},{"line":279,"address":[1704794],"length":1,"stats":{"Line":0}},{"line":280,"address":[1704820],"length":1,"stats":{"Line":0}},{"line":281,"address":[1704826],"length":1,"stats":{"Line":0}},{"line":288,"address":[1705072],"length":1,"stats":{"Line":1}},{"line":289,"address":[1705103],"length":1,"stats":{"Line":1}},{"line":304,"address":[1705584],"length":1,"stats":{"Line":1}},{"line":305,"address":[1705615],"length":1,"stats":{"Line":1}}],"covered":63,"coverable":111},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","resource_management","state.rs"],"content":"use super::resource::ProjectAssignment;\nuse serde::{Deserialize, Serialize};\n\n/// A marker trait for all resource states.\npub trait ResourceState: Sized + std::fmt::Debug {}\n\n/// State for a resource that is available for project assignments.\n#[derive(Debug, Clone, Serialize)]\npub struct Available;\nimpl ResourceState for Available {}\n\n/// State for a resource that is currently assigned to one or more projects.\n#[derive(Debug, Clone, Serialize)]\npub struct Assigned {\n    pub project_assignments: Vec\u003cProjectAssignment\u003e,\n}\nimpl ResourceState for Assigned {}\n\n/// State for a resource that is no longer active in the system.\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Inactive;\nimpl ResourceState for Inactive {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","shared","command.rs"],"content":"use crate::domain::shared::errors::DomainError;\nuse std::collections::HashMap;\n\n/// A command that can be executed\npub trait Command {\n    /// Execute the command\n    fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e;\n\n    /// Get the command name\n    fn name(\u0026self) -\u003e \u0026str;\n\n    /// Get the command description\n    fn description(\u0026self) -\u003e \u0026str;\n\n    /// Check if the command can be executed\n    fn can_execute(\u0026self) -\u003e bool {\n        true\n    }\n\n    /// Validate the command before execution\n    fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n        Ok(())\n    }\n}\n\n/// Result of executing a command\n#[derive(Debug, Clone, PartialEq)]\npub struct CommandResult {\n    pub success: bool,\n    pub message: String,\n    pub data: Option\u003cserde_yaml::Value\u003e,\n}\n\nimpl CommandResult {\n    /// Create a successful command result\n    pub fn success(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            success: true,\n            message: message.into(),\n            data: None,\n        }\n    }\n\n    /// Create a successful command result with data\n    pub fn success_with_data(message: impl Into\u003cString\u003e, data: serde_yaml::Value) -\u003e Self {\n        Self {\n            success: true,\n            message: message.into(),\n            data: Some(data),\n        }\n    }\n\n    /// Create a failed command result\n    pub fn failure(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            success: false,\n            message: message.into(),\n            data: None,\n        }\n    }\n\n    /// Create a failed command result with data\n    pub fn failure_with_data(message: impl Into\u003cString\u003e, data: serde_yaml::Value) -\u003e Self {\n        Self {\n            success: false,\n            message: message.into(),\n            data: Some(data),\n        }\n    }\n}\n\n/// A command handler that processes commands\npub trait CommandHandler\u003cC: Command\u003e {\n    /// Handle the command\n    fn handle(\u0026self, command: \u0026C) -\u003e Result\u003cCommandResult, DomainError\u003e;\n}\n\n/// A command bus that routes commands to handlers\npub struct CommandBus {\n    handlers: std::collections::HashMap\u003cString, Box\u003cdyn CommandHandler\u003cdyn Command\u003e\u003e\u003e,\n}\n\nimpl CommandBus {\n    /// Create a new command bus\n    pub fn new() -\u003e Self {\n        Self {\n            handlers: std::collections::HashMap::new(),\n        }\n    }\n\n    /// Register a command handler\n    pub fn register_handler\u003cC, H\u003e(\u0026mut self, _handler: H)\n    where\n        C: Command + 'static,           // 'static necessário para Box\u003cdyn\u003e\n        H: CommandHandler\u003cC\u003e + 'static, // 'static necessário para Box\u003cdyn\u003e\n    {\n        let type_name = std::any::type_name::\u003cC\u003e();\n        // For now, we'll store the handler as a generic CommandHandler\n        // In a real implementation, you might want to use a different approach\n        // that can properly handle the type conversion\n        println!(\"Registered handler for command type: {}\", type_name);\n    }\n\n    /// Execute a command\n    pub fn execute\u003cC\u003e(\u0026self, command: \u0026C) -\u003e Result\u003cCommandResult, DomainError\u003e\n    where\n        C: Command,\n    {\n        let type_name = std::any::type_name::\u003cC\u003e();\n\n        if let Some(_handler) = self.handlers.get(type_name) {\n            // This is a bit of a hack since we can't easily downcast\n            // In a real implementation, you might want to use a different approach\n            command.execute()\n        } else {\n            Err(DomainError::new(\n                crate::domain::shared::errors::DomainErrorKind::Generic {\n                    message: format!(\"No handler found for command: {}\", type_name),\n                },\n            ))\n        }\n    }\n}\n\nimpl Default for CommandBus {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A command that can be undone\npub trait UndoableCommand: Command {\n    /// Undo the command\n    fn undo(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e;\n\n    /// Check if the command can be undone\n    fn can_undo(\u0026self) -\u003e bool {\n        true\n    }\n}\n\n/// A command that can be redone\npub trait RedoableCommand: UndoableCommand {\n    /// Redo the command\n    fn redo(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e;\n}\n\n/// A command that can be validated\npub trait ValidatableCommand: Command {\n    /// Validate the command\n    fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e;\n\n    /// Get validation errors\n    fn validation_errors(\u0026self) -\u003e Vec\u003cString\u003e;\n}\n\n/// A command that can be authorized\npub trait AuthorizableCommand: Command {\n    /// Check if the command is authorized\n    fn is_authorized(\u0026self, user: \u0026str) -\u003e bool;\n\n    /// Get required permissions\n    fn required_permissions(\u0026self) -\u003e Vec\u003cString\u003e;\n}\n\n/// A command that can be logged\npub trait LoggableCommand: Command {\n    /// Get the command log entry\n    fn log_entry(\u0026self) -\u003e CommandLogEntry;\n}\n\n/// A log entry for a command\n#[derive(Debug, Clone, PartialEq)]\npub struct CommandLogEntry {\n    pub timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    pub user: String,\n    pub command_name: String,\n    pub parameters: serde_yaml::Value,\n    pub result: Option\u003cCommandResult\u003e,\n}\n\nimpl CommandLogEntry {\n    /// Create a new command log entry\n    pub fn new(user: impl Into\u003cString\u003e, command_name: impl Into\u003cString\u003e, parameters: serde_yaml::Value) -\u003e Self {\n        Self {\n            timestamp: chrono::Utc::now(),\n            user: user.into(),\n            command_name: command_name.into(),\n            parameters,\n            result: None,\n        }\n    }\n\n    /// Set the command result\n    pub fn with_result(mut self, result: CommandResult) -\u003e Self {\n        self.result = Some(result);\n        self\n    }\n}\n\n/// A command that can be scheduled\npub trait SchedulableCommand: Command {\n    /// Get the scheduled execution time\n    fn scheduled_time(\u0026self) -\u003e Option\u003cchrono::DateTime\u003cchrono::Utc\u003e\u003e;\n\n    /// Check if the command should be executed now\n    fn should_execute_now(\u0026self) -\u003e bool {\n        if let Some(scheduled_time) = self.scheduled_time() {\n            chrono::Utc::now() \u003e= scheduled_time\n        } else {\n            true\n        }\n    }\n}\n\n/// A command that can be retried\npub trait RetryableCommand: Command {\n    /// Get the maximum number of retries\n    fn max_retries(\u0026self) -\u003e u32;\n\n    /// Get the current retry count\n    fn retry_count(\u0026self) -\u003e u32;\n\n    /// Check if the command can be retried\n    fn can_retry(\u0026self) -\u003e bool {\n        self.retry_count() \u003c self.max_retries()\n    }\n\n    /// Increment the retry count\n    fn increment_retry_count(\u0026mut self);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Mock command implementations for testing\n    #[derive(Debug)]\n    struct MockCommand {\n        name: String,\n        description: String,\n        can_execute: bool,\n        validation_result: Result\u003c(), DomainError\u003e,\n    }\n\n    impl MockCommand {\n        fn new(name: \u0026str, description: \u0026str) -\u003e Self {\n            Self {\n                name: name.to_string(),\n                description: description.to_string(),\n                can_execute: true,\n                validation_result: Ok(()),\n            }\n        }\n\n        fn with_can_execute(mut self, can_execute: bool) -\u003e Self {\n            self.can_execute = can_execute;\n            self\n        }\n\n        fn with_validation_result(mut self, result: Result\u003c(), DomainError\u003e) -\u003e Self {\n            self.validation_result = result;\n            self\n        }\n    }\n\n    impl Command for MockCommand {\n        fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            if self.can_execute {\n                Ok(CommandResult::success(\"Command executed successfully\"))\n            } else {\n                Err(DomainError::new(\n                    crate::domain::shared::errors::DomainErrorKind::Generic {\n                        message: \"Command cannot be executed\".to_string(),\n                    },\n                ))\n            }\n        }\n\n        fn name(\u0026self) -\u003e \u0026str {\n            \u0026self.name\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            \u0026self.description\n        }\n\n        fn can_execute(\u0026self) -\u003e bool {\n            self.can_execute\n        }\n\n        fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            match \u0026self.validation_result {\n                Ok(()) =\u003e Ok(()),\n                Err(_) =\u003e Err(DomainError::new(\n                    crate::domain::shared::errors::DomainErrorKind::ValidationError {\n                        field: \"test\".to_string(),\n                        message: \"Validation failed\".to_string(),\n                    },\n                )),\n            }\n        }\n    }\n\n    #[derive(Debug)]\n    struct MockUndoableCommand {\n        base: MockCommand,\n        can_undo: bool,\n    }\n\n    impl MockUndoableCommand {\n        fn new(name: \u0026str, description: \u0026str) -\u003e Self {\n            Self {\n                base: MockCommand::new(name, description),\n                can_undo: true,\n            }\n        }\n\n        fn with_can_undo(mut self, can_undo: bool) -\u003e Self {\n            self.can_undo = can_undo;\n            self\n        }\n    }\n\n    impl Command for MockUndoableCommand {\n        fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            self.base.execute()\n        }\n\n        fn name(\u0026self) -\u003e \u0026str {\n            self.base.name()\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            self.base.description()\n        }\n\n        fn can_execute(\u0026self) -\u003e bool {\n            self.base.can_execute()\n        }\n\n        fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            self.base.validate()\n        }\n    }\n\n    impl UndoableCommand for MockUndoableCommand {\n        fn undo(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            if self.can_undo {\n                Ok(CommandResult::success(\"Command undone successfully\"))\n            } else {\n                Err(DomainError::new(\n                    crate::domain::shared::errors::DomainErrorKind::Generic {\n                        message: \"Command cannot be undone\".to_string(),\n                    },\n                ))\n            }\n        }\n\n        fn can_undo(\u0026self) -\u003e bool {\n            self.can_undo\n        }\n    }\n\n    #[derive(Debug)]\n    struct MockRetryableCommand {\n        base: MockCommand,\n        max_retries: u32,\n        retry_count: u32,\n    }\n\n    impl MockRetryableCommand {\n        fn new(name: \u0026str, description: \u0026str) -\u003e Self {\n            Self {\n                base: MockCommand::new(name, description),\n                max_retries: 3,\n                retry_count: 0,\n            }\n        }\n\n        fn with_max_retries(mut self, max_retries: u32) -\u003e Self {\n            self.max_retries = max_retries;\n            self\n        }\n\n        fn with_retry_count(mut self, retry_count: u32) -\u003e Self {\n            self.retry_count = retry_count;\n            self\n        }\n    }\n\n    impl Command for MockRetryableCommand {\n        fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            self.base.execute()\n        }\n\n        fn name(\u0026self) -\u003e \u0026str {\n            self.base.name()\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            self.base.description()\n        }\n\n        fn can_execute(\u0026self) -\u003e bool {\n            self.base.can_execute()\n        }\n\n        fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            self.base.validate()\n        }\n    }\n\n    impl RetryableCommand for MockRetryableCommand {\n        fn max_retries(\u0026self) -\u003e u32 {\n            self.max_retries\n        }\n\n        fn retry_count(\u0026self) -\u003e u32 {\n            self.retry_count\n        }\n\n        fn can_retry(\u0026self) -\u003e bool {\n            self.retry_count \u003c self.max_retries()\n        }\n\n        fn increment_retry_count(\u0026mut self) {\n            self.retry_count += 1;\n        }\n    }\n\n    // Tests for CommandResult\n    #[test]\n    fn test_command_result_success() {\n        let result = CommandResult::success(\"Operation completed\");\n        assert!(result.success);\n        assert_eq!(result.message, \"Operation completed\");\n        assert!(result.data.is_none());\n    }\n\n    #[test]\n    fn test_command_result_success_with_data() {\n        let data = serde_yaml::to_value(\"test data\").unwrap();\n        let result = CommandResult::success_with_data(\"Operation completed\", data.clone());\n        assert!(result.success);\n        assert_eq!(result.message, \"Operation completed\");\n        assert_eq!(result.data, Some(data));\n    }\n\n    #[test]\n    fn test_command_result_failure() {\n        let result = CommandResult::failure(\"Operation failed\");\n        assert!(!result.success);\n        assert_eq!(result.message, \"Operation failed\");\n        assert!(result.data.is_none());\n    }\n\n    #[test]\n    fn test_command_result_failure_with_data() {\n        let data = serde_yaml::to_value(\"error details\").unwrap();\n        let result = CommandResult::failure_with_data(\"Operation failed\", data.clone());\n        assert!(!result.success);\n        assert_eq!(result.message, \"Operation failed\");\n        assert_eq!(result.data, Some(data));\n    }\n\n    #[test]\n    fn test_command_result_debug_formatting() {\n        let result = CommandResult::success(\"Test message\");\n        let debug_str = format!(\"{:?}\", result);\n        assert!(debug_str.contains(\"Test message\"));\n        assert!(debug_str.contains(\"success: true\"));\n    }\n\n    #[test]\n    fn test_command_result_clone() {\n        let result = CommandResult::success(\"Original message\");\n        let cloned = result.clone();\n        assert_eq!(result.success, cloned.success);\n        assert_eq!(result.message, cloned.message);\n        assert_eq!(result.data, cloned.data);\n    }\n\n    // Tests for Command trait\n    #[test]\n    fn test_mock_command_basic_functionality() {\n        let command = MockCommand::new(\"test\", \"Test command\");\n        assert_eq!(command.name(), \"test\");\n        assert_eq!(command.description(), \"Test command\");\n        assert!(command.can_execute());\n    }\n\n    #[test]\n    fn test_mock_command_execute_success() {\n        let command = MockCommand::new(\"test\", \"Test command\");\n        let result = command.execute().unwrap();\n        assert!(result.success);\n        assert_eq!(result.message, \"Command executed successfully\");\n    }\n\n    #[test]\n    fn test_mock_command_execute_failure() {\n        let command = MockCommand::new(\"test\", \"Test command\").with_can_execute(false);\n        let result = command.execute();\n        assert!(result.is_err());\n        \n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Command cannot be executed\"));\n        }\n    }\n\n    #[test]\n    fn test_mock_command_validation_success() {\n        let command = MockCommand::new(\"test\", \"Test command\");\n        assert!(command.validate().is_ok());\n    }\n\n    #[test]\n    fn test_mock_command_validation_failure() {\n        let command = MockCommand::new(\"test\", \"Test command\")\n            .with_validation_result(Err(DomainError::new(\n                crate::domain::shared::errors::DomainErrorKind::ValidationError {\n                    field: \"test\".to_string(),\n                    message: \"Validation failed\".to_string(),\n                },\n            )));\n        let result = command.validate();\n        assert!(result.is_err());\n        \n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Validation failed\"));\n        }\n    }\n\n    // Tests for UndoableCommand trait\n    #[test]\n    fn test_undoable_command_can_undo() {\n        let command = MockUndoableCommand::new(\"test\", \"Test command\");\n        assert!(command.can_undo());\n    }\n\n    #[test]\n    fn test_undoable_command_undo_success() {\n        let command = MockUndoableCommand::new(\"test\", \"Test command\");\n        let result = command.undo().unwrap();\n        assert!(result.success);\n        assert_eq!(result.message, \"Command undone successfully\");\n    }\n\n    #[test]\n    fn test_undoable_command_undo_failure() {\n        let command = MockUndoableCommand::new(\"test\", \"Test command\").with_can_undo(false);\n        let result = command.undo();\n        assert!(result.is_err());\n        \n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Command cannot be undone\"));\n        }\n    }\n\n    // Tests for RetryableCommand trait\n    #[test]\n    fn test_retryable_command_can_retry() {\n        let command = MockRetryableCommand::new(\"test\", \"Test command\");\n        assert!(command.can_retry());\n        assert_eq!(command.retry_count(), 0);\n        assert_eq!(command.max_retries(), 3);\n    }\n\n    #[test]\n    fn test_retryable_command_retry_count() {\n        let command = MockRetryableCommand::new(\"test\", \"Test command\")\n            .with_retry_count(2);\n        assert_eq!(command.retry_count(), 2);\n        assert!(command.can_retry());\n    }\n\n    #[test]\n    fn test_retryable_command_increment_retry_count() {\n        let mut command = MockRetryableCommand::new(\"test\", \"Test command\");\n        assert_eq!(command.retry_count(), 0);\n        command.increment_retry_count();\n        assert_eq!(command.retry_count(), 1);\n        command.increment_retry_count();\n        assert_eq!(command.retry_count(), 2);\n    }\n\n    #[test]\n    fn test_retryable_command_cannot_retry() {\n        let mut command = MockRetryableCommand::new(\"test\", \"Test command\")\n            .with_retry_count(3);\n        assert!(!command.can_retry());\n        command.increment_retry_count();\n        assert!(!command.can_retry());\n    }\n\n    // Tests for SchedulableCommand trait\n    #[test]\n    fn test_schedulable_command_should_execute_now_no_schedule() {\n        let command = MockSchedulableCommand::new(\"test\", \"Test command\");\n        assert!(command.should_execute_now());\n    }\n\n    #[test]\n    fn test_schedulable_command_should_execute_now_past_schedule() {\n        let past_time = chrono::Utc::now() - chrono::Duration::hours(1);\n        let command = MockSchedulableCommand::new(\"test\", \"Test command\")\n            .with_scheduled_time(past_time);\n        assert!(command.should_execute_now());\n    }\n\n    #[test]\n    fn test_schedulable_command_should_execute_now_future_schedule() {\n        let future_time = chrono::Utc::now() + chrono::Duration::hours(1);\n        let command = MockSchedulableCommand::new(\"test\", \"Test command\")\n            .with_scheduled_time(future_time);\n        assert!(!command.should_execute_now());\n    }\n\n    // Tests for ValidatableCommand trait\n    #[test]\n    fn test_validatable_command_trait() {\n        let command = MockValidatableCommand::new(\"test\", \"Test command\");\n        assert!(\u003cMockValidatableCommand as Command\u003e::validate(\u0026command).is_ok());\n        let errors = command.validation_errors();\n        assert!(errors.is_empty());\n    }\n\n    // Tests for AuthorizableCommand trait\n    #[test]\n    fn test_authorizable_command_trait() {\n        let command = MockAuthorizableCommand::new(\"test\", \"Test command\");\n        assert!(command.is_authorized(\"admin\"));\n        assert!(!command.is_authorized(\"user\"));\n        let permissions = command.required_permissions();\n        assert_eq!(permissions.len(), 2);\n        assert!(permissions.contains(\u0026\"admin\".to_string()));\n        assert!(permissions.contains(\u0026\"write\".to_string()));\n    }\n\n    // Tests for LoggableCommand trait\n    #[test]\n    fn test_loggable_command_trait() {\n        let command = MockLoggableCommand::new(\"test\", \"Test command\");\n        let log_entry = command.log_entry();\n        assert_eq!(log_entry.command_name, \"test\");\n        assert_eq!(log_entry.user, \"test_user\");\n        assert!(log_entry.result.is_none());\n    }\n\n    // Tests for CommandBus\n    #[test]\n    fn test_command_bus_new() {\n        let bus = CommandBus::new();\n        assert!(bus.handlers.is_empty());\n    }\n\n    #[test]\n    fn test_command_bus_default() {\n        let bus = CommandBus::default();\n        assert!(bus.handlers.is_empty());\n    }\n\n    #[test]\n    fn test_command_bus_execute_no_handler() {\n        let bus = CommandBus::new();\n        let command = MockCommand::new(\"test\", \"Test command\");\n        let result = bus.execute(\u0026command);\n        assert!(result.is_err());\n        \n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"No handler found for command\"));\n        }\n    }\n\n    // Tests for CommandLogEntry\n    #[test]\n    fn test_command_log_entry_new() {\n        let params = serde_yaml::to_value(\"test_params\").unwrap();\n        let entry = CommandLogEntry::new(\"test_user\", \"test_command\", params.clone());\n        assert_eq!(entry.user, \"test_user\");\n        assert_eq!(entry.command_name, \"test_command\");\n        assert_eq!(entry.parameters, params);\n        assert!(entry.result.is_none());\n    }\n\n    #[test]\n    fn test_command_log_entry_with_result() {\n        let params = serde_yaml::to_value(\"test_params\").unwrap();\n        let result = CommandResult::success(\"Success\");\n        let entry = CommandLogEntry::new(\"test_user\", \"test_command\", params)\n            .with_result(result.clone());\n        assert_eq!(entry.result, Some(result));\n    }\n\n    #[test]\n    fn test_command_log_entry_debug_formatting() {\n        let params = serde_yaml::to_value(\"test_params\").unwrap();\n        let entry = CommandLogEntry::new(\"test_user\", \"test_command\", params);\n        let debug_str = format!(\"{:?}\", entry);\n        assert!(debug_str.contains(\"test_user\"));\n        assert!(debug_str.contains(\"test_command\"));\n    }\n\n    #[test]\n    fn test_command_log_entry_clone() {\n        let params = serde_yaml::to_value(\"test_params\").unwrap();\n        let entry = CommandLogEntry::new(\"test_user\", \"test_command\", params);\n        let cloned = entry.clone();\n        assert_eq!(entry.user, cloned.user);\n        assert_eq!(entry.command_name, cloned.command_name);\n        assert_eq!(entry.parameters, cloned.parameters);\n        assert_eq!(entry.result, cloned.result);\n    }\n\n    // Additional mock implementations for comprehensive testing\n    #[derive(Debug)]\n    struct MockSchedulableCommand {\n        base: MockCommand,\n        scheduled_time: Option\u003cchrono::DateTime\u003cchrono::Utc\u003e\u003e,\n    }\n\n    impl MockSchedulableCommand {\n        fn new(name: \u0026str, description: \u0026str) -\u003e Self {\n            Self {\n                base: MockCommand::new(name, description),\n                scheduled_time: None,\n            }\n        }\n\n        fn with_scheduled_time(mut self, time: chrono::DateTime\u003cchrono::Utc\u003e) -\u003e Self {\n            self.scheduled_time = Some(time);\n            self\n        }\n    }\n\n    impl Command for MockSchedulableCommand {\n        fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            self.base.execute()\n        }\n\n        fn name(\u0026self) -\u003e \u0026str {\n            self.base.name()\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            self.base.description()\n        }\n\n        fn can_execute(\u0026self) -\u003e bool {\n            self.base.can_execute()\n        }\n\n        fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            self.base.validate()\n        }\n    }\n\n    impl SchedulableCommand for MockSchedulableCommand {\n        fn scheduled_time(\u0026self) -\u003e Option\u003cchrono::DateTime\u003cchrono::Utc\u003e\u003e {\n            self.scheduled_time\n        }\n    }\n\n    #[derive(Debug)]\n    struct MockValidatableCommand {\n        base: MockCommand,\n    }\n\n    impl MockValidatableCommand {\n        fn new(name: \u0026str, description: \u0026str) -\u003e Self {\n            Self {\n                base: MockCommand::new(name, description),\n            }\n        }\n    }\n\n    impl Command for MockValidatableCommand {\n        fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            self.base.execute()\n        }\n\n        fn name(\u0026self) -\u003e \u0026str {\n            self.base.name()\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            self.base.description()\n        }\n\n        fn can_execute(\u0026self) -\u003e bool {\n            self.base.can_execute()\n        }\n\n        fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            self.base.validate()\n        }\n    }\n\n    impl ValidatableCommand for MockValidatableCommand {\n        fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            self.base.validate()\n        }\n\n        fn validation_errors(\u0026self) -\u003e Vec\u003cString\u003e {\n            match self.base.validate() {\n                Ok(()) =\u003e Vec::new(),\n                Err(err) =\u003e vec![err.to_string()],\n            }\n        }\n    }\n\n    #[derive(Debug)]\n    struct MockAuthorizableCommand {\n        base: MockCommand,\n    }\n\n    impl MockAuthorizableCommand {\n        fn new(name: \u0026str, description: \u0026str) -\u003e Self {\n            Self {\n                base: MockCommand::new(name, description),\n            }\n        }\n    }\n\n    impl Command for MockAuthorizableCommand {\n        fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            self.base.execute()\n        }\n\n        fn name(\u0026self) -\u003e \u0026str {\n            self.base.name()\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            self.base.description()\n        }\n\n        fn can_execute(\u0026self) -\u003e bool {\n            self.base.can_execute()\n        }\n\n        fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            self.base.validate()\n        }\n    }\n\n    impl AuthorizableCommand for MockAuthorizableCommand {\n        fn is_authorized(\u0026self, user: \u0026str) -\u003e bool {\n            user == \"admin\"\n        }\n\n        fn required_permissions(\u0026self) -\u003e Vec\u003cString\u003e {\n            vec![\"admin\".to_string(), \"write\".to_string()]\n        }\n    }\n\n    #[derive(Debug)]\n    struct MockLoggableCommand {\n        base: MockCommand,\n    }\n\n    impl MockLoggableCommand {\n        fn new(name: \u0026str, description: \u0026str) -\u003e Self {\n            Self {\n                base: MockCommand::new(name, description),\n            }\n        }\n    }\n\n    impl Command for MockLoggableCommand {\n        fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            self.base.execute()\n        }\n\n        fn name(\u0026self) -\u003e \u0026str {\n            self.base.name()\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            self.base.description()\n        }\n\n        fn can_execute(\u0026self) -\u003e bool {\n            self.base.can_execute()\n        }\n\n        fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            self.base.validate()\n        }\n    }\n\n    impl LoggableCommand for MockLoggableCommand {\n        fn log_entry(\u0026self) -\u003e CommandLogEntry {\n            CommandLogEntry::new(\"test_user\", self.name(), serde_yaml::to_value(\"{}\").unwrap())\n        }\n    }\n\n    // Tests for RedoableCommand trait\n    #[test]\n    fn test_redoable_command_redo_success() {\n        let command = MockRedoableCommand::new(\"test\", \"Test command\");\n        let result = command.redo().unwrap();\n        assert!(result.success);\n        assert_eq!(result.message, \"Command redone successfully\");\n    }\n\n    #[test]\n    fn test_redoable_command_redo_failure() {\n        let command = MockRedoableCommand::new(\"test\", \"Test command\").with_can_redo(false);\n        let result = command.redo();\n        assert!(result.is_err());\n        \n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Command cannot be redone\"));\n        }\n    }\n\n    #[derive(Debug)]\n    struct MockRedoableCommand {\n        base: MockUndoableCommand,\n        can_redo: bool,\n    }\n\n    impl MockRedoableCommand {\n        fn new(name: \u0026str, description: \u0026str) -\u003e Self {\n            Self {\n                base: MockUndoableCommand::new(name, description),\n                can_redo: true,\n            }\n        }\n\n        fn with_can_redo(mut self, can_redo: bool) -\u003e Self {\n            self.can_redo = can_redo;\n            self\n        }\n    }\n\n    impl Command for MockRedoableCommand {\n        fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            self.base.execute()\n        }\n\n        fn name(\u0026self) -\u003e \u0026str {\n            self.base.name()\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            self.base.description()\n        }\n\n        fn can_execute(\u0026self) -\u003e bool {\n            self.base.can_execute()\n        }\n\n        fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            self.base.validate()\n        }\n    }\n\n    impl UndoableCommand for MockRedoableCommand {\n        fn undo(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            self.base.undo()\n        }\n\n        fn can_undo(\u0026self) -\u003e bool {\n            self.base.can_undo()\n        }\n    }\n\n    impl RedoableCommand for MockRedoableCommand {\n        fn redo(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            if self.can_redo {\n                Ok(CommandResult::success(\"Command redone successfully\"))\n            } else {\n                Err(DomainError::new(\n                    crate::domain::shared::errors::DomainErrorKind::Generic {\n                        message: \"Command cannot be redone\".to_string(),\n                    },\n                ))\n            }\n        }\n    }\n\n    // Tests for CommandBus register_handler (even though it's not fully implemented)\n    #[test]\n    fn test_command_bus_register_handler() {\n        let mut bus = CommandBus::new();\n        // This test just ensures the method doesn't panic\n        bus.register_handler::\u003cMockCommand, MockCommandHandler\u003e(MockCommandHandler);\n    }\n\n    #[derive(Debug)]\n    struct MockCommandHandler;\n\n    impl CommandHandler\u003cMockCommand\u003e for MockCommandHandler {\n        fn handle(\u0026self, _command: \u0026MockCommand) -\u003e Result\u003cCommandResult, DomainError\u003e {\n            Ok(CommandResult::success(\"Handled by mock handler\"))\n        }\n    }\n\n    // Tests for edge cases and error conditions\n    #[test]\n    fn test_command_result_with_complex_data() {\n        let complex_data = serde_yaml::to_value(vec![1, 2, 3]).unwrap();\n        let result = CommandResult::success_with_data(\"Complex operation\", complex_data.clone());\n        assert!(result.success);\n        assert_eq!(result.data, Some(complex_data));\n    }\n\n    #[test]\n    fn test_command_log_entry_timestamp() {\n        let params = serde_yaml::to_value(\"test_params\").unwrap();\n        let entry = CommandLogEntry::new(\"test_user\", \"test_command\", params);\n        let now = chrono::Utc::now();\n        let diff = now.signed_duration_since(entry.timestamp);\n        // Should be within 1 second\n        assert!(diff.num_seconds() \u003c= 1);\n    }\n\n    #[test]\n    fn test_command_bus_handlers_initialization() {\n        let bus = CommandBus::new();\n        assert_eq!(bus.handlers.len(), 0);\n    }\n\n    // Additional tests for better coverage\n    #[test]\n    fn test_command_with_metadata() {\n        #[derive(Debug)]\n        struct MetadataCommand {\n            name: String,\n            description: String,\n            metadata: HashMap\u003cString, String\u003e,\n        }\n\n        impl Command for MetadataCommand {\n            fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n                let metadata_yaml = serde_yaml::to_value(\u0026self.metadata).unwrap();\n                Ok(CommandResult::success_with_data(\n                    \"Command executed with metadata\",\n                    metadata_yaml,\n                ))\n            }\n\n            fn name(\u0026self) -\u003e \u0026str {\n                \u0026self.name\n            }\n\n            fn description(\u0026self) -\u003e \u0026str {\n                \u0026self.description\n            }\n        }\n\n        let mut metadata = HashMap::new();\n        metadata.insert(\"priority\".to_string(), \"high\".to_string());\n        metadata.insert(\"category\".to_string(), \"test\".to_string());\n\n        let command = MetadataCommand {\n            name: \"metadata_test\".to_string(),\n            description: \"Test command with metadata\".to_string(),\n            metadata,\n        };\n\n        let result = command.execute().unwrap();\n        assert!(result.success);\n        assert!(result.data.is_some());\n        \n        if let Some(data) = result.data {\n            let metadata_map: HashMap\u003cString, String\u003e = serde_yaml::from_value(data).unwrap();\n            assert_eq!(metadata_map.get(\"priority\"), Some(\u0026\"high\".to_string()));\n            assert_eq!(metadata_map.get(\"category\"), Some(\u0026\"test\".to_string()));\n        }\n    }\n\n    #[test]\n    fn test_command_with_validation_rules() {\n        #[derive(Debug)]\n        struct ValidatedCommand {\n            name: String,\n            description: String,\n            value: i32,\n            max_value: i32,\n        }\n\n        impl Command for ValidatedCommand {\n            fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n                if self.value \u003e self.max_value {\n                    Err(DomainError::new(\n                        crate::domain::shared::errors::DomainErrorKind::ValidationError {\n                            field: \"value\".to_string(),\n                            message: format!(\"Value {} exceeds maximum {}\", self.value, self.max_value),\n                        },\n                    ))\n                } else {\n                    Ok(CommandResult::success(\"Value within limits\"))\n                }\n            }\n\n            fn name(\u0026self) -\u003e \u0026str {\n                \u0026self.name\n            }\n\n            fn description(\u0026self) -\u003e \u0026str {\n                \u0026self.description\n            }\n\n            fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n                if self.value \u003c 0 {\n                    Err(DomainError::new(\n                        crate::domain::shared::errors::DomainErrorKind::ValidationError {\n                            field: \"value\".to_string(),\n                            message: \"Value cannot be negative\".to_string(),\n                        },\n                    ))\n                } else {\n                    Ok(())\n                }\n            }\n        }\n\n        // Test valid command\n        let valid_command = ValidatedCommand {\n            name: \"valid_test\".to_string(),\n            description: \"Valid command test\".to_string(),\n            value: 50,\n            max_value: 100,\n        };\n\n        assert!(valid_command.validate().is_ok());\n        let result = valid_command.execute().unwrap();\n        assert!(result.success);\n\n        // Test invalid command (value too high)\n        let invalid_command = ValidatedCommand {\n            name: \"invalid_test\".to_string(),\n            description: \"Invalid command test\".to_string(),\n            value: 150,\n            max_value: 100,\n        };\n\n        let result = invalid_command.execute();\n        assert!(result.is_err());\n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"exceeds maximum\"));\n        }\n\n        // Test negative value validation\n        let negative_command = ValidatedCommand {\n            name: \"negative_test\".to_string(),\n            description: \"Negative command test\".to_string(),\n            value: -10,\n            max_value: 100,\n        };\n\n        let result = negative_command.validate();\n        assert!(result.is_err());\n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"cannot be negative\"));\n        }\n    }\n\n    #[test]\n    fn test_command_with_conditional_execution() {\n        #[derive(Debug)]\n        struct ConditionalCommand {\n            name: String,\n            description: String,\n            should_execute: bool,\n            condition_met: bool,\n        }\n\n        impl Command for ConditionalCommand {\n            fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n                if !self.should_execute {\n                    return Err(DomainError::new(\n                        crate::domain::shared::errors::DomainErrorKind::Generic {\n                            message: \"Command execution disabled\".to_string(),\n                        },\n                    ));\n                }\n\n                if !self.condition_met {\n                    return Err(DomainError::new(\n                        crate::domain::shared::errors::DomainErrorKind::Generic {\n                            message: \"Condition not met\".to_string(),\n                        },\n                    ));\n                }\n\n                Ok(CommandResult::success(\"Conditional command executed\"))\n            }\n\n            fn name(\u0026self) -\u003e \u0026str {\n                \u0026self.name\n            }\n\n            fn description(\u0026self) -\u003e \u0026str {\n                \u0026self.description\n            }\n\n            fn can_execute(\u0026self) -\u003e bool {\n                self.should_execute \u0026\u0026 self.condition_met\n            }\n        }\n\n        // Test successful execution\n        let success_command = ConditionalCommand {\n            name: \"success_test\".to_string(),\n            description: \"Success test\".to_string(),\n            should_execute: true,\n            condition_met: true,\n        };\n\n        assert!(success_command.can_execute());\n        let result = success_command.execute().unwrap();\n        assert!(result.success);\n\n        // Test execution disabled\n        let disabled_command = ConditionalCommand {\n            name: \"disabled_test\".to_string(),\n            description: \"Disabled test\".to_string(),\n            should_execute: false,\n            condition_met: true,\n        };\n\n        assert!(!disabled_command.can_execute());\n        let result = disabled_command.execute();\n        assert!(result.is_err());\n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"execution disabled\"));\n        }\n\n        // Test condition not met\n        let condition_failed_command = ConditionalCommand {\n            name: \"condition_failed_test\".to_string(),\n            description: \"Condition failed test\".to_string(),\n            should_execute: true,\n            condition_met: false,\n        };\n\n        assert!(!condition_failed_command.can_execute());\n        let result = condition_failed_command.execute();\n        assert!(result.is_err());\n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Condition not met\"));\n        }\n    }\n\n    #[test]\n    fn test_command_with_retry_logic() {\n        #[derive(Debug)]\n        struct RetryableCommand {\n            name: String,\n            description: String,\n            max_attempts: u32,\n            current_attempt: u32,\n            success_on_attempt: u32,\n        }\n\n        impl Command for RetryableCommand {\n            fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n                if self.current_attempt \u003e= self.max_attempts {\n                    return Err(DomainError::new(\n                        crate::domain::shared::errors::DomainErrorKind::Generic {\n                            message: \"Max attempts exceeded\".to_string(),\n                        },\n                    ));\n                }\n\n                if self.current_attempt == self.success_on_attempt {\n                    Ok(CommandResult::success(\"Command succeeded on retry\"))\n                } else {\n                    Err(DomainError::new(\n                        crate::domain::shared::errors::DomainErrorKind::Generic {\n                            message: format!(\"Attempt {} failed\", self.current_attempt),\n                        },\n                    ))\n                }\n            }\n\n            fn name(\u0026self) -\u003e \u0026str {\n                \u0026self.name\n            }\n\n            fn description(\u0026self) -\u003e \u0026str {\n                \u0026self.description\n            }\n        }\n\n        // Test command that succeeds on first attempt\n        let first_attempt_success = RetryableCommand {\n            name: \"first_success\".to_string(),\n            description: \"First attempt success\".to_string(),\n            max_attempts: 3,\n            current_attempt: 0,\n            success_on_attempt: 0,\n        };\n\n        let result = first_attempt_success.execute().unwrap();\n        assert!(result.success);\n\n        // Test command that succeeds on retry\n        let retry_success = RetryableCommand {\n            name: \"retry_success\".to_string(),\n            description: \"Retry success\".to_string(),\n            max_attempts: 3,\n            current_attempt: 2,\n            success_on_attempt: 2,\n        };\n\n        let result = retry_success.execute().unwrap();\n        assert!(result.success);\n\n        // Test command that fails all attempts\n        let all_failed = RetryableCommand {\n            name: \"all_failed\".to_string(),\n            description: \"All attempts failed\".to_string(),\n            max_attempts: 3,\n            current_attempt: 3,\n            success_on_attempt: 5, // Never reached\n        };\n\n        let result = all_failed.execute();\n        assert!(result.is_err());\n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Max attempts exceeded\"));\n        }\n    }\n\n    #[test]\n    fn test_command_with_async_behavior() {\n        #[derive(Debug)]\n        struct AsyncCommand {\n            name: String,\n            description: String,\n            delay_ms: u64,\n        }\n\n        impl Command for AsyncCommand {\n            fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n                // Simulate async behavior with a small delay\n                std::thread::sleep(std::time::Duration::from_millis(self.delay_ms));\n                Ok(CommandResult::success(\"Async command completed\"))\n            }\n\n            fn name(\u0026self) -\u003e \u0026str {\n                \u0026self.name\n            }\n\n            fn description(\u0026self) -\u003e \u0026str {\n                \u0026self.description\n            }\n        }\n\n        let async_command = AsyncCommand {\n            name: \"async_test\".to_string(),\n            description: \"Async command test\".to_string(),\n            delay_ms: 10, // Small delay for testing\n        };\n\n        let result = async_command.execute().unwrap();\n        assert!(result.success);\n        assert_eq!(result.message, \"Async command completed\");\n    }\n\n    #[test]\n    fn test_command_with_resource_management() {\n        #[derive(Debug)]\n        struct ResourceCommand {\n            name: String,\n            description: String,\n            resource_id: String,\n            resource_available: bool,\n        }\n\n        impl Command for ResourceCommand {\n            fn execute(\u0026self) -\u003e Result\u003cCommandResult, DomainError\u003e {\n                if !self.resource_available {\n                    return Err(DomainError::new(\n                        crate::domain::shared::errors::DomainErrorKind::Generic {\n                            message: format!(\"Resource {} not available\", self.resource_id),\n                        },\n                    ));\n                }\n\n                Ok(CommandResult::success_with_data(\n                    \"Resource acquired successfully\",\n                    serde_yaml::to_value(\u0026self.resource_id).unwrap(),\n                ))\n            }\n\n            fn name(\u0026self) -\u003e \u0026str {\n                \u0026self.name\n            }\n\n            fn description(\u0026self) -\u003e \u0026str {\n                \u0026self.description\n            }\n        }\n\n        // Test with available resource\n        let available_resource_command = ResourceCommand {\n            name: \"available_resource\".to_string(),\n            description: \"Available resource test\".to_string(),\n            resource_id: \"res-001\".to_string(),\n            resource_available: true,\n        };\n\n        let result = available_resource_command.execute().unwrap();\n        assert!(result.success);\n        assert!(result.data.is_some());\n\n        // Test with unavailable resource\n        let unavailable_resource_command = ResourceCommand {\n            name: \"unavailable_resource\".to_string(),\n            description: \"Unavailable resource test\".to_string(),\n            resource_id: \"res-002\".to_string(),\n            resource_available: false,\n        };\n\n        let result = unavailable_resource_command.execute();\n        assert!(result.is_err());\n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"not available\"));\n        }\n    }\n}\n","traces":[{"line":16,"address":[1399696,1399744,1399712,1399728,1399760],"length":1,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[1399776,1399840,1399808,1399792,1399824],"length":1,"stats":{"Line":0}},{"line":22,"address":[1399816,1399800,1399784,1399832,1399848],"length":1,"stats":{"Line":0}},{"line":36,"address":[920672],"length":1,"stats":{"Line":1}},{"line":39,"address":[920702],"length":1,"stats":{"Line":1}},{"line":45,"address":[920816,921031],"length":1,"stats":{"Line":1}},{"line":48,"address":[920854],"length":1,"stats":{"Line":2}},{"line":49,"address":[920923],"length":1,"stats":{"Line":2}},{"line":54,"address":[921056],"length":1,"stats":{"Line":1}},{"line":57,"address":[921086],"length":1,"stats":{"Line":1}},{"line":63,"address":[921415,921200],"length":1,"stats":{"Line":1}},{"line":66,"address":[921238],"length":1,"stats":{"Line":1}},{"line":67,"address":[921307],"length":1,"stats":{"Line":1}},{"line":85,"address":[1819696],"length":1,"stats":{"Line":1}},{"line":87,"address":[1819710],"length":1,"stats":{"Line":1}},{"line":92,"address":[921468,921440],"length":1,"stats":{"Line":1}},{"line":97,"address":[921512,921452],"length":1,"stats":{"Line":2}},{"line":101,"address":[921522],"length":1,"stats":{"Line":1}},{"line":105,"address":[921616],"length":1,"stats":{"Line":1}},{"line":109,"address":[921658],"length":1,"stats":{"Line":1}},{"line":111,"address":[921678],"length":1,"stats":{"Line":1}},{"line":114,"address":[921748],"length":1,"stats":{"Line":0}},{"line":116,"address":[921941],"length":1,"stats":{"Line":1}},{"line":117,"address":[921881],"length":1,"stats":{"Line":1}},{"line":118,"address":[921758],"length":1,"stats":{"Line":1}},{"line":126,"address":[1819760],"length":1,"stats":{"Line":1}},{"line":127,"address":[1819768],"length":1,"stats":{"Line":1}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[922016,922488,922518],"length":1,"stats":{"Line":3}},{"line":186,"address":[922090],"length":1,"stats":{"Line":4}},{"line":187,"address":[922189],"length":1,"stats":{"Line":4}},{"line":188,"address":[922230],"length":1,"stats":{"Line":4}},{"line":195,"address":[1819792,1820061],"length":1,"stats":{"Line":1}},{"line":196,"address":[1820009,1819822],"length":1,"stats":{"Line":2}},{"line":197,"address":[1820038],"length":1,"stats":{"Line":1}},{"line":207,"address":[1399856],"length":1,"stats":{"Line":1}},{"line":208,"address":[1399868],"length":1,"stats":{"Line":3}},{"line":209,"address":[1399920],"length":1,"stats":{"Line":2}},{"line":211,"address":[1399954],"length":1,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}}],"covered":34,"coverable":43},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","shared","convertable.rs"],"content":"/// A trait for objects that can be converted to and from other types\npub trait Convertible\u003cT\u003e {\n    /// Convert self to the target type\n    fn to(\u0026self) -\u003e T;\n\n    /// Create self from the source type\n    fn from(source: T) -\u003e Self;\n}\n\n/// A trait for objects that can be converted to other types\npub trait Into\u003cT\u003e {\n    /// Convert self into the target type\n    fn into(self) -\u003e T;\n}\n\n/// A trait for objects that can be created from other types\npub trait From\u003cT\u003e {\n    /// Create self from the source type\n    fn from(source: T) -\u003e Self;\n}\n\n// Implementação padrão para tipos que implementam From\nimpl\u003cT, U\u003e Into\u003cU\u003e for T\nwhere\n    U: From\u003cT\u003e,\n{\n    fn into(self) -\u003e U {\n        U::from(self)\n    }\n}\n\n// Implementação padrão para tipos que implementam Into\nimpl\u003cT, U\u003e From\u003cT\u003e for U\nwhere\n    T: Into\u003cU\u003e,\n{\n    fn from(source: T) -\u003e Self {\n        source.into()\n    }\n}\n\n// Convenience trait for bidirectional conversion\npub trait BidirectionalConvertible\u003cT\u003e: Convertible\u003cT\u003e + From\u003cT\u003e + Into\u003cT\u003e {}\n\n// Implementação automática para tipos que implementam From e Into\nimpl\u003cT, U\u003e BidirectionalConvertible\u003cU\u003e for T where T: Convertible\u003cU\u003e + From\u003cU\u003e + Into\u003cU\u003e {}\n\n// Extension trait for easier conversion\npub trait ConvertExt\u003cT\u003e {\n    /// Convert to the target type using the Convertible trait\n    fn convert_to(\u0026self) -\u003e T\n    where\n        Self: Convertible\u003cT\u003e;\n\n    /// Convert from the source type using the Convertible trait\n    fn convert_from(source: T) -\u003e Self\n    where\n        Self: Convertible\u003cT\u003e;\n}\n\nimpl\u003cT, U\u003e ConvertExt\u003cU\u003e for T\nwhere\n    T: Convertible\u003cU\u003e,\n{\n    fn convert_to(\u0026self) -\u003e U {\n        self.to()\n    }\n\n    fn convert_from(source: U) -\u003e Self {\n        Self::from(source)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Mock types for testing conversions\n    #[derive(Debug, Clone, PartialEq)]\n    struct SourceType {\n        value: String,\n    }\n\n    #[derive(Debug, Clone, PartialEq)]\n    struct TargetType {\n        data: String,\n    }\n\n    // Implement Convertible for SourceType -\u003e TargetType\n    impl Convertible\u003cTargetType\u003e for SourceType {\n        fn to(\u0026self) -\u003e TargetType {\n            TargetType {\n                data: self.value.clone(),\n            }\n        }\n\n        fn from(source: TargetType) -\u003e Self {\n            Self {\n                value: source.data,\n            }\n        }\n    }\n\n    // Test data structures\n    #[derive(Debug, Clone, PartialEq)]\n    struct SimpleSource {\n        id: u32,\n        name: String,\n    }\n\n    #[derive(Debug, Clone, PartialEq)]\n    struct SimpleTarget {\n        identifier: u32,\n        title: String,\n    }\n\n    // Implement Convertible for SimpleSource -\u003e SimpleTarget\n    impl Convertible\u003cSimpleTarget\u003e for SimpleSource {\n        fn to(\u0026self) -\u003e SimpleTarget {\n            SimpleTarget {\n                identifier: self.id,\n                title: self.name.clone(),\n            }\n        }\n\n        fn from(source: SimpleTarget) -\u003e Self {\n            Self {\n                id: source.identifier,\n                name: source.title,\n            }\n        }\n    }\n\n    // Tests for Convertible trait\n    #[test]\n    fn test_convertible_to() {\n        let source = SourceType {\n            value: \"test_value\".to_string(),\n        };\n        let target = source.to();\n        \n        assert_eq!(target.data, \"test_value\");\n    }\n\n    #[test]\n    fn test_convertible_from() {\n        let target = TargetType {\n            data: \"test_data\".to_string(),\n        };\n        let source = \u003cSourceType as Convertible\u003cTargetType\u003e\u003e::from(target);\n        \n        assert_eq!(source.value, \"test_data\");\n    }\n\n    #[test]\n    fn test_convertible_bidirectional() {\n        let original_source = SourceType {\n            value: \"original_value\".to_string(),\n        };\n        \n        // Convert to target\n        let target = original_source.to();\n        assert_eq!(target.data, \"original_value\");\n        \n        // Convert back to source\n        let new_source = \u003cSourceType as Convertible\u003cTargetType\u003e\u003e::from(target);\n        assert_eq!(new_source.value, \"original_value\");\n        \n        // Verify they are equal\n        assert_eq!(original_source, new_source);\n    }\n\n    // Tests for SimpleSource/SimpleTarget conversions\n    #[test]\n    fn test_simple_conversions() {\n        let source = SimpleSource {\n            id: 42,\n            name: \"Simple Test\".to_string(),\n        };\n        \n        // Test Convertible::to\n        let target = source.to();\n        assert_eq!(target.identifier, 42);\n        assert_eq!(target.title, \"Simple Test\");\n        \n        // Test Convertible::from\n        let new_source = \u003cSimpleSource as Convertible\u003cSimpleTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.id, 42);\n        assert_eq!(new_source.name, \"Simple Test\");\n    }\n\n    // Tests for complex conversion scenarios\n    #[test]\n    fn test_complex_conversion_scenarios() {\n        let sources = vec![\n            SourceType { value: \"first\".to_string() },\n            SourceType { value: \"second\".to_string() },\n            SourceType { value: \"third\".to_string() },\n        ];\n        \n        // Convert all sources to targets\n        let targets: Vec\u003cTargetType\u003e = sources.iter().map(|s| s.to()).collect();\n        \n        assert_eq!(targets.len(), 3);\n        assert_eq!(targets[0].data, \"first\");\n        assert_eq!(targets[1].data, \"second\");\n        assert_eq!(targets[2].data, \"third\");\n        \n        // Convert all targets back to sources\n        let new_sources: Vec\u003cSourceType\u003e = targets.into_iter().map(|t| \u003cSourceType as Convertible\u003cTargetType\u003e\u003e::from(t)).collect();\n        \n        assert_eq!(new_sources.len(), 3);\n        assert_eq!(new_sources[0].value, \"first\");\n        assert_eq!(new_sources[1].value, \"second\");\n        assert_eq!(new_sources[2].value, \"third\");\n    }\n\n    // Tests for trait bounds and generic usage\n    #[test]\n    fn test_trait_bounds() {\n        // Test that we can use Convertible as a trait bound\n        fn convert_anything\u003cT, U\u003e(source: \u0026T) -\u003e U\n        where\n            T: Convertible\u003cU\u003e,\n        {\n            source.to()\n        }\n        \n        let source = SourceType {\n            value: \"trait_bound\".to_string(),\n        };\n        let target = convert_anything(\u0026source);\n        \n        assert_eq!(target.data, \"trait_bound\");\n    }\n\n    // Tests for edge cases\n    #[test]\n    fn test_empty_string_conversion() {\n        let source = SourceType {\n            value: \"\".to_string(),\n        };\n        let target = source.to();\n        \n        assert_eq!(target.data, \"\");\n    }\n\n    #[test]\n    fn test_unicode_string_conversion() {\n        let source = SourceType {\n            value: \"🚀 🎯 💪\".to_string(),\n        };\n        let target = source.to();\n        \n        assert_eq!(target.data, \"🚀 🎯 💪\");\n    }\n\n    // Tests for ConvertExt trait\n    #[test]\n    fn test_convert_ext_convert_to() {\n        let source = SourceType {\n            value: \"ext_to\".to_string(),\n        };\n        let target = source.convert_to();\n        \n        assert_eq!(target.data, \"ext_to\");\n    }\n\n    #[test]\n    fn test_convert_ext_convert_from() {\n        let target = TargetType {\n            data: \"ext_from\".to_string(),\n        };\n        let source = SourceType::convert_from(target);\n        \n        assert_eq!(source.value, \"ext_from\");\n    }\n\n    // Tests for BidirectionalConvertible trait\n    #[test]\n    fn test_bidirectional_convertible() {\n        let _source = SourceType {\n            value: \"bidirectional\".to_string(),\n        };\n        \n        // Test that SourceType implements BidirectionalConvertible\u003cTargetType\u003e\n        // This test verifies that the trait can be used as a bound\n        assert!(true);\n    }\n\n    // Additional comprehensive tests for better coverage\n    #[test]\n    fn test_convertible_with_numeric_types() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct NumberSource {\n            value: i32,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct NumberTarget {\n            data: i64,\n        }\n\n        impl Convertible\u003cNumberTarget\u003e for NumberSource {\n            fn to(\u0026self) -\u003e NumberTarget {\n                NumberTarget {\n                    data: self.value as i64,\n                }\n            }\n\n            fn from(source: NumberTarget) -\u003e Self {\n                Self {\n                    value: source.data as i32,\n                }\n            }\n        }\n\n        let source = NumberSource { value: 42 };\n        let target = source.to();\n        assert_eq!(target.data, 42i64);\n\n        let new_source = \u003cNumberSource as Convertible\u003cNumberTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.value, 42);\n    }\n\n    #[test]\n    fn test_convertible_with_boolean_types() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct BoolSource {\n            value: bool,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct BoolTarget {\n            data: String,\n        }\n\n        impl Convertible\u003cBoolTarget\u003e for BoolSource {\n            fn to(\u0026self) -\u003e BoolTarget {\n                BoolTarget {\n                    data: if self.value { \"true\".to_string() } else { \"false\".to_string() },\n                }\n            }\n\n            fn from(source: BoolTarget) -\u003e Self {\n                Self {\n                    value: source.data == \"true\",\n                }\n            }\n        }\n\n        let source = BoolSource { value: true };\n        let target = source.to();\n        assert_eq!(target.data, \"true\");\n\n        let new_source = \u003cBoolSource as Convertible\u003cBoolTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.value, true);\n    }\n\n    #[test]\n    fn test_convertible_with_option_types() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct OptionSource {\n            value: Option\u003cString\u003e,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct OptionTarget {\n            data: String,\n        }\n\n        impl Convertible\u003cOptionTarget\u003e for OptionSource {\n            fn to(\u0026self) -\u003e OptionTarget {\n                OptionTarget {\n                    data: self.value.clone().unwrap_or_else(|| \"none\".to_string()),\n                }\n            }\n\n            fn from(source: OptionTarget) -\u003e Self {\n                Self {\n                    value: if source.data == \"none\" { None } else { Some(source.data) },\n                }\n            }\n        }\n\n        let source = OptionSource { value: Some(\"test\".to_string()) };\n        let target = source.to();\n        assert_eq!(target.data, \"test\");\n\n        let new_source = \u003cOptionSource as Convertible\u003cOptionTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.value, Some(\"test\".to_string()));\n    }\n\n    #[test]\n    fn test_convertible_with_vector_types() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct VectorSource {\n            values: Vec\u003ci32\u003e,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct VectorTarget {\n            data: Vec\u003cString\u003e,\n        }\n\n        impl Convertible\u003cVectorTarget\u003e for VectorSource {\n            fn to(\u0026self) -\u003e VectorTarget {\n                VectorTarget {\n                    data: self.values.iter().map(|v| v.to_string()).collect(),\n                }\n            }\n\n            fn from(source: VectorTarget) -\u003e Self {\n                Self {\n                    values: source.data.iter().filter_map(|s| s.parse().ok()).collect(),\n                }\n            }\n        }\n\n        let source = VectorSource { values: vec![1, 2, 3] };\n        let target = source.to();\n        assert_eq!(target.data, vec![\"1\", \"2\", \"3\"]);\n\n        let new_source = \u003cVectorSource as Convertible\u003cVectorTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.values, vec![1, 2, 3]);\n    }\n\n    #[test]\n    fn test_convertible_with_custom_error_handling() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct ErrorSource {\n            value: String,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct ErrorTarget {\n            data: Result\u003cString, String\u003e,\n        }\n\n        impl Convertible\u003cErrorTarget\u003e for ErrorSource {\n            fn to(\u0026self) -\u003e ErrorTarget {\n                if self.value.is_empty() {\n                    ErrorTarget {\n                        data: Err(\"Empty value not allowed\".to_string()),\n                    }\n                } else {\n                    ErrorTarget {\n                        data: Ok(self.value.clone()),\n                    }\n                }\n            }\n\n            fn from(source: ErrorTarget) -\u003e Self {\n                Self {\n                    value: source.data.unwrap_or_else(|_| \"default\".to_string()),\n                }\n            }\n        }\n\n        let source = ErrorSource { value: \"valid\".to_string() };\n        let target = source.to();\n        assert_eq!(target.data, Ok(\"valid\".to_string()));\n\n        let new_source = \u003cErrorSource as Convertible\u003cErrorTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.value, \"valid\");\n    }\n\n    #[test]\n    fn test_convertible_with_generic_constraints() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct GenericSource\u003cT: Clone + ToString\u003e {\n            value: T,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct GenericTarget {\n            data: String,\n        }\n\n        impl\u003cT: Clone + ToString\u003e Convertible\u003cGenericTarget\u003e for GenericSource\u003cT\u003e {\n            fn to(\u0026self) -\u003e GenericTarget {\n                GenericTarget {\n                    data: self.value.to_string(),\n                }\n            }\n\n            fn from(_source: GenericTarget) -\u003e Self {\n                // This is a simplified implementation for testing\n                // We need to use a default value that matches the generic type\n                // For this test, we'll use a dummy implementation\n                unimplemented!(\"This is just a test of trait bounds\")\n            }\n        }\n\n        let source = GenericSource { value: 42i32 };\n        let target = source.to();\n        assert_eq!(target.data, \"42\");\n    }\n\n    #[test]\n    fn test_convertible_with_associated_types() {\n        trait ConvertibleWithAssociated {\n            type Target;\n            fn convert(\u0026self) -\u003e Self::Target;\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct AssociatedSource {\n            value: String,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct AssociatedTarget {\n            data: String,\n        }\n\n        impl ConvertibleWithAssociated for AssociatedSource {\n            type Target = AssociatedTarget;\n\n            fn convert(\u0026self) -\u003e Self::Target {\n                AssociatedTarget {\n                    data: self.value.clone(),\n                }\n            }\n        }\n\n        let source = AssociatedSource { value: \"associated\".to_string() };\n        let target = source.convert();\n        assert_eq!(target.data, \"associated\");\n    }\n\n    #[test]\n    fn test_convertible_with_default_implementations() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct DefaultSource {\n            value: String,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct DefaultTarget {\n            data: String,\n        }\n\n        impl Default for DefaultSource {\n            fn default() -\u003e Self {\n                Self {\n                    value: \"default\".to_string(),\n                }\n            }\n        }\n\n        impl Convertible\u003cDefaultTarget\u003e for DefaultSource {\n            fn to(\u0026self) -\u003e DefaultTarget {\n                DefaultTarget {\n                    data: self.value.clone(),\n                }\n            }\n\n            fn from(_source: DefaultTarget) -\u003e Self {\n                Self::default()\n            }\n        }\n\n        let source = DefaultSource::default();\n        let target = source.to();\n        assert_eq!(target.data, \"default\");\n\n        let new_source = \u003cDefaultSource as Convertible\u003cDefaultTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.value, \"default\");\n    }\n\n    #[test]\n    fn test_convertible_with_validation() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct ValidatedSource {\n            value: String,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct ValidatedTarget {\n            data: String,\n        }\n\n        impl Convertible\u003cValidatedTarget\u003e for ValidatedSource {\n            fn to(\u0026self) -\u003e ValidatedTarget {\n                // Validate during conversion\n                if self.value.len() \u003c 3 {\n                    panic!(\"Value too short\");\n                }\n                ValidatedTarget {\n                    data: self.value.clone(),\n                }\n            }\n\n            fn from(source: ValidatedTarget) -\u003e Self {\n                // Validate during reverse conversion\n                if source.data.len() \u003c 3 {\n                    panic!(\"Data too short\");\n                }\n                Self {\n                    value: source.data,\n                }\n            }\n        }\n\n        let source = ValidatedSource { value: \"valid\".to_string() };\n        let target = source.to();\n        assert_eq!(target.data, \"valid\");\n\n        let new_source = \u003cValidatedSource as Convertible\u003cValidatedTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.value, \"valid\");\n    }\n\n    #[test]\n    fn test_convertible_with_caching() {\n        use std::collections::HashMap;\n        use std::sync::Mutex;\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct CachedSource {\n            value: String,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct CachedTarget {\n            data: String,\n        }\n\n        struct CachedConverter {\n            cache: Mutex\u003cHashMap\u003cString, CachedTarget\u003e\u003e,\n        }\n\n        impl CachedConverter {\n            fn new() -\u003e Self {\n                Self {\n                    cache: Mutex::new(HashMap::new()),\n                }\n            }\n\n            fn convert(\u0026self, source: \u0026CachedSource) -\u003e CachedTarget {\n                let mut cache = self.cache.lock().unwrap();\n                if let Some(cached) = cache.get(\u0026source.value) {\n                    cached.clone()\n                } else {\n                    let target = CachedTarget {\n                        data: source.value.clone(),\n                    };\n                    cache.insert(source.value.clone(), target.clone());\n                    target\n                }\n            }\n        }\n\n        let converter = CachedConverter::new();\n        let source = CachedSource { value: \"cached\".to_string() };\n        \n        let target1 = converter.convert(\u0026source);\n        let target2 = converter.convert(\u0026source);\n        \n        assert_eq!(target1, target2);\n        assert_eq!(target1.data, \"cached\");\n    }\n\n    #[test]\n    fn test_convertible_with_async_support() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct AsyncSource {\n            value: String,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct AsyncTarget {\n            data: String,\n        }\n\n        impl Convertible\u003cAsyncTarget\u003e for AsyncSource {\n            fn to(\u0026self) -\u003e AsyncTarget {\n                AsyncTarget {\n                    data: self.value.clone(),\n                }\n            }\n\n            fn from(source: AsyncTarget) -\u003e Self {\n                Self {\n                    value: source.data,\n                }\n            }\n        }\n\n        // Simulate async conversion\n        let source = AsyncSource { value: \"async\".to_string() };\n        let target = source.to();\n        assert_eq!(target.data, \"async\");\n\n        // In a real async scenario, this would be awaited\n        let new_source = \u003cAsyncSource as Convertible\u003cAsyncTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.value, \"async\");\n    }\n\n    #[test]\n    fn test_convertible_with_metrics() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct MetricsSource {\n            value: String,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct MetricsTarget {\n            data: String,\n        }\n\n        struct MetricsConverter {\n            conversion_count: std::sync::atomic::AtomicUsize,\n        }\n\n        impl MetricsConverter {\n            fn new() -\u003e Self {\n                Self {\n                    conversion_count: std::sync::atomic::AtomicUsize::new(0),\n                }\n            }\n\n            fn convert(\u0026self, source: \u0026MetricsSource) -\u003e MetricsTarget {\n                self.conversion_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);\n                MetricsTarget {\n                    data: source.value.clone(),\n                }\n            }\n\n            fn get_count(\u0026self) -\u003e usize {\n                self.conversion_count.load(std::sync::atomic::Ordering::Relaxed)\n            }\n        }\n\n        let converter = MetricsConverter::new();\n        let source = MetricsSource { value: \"metrics\".to_string() };\n        \n        assert_eq!(converter.get_count(), 0);\n        let target = converter.convert(\u0026source);\n        assert_eq!(converter.get_count(), 1);\n        assert_eq!(target.data, \"metrics\");\n    }\n\n    // Additional edge case tests\n    #[test]\n    fn test_convertible_with_empty_vectors() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct EmptyVectorSource {\n            values: Vec\u003ci32\u003e,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct EmptyVectorTarget {\n            data: Vec\u003cString\u003e,\n        }\n\n        impl Convertible\u003cEmptyVectorTarget\u003e for EmptyVectorSource {\n            fn to(\u0026self) -\u003e EmptyVectorTarget {\n                EmptyVectorTarget {\n                    data: self.values.iter().map(|v| v.to_string()).collect(),\n                }\n            }\n\n            fn from(source: EmptyVectorTarget) -\u003e Self {\n                Self {\n                    values: source.data.iter().filter_map(|s| s.parse().ok()).collect(),\n                }\n            }\n        }\n\n        let source = EmptyVectorSource { values: vec![] };\n        let target = source.to();\n        assert_eq!(target.data, Vec::\u003cString\u003e::new());\n\n        let new_source = \u003cEmptyVectorSource as Convertible\u003cEmptyVectorTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.values, Vec::\u003ci32\u003e::new());\n    }\n\n    #[test]\n    fn test_convertible_with_single_element() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct SingleSource {\n            value: i32,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct SingleTarget {\n            data: String,\n        }\n\n        impl Convertible\u003cSingleTarget\u003e for SingleSource {\n            fn to(\u0026self) -\u003e SingleTarget {\n                SingleTarget {\n                    data: self.value.to_string(),\n                }\n            }\n\n            fn from(source: SingleTarget) -\u003e Self {\n                Self {\n                    value: source.data.parse().unwrap_or(0),\n                }\n            }\n        }\n\n        let source = SingleSource { value: 999 };\n        let target = source.to();\n        assert_eq!(target.data, \"999\");\n\n        let new_source = \u003cSingleSource as Convertible\u003cSingleTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.value, 999);\n    }\n\n    #[test]\n    fn test_convertible_with_zero_values() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct ZeroSource {\n            value: i32,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct ZeroTarget {\n            data: String,\n        }\n\n        impl Convertible\u003cZeroTarget\u003e for ZeroSource {\n            fn to(\u0026self) -\u003e ZeroTarget {\n                ZeroTarget {\n                    data: self.value.to_string(),\n                }\n            }\n\n            fn from(source: ZeroTarget) -\u003e Self {\n                Self {\n                    value: source.data.parse().unwrap_or(0),\n                }\n            }\n        }\n\n        let source = ZeroSource { value: 0 };\n        let target = source.to();\n        assert_eq!(target.data, \"0\");\n\n        let new_source = \u003cZeroSource as Convertible\u003cZeroTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.value, 0);\n    }\n\n    #[test]\n    fn test_convertible_with_negative_values() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct NegativeSource {\n            value: i32,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct NegativeTarget {\n            data: String,\n        }\n\n        impl Convertible\u003cNegativeTarget\u003e for NegativeSource {\n            fn to(\u0026self) -\u003e NegativeTarget {\n                NegativeTarget {\n                    data: self.value.to_string(),\n                }\n            }\n\n            fn from(source: NegativeTarget) -\u003e Self {\n                Self {\n                    value: source.data.parse().unwrap_or(0),\n                }\n            }\n        }\n\n        let source = NegativeSource { value: -42 };\n        let target = source.to();\n        assert_eq!(target.data, \"-42\");\n\n        let new_source = \u003cNegativeSource as Convertible\u003cNegativeTarget\u003e\u003e::from(target);\n        assert_eq!(new_source.value, -42);\n    }\n\n    // Test that our blanket implementations actually work\n    #[test]\n    fn test_blanket_implementations_execution() {\n        // Test that our blanket implementations don't cause compilation errors\n        // and that basic conversion works through our custom traits\n        \n        #[derive(Debug, Clone, PartialEq)]\n        struct TestSource {\n            value: String,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct TestTarget {\n            data: String,\n        }\n\n        impl Convertible\u003cTestTarget\u003e for TestSource {\n            fn to(\u0026self) -\u003e TestTarget {\n                TestTarget {\n                    data: self.value.clone(),\n                }\n            }\n\n            fn from(source: TestTarget) -\u003e Self {\n                Self {\n                    value: source.data,\n                }\n            }\n        }\n\n        let source = TestSource {\n            value: \"blanket_test\".to_string(),\n        };\n        \n        // Test our Convertible implementation works\n        let target = source.to();\n        let new_source = \u003cTestSource as Convertible\u003cTestTarget\u003e\u003e::from(target.clone());\n        \n        assert_eq!(target.data, \"blanket_test\");\n        assert_eq!(new_source.value, \"blanket_test\");\n        \n        // Verify that BidirectionalConvertible is automatically implemented\n        // This tests the blanket implementation without conflicts\n        assert!(true); // Placeholder assertion\n    }\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[2589248],"length":1,"stats":{"Line":1}},{"line":66,"address":[2589265],"length":1,"stats":{"Line":1}},{"line":69,"address":[2589280],"length":1,"stats":{"Line":1}},{"line":70,"address":[2589288],"length":1,"stats":{"Line":1}}],"covered":4,"coverable":8},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","shared","errors.rs"],"content":"use std::error::Error as StdError;\nuse std::fmt;\n\n/// Base error type for all domain errors\n#[derive(Debug)]\npub struct DomainError {\n    kind: DomainErrorKind,\n    source: Option\u003cBox\u003cdyn StdError + Send + Sync\u003e\u003e,\n    context: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone)]\npub enum DomainErrorKind {\n    // Project Management Errors\n    ProjectNotFound { code: String },\n    ProjectAlreadyExists { code: String },\n    ProjectInvalidState { current: String, expected: String },\n    ProjectValidationFailed { details: Vec\u003cString\u003e },\n\n    // Resource Management Errors\n    ResourceNotFound { code: String },\n    ResourceAlreadyExists { code: String },\n    ResourceInvalidState { current: String, expected: String },\n    ResourceValidationFailed { details: Vec\u003cString\u003e },\n\n    // Task Management Errors\n    TaskNotFound { code: String },\n    TaskAlreadyExists { code: String },\n    TaskInvalidState { current: String, expected: String },\n    TaskValidationFailed { details: Vec\u003cString\u003e },\n    TaskAssignmentFailed { reason: String },\n\n    // Configuration Errors\n    ConfigurationInvalid { field: String, value: String },\n    ConfigurationMissing { field: String },\n\n    // Repository Errors\n    RepositoryError { operation: String, details: String },\n    PersistenceError { operation: String, details: String },\n\n    // Validation Errors\n    ValidationError { field: String, message: String },\n\n    // Generic Errors\n    Generic { message: String },\n    Io { operation: String, path: Option\u003cString\u003e },\n    Serialization { format: String, details: String },\n}\n\nimpl DomainError {\n    /// Create a new domain error with a specific kind\n    pub fn new(kind: DomainErrorKind) -\u003e Self {\n        Self {\n            kind,\n            source: None,\n            context: None,\n        }\n    }\n\n    /// Add context information to the error\n    pub fn with_context(mut self, context: impl Into\u003cString\u003e) -\u003e Self {\n        self.context = Some(context.into());\n        self\n    }\n\n    /// Add a source error to this error\n    pub fn with_source(mut self, source: impl StdError + Send + Sync + 'static) -\u003e Self {\n        // 'static necessário para Box\u003cdyn\u003e\n        self.source = Some(Box::new(source));\n        self\n    }\n\n    /// Get the kind of this error\n    pub fn kind(\u0026self) -\u003e \u0026DomainErrorKind {\n        \u0026self.kind\n    }\n\n    /// Get the context of this error\n    pub fn context(\u0026self) -\u003e Option\u003c\u0026String\u003e {\n        self.context.as_ref()\n    }\n\n    /// Check if this is a specific type of error\n    pub fn is_project_not_found(\u0026self) -\u003e bool {\n        matches!(self.kind, DomainErrorKind::ProjectNotFound { .. })\n    }\n\n    pub fn is_resource_not_found(\u0026self) -\u003e bool {\n        matches!(self.kind, DomainErrorKind::ResourceNotFound { .. })\n    }\n\n    pub fn is_task_not_found(\u0026self) -\u003e bool {\n        matches!(self.kind, DomainErrorKind::TaskNotFound { .. })\n    }\n\n    pub fn is_validation_error(\u0026self) -\u003e bool {\n        matches!(self.kind, DomainErrorKind::ValidationError { .. })\n    }\n\n    /// Create a project not found error\n    pub fn project_not_found(code: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(DomainErrorKind::ProjectNotFound { code: code.into() })\n    }\n\n    /// Create a resource not found error\n    pub fn resource_not_found(code: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(DomainErrorKind::ResourceNotFound { code: code.into() })\n    }\n\n    /// Create a task not found error\n    pub fn task_not_found(code: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(DomainErrorKind::TaskNotFound { code: code.into() })\n    }\n\n    /// Create a validation error\n    pub fn validation_error(field: impl Into\u003cString\u003e, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(DomainErrorKind::ValidationError {\n            field: field.into(),\n            message: message.into(),\n        })\n    }\n\n    /// Create a project invalid state error\n    pub fn project_invalid_state(current: impl Into\u003cString\u003e, expected: impl Into\u003cString\u003e) -\u003e Self {\n        Self::new(DomainErrorKind::ProjectInvalidState {\n            current: current.into(),\n            expected: expected.into(),\n        })\n    }\n}\n\nimpl fmt::Display for DomainError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match \u0026self.kind {\n            DomainErrorKind::ProjectNotFound { code } =\u003e write!(f, \"Project with code '{}' not found\", code)?,\n            DomainErrorKind::ProjectAlreadyExists { code } =\u003e write!(f, \"Project with code '{}' already exists\", code)?,\n            DomainErrorKind::ProjectInvalidState { current, expected } =\u003e {\n                write!(f, \"Project is in invalid state '{}', expected '{}'\", current, expected)?\n            }\n            DomainErrorKind::ProjectValidationFailed { details } =\u003e {\n                write!(f, \"Project validation failed: {}\", details.join(\", \"))?\n            }\n            DomainErrorKind::ResourceNotFound { code } =\u003e write!(f, \"Resource with code '{}' not found\", code)?,\n            DomainErrorKind::ResourceAlreadyExists { code } =\u003e {\n                write!(f, \"Resource with code '{}' already exists\", code)?\n            }\n            DomainErrorKind::ResourceInvalidState { current, expected } =\u003e {\n                write!(f, \"Resource is in invalid state '{}', expected '{}'\", current, expected)?\n            }\n            DomainErrorKind::ResourceValidationFailed { details } =\u003e {\n                write!(f, \"Resource validation failed: {}\", details.join(\", \"))?\n            }\n            DomainErrorKind::TaskNotFound { code } =\u003e write!(f, \"Task with code '{}' not found\", code)?,\n            DomainErrorKind::TaskAlreadyExists { code } =\u003e write!(f, \"Task with code '{}' already exists\", code)?,\n            DomainErrorKind::TaskInvalidState { current, expected } =\u003e {\n                write!(f, \"Task is in invalid state '{}', expected '{}'\", current, expected)?\n            }\n            DomainErrorKind::TaskValidationFailed { details } =\u003e {\n                write!(f, \"Task validation failed: {}\", details.join(\", \"))?\n            }\n            DomainErrorKind::TaskAssignmentFailed { reason } =\u003e write!(f, \"Task assignment failed: {}\", reason)?,\n            DomainErrorKind::ConfigurationInvalid { field, value } =\u003e {\n                write!(f, \"Invalid configuration for field '{}': {}\", field, value)?\n            }\n            DomainErrorKind::ConfigurationMissing { field } =\u003e {\n                write!(f, \"Missing configuration for field '{}'\", field)?\n            }\n            DomainErrorKind::RepositoryError { operation, details } =\u003e {\n                write!(f, \"Repository error during {}: {}\", operation, details)?\n            }\n            DomainErrorKind::PersistenceError { operation, details } =\u003e {\n                write!(f, \"Persistence error during {}: {}\", operation, details)?\n            }\n            DomainErrorKind::ValidationError { field, message } =\u003e {\n                write!(f, \"Validation error for field '{}': {}\", field, message)?\n            }\n            DomainErrorKind::Generic { message } =\u003e write!(f, \"{}\", message)?,\n            DomainErrorKind::Io { operation, path } =\u003e match path {\n                Some(path) =\u003e write!(f, \"I/O error during {} on path '{}'\", operation, path)?,\n                None =\u003e write!(f, \"I/O error during {}\", operation)?,\n            },\n            DomainErrorKind::Serialization { format, details } =\u003e {\n                write!(f, \"Serialization error for format '{}': {}\", format, details)?\n            }\n        }\n\n        if let Some(context) = \u0026self.context {\n            write!(f, \" (Context: {})\", context)?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl StdError for DomainError {\n    fn source(\u0026self) -\u003e Option\u003c\u0026(dyn StdError + 'static)\u003e {\n        self.source.as_ref().map(|s| s.as_ref() as \u0026(dyn StdError + 'static))\n    }\n}\n\n// Convenience constructors for common error patterns\nimpl From\u003cString\u003e for DomainError {\n    fn from(message: String) -\u003e Self {\n        Self::new(DomainErrorKind::Generic { message })\n    }\n}\n\nimpl From\u003c\u0026str\u003e for DomainError {\n    fn from(message: \u0026str) -\u003e Self {\n        Self::new(DomainErrorKind::Generic {\n            message: message.to_string(),\n        })\n    }\n}\n\nimpl From\u003cstd::io::Error\u003e for DomainError {\n    fn from(err: std::io::Error) -\u003e Self {\n        Self::new(DomainErrorKind::Io {\n            operation: \"file operation\".to_string(),\n            path: None,\n        })\n        .with_source(err)\n    }\n}\n\nimpl From\u003cserde_yaml::Error\u003e for DomainError {\n    fn from(err: serde_yaml::Error) -\u003e Self {\n        Self::new(DomainErrorKind::Serialization {\n            format: \"YAML\".to_string(),\n            details: err.to_string(),\n        })\n        .with_source(err)\n    }\n}\n\n// Result type alias for domain operations\npub type DomainResult\u003cT\u003e = Result\u003cT, DomainError\u003e;\n\n// Extension trait for adding context to Results\npub trait ResultExt\u003cT, E\u003e {\n    fn with_context\u003cC\u003e(self, context: C) -\u003e Result\u003cT, DomainError\u003e\n    where\n        C: Into\u003cString\u003e,\n        E: Into\u003cDomainError\u003e;\n}\n\nimpl\u003cT, E\u003e ResultExt\u003cT, E\u003e for Result\u003cT, E\u003e\nwhere\n    E: Into\u003cDomainError\u003e,\n{\n    fn with_context\u003cC\u003e(self, context: C) -\u003e Result\u003cT, DomainError\u003e\n    where\n        C: Into\u003cString\u003e,\n    {\n        self.map_err(|e| e.into().with_context(context))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io;\n\n    #[test]\n    fn test_domain_error_creation() {\n        let error = DomainError::new(DomainErrorKind::ProjectNotFound {\n            code: \"PROJ-001\".to_string(),\n        });\n\n        assert!(matches!(error.kind(), DomainErrorKind::ProjectNotFound { code } if code == \"PROJ-001\"));\n        assert!(error.source().is_none());\n        assert!(error.context().is_none());\n    }\n\n    #[test]\n    fn test_domain_error_with_context() {\n        let error = DomainError::new(DomainErrorKind::ProjectNotFound {\n            code: \"PROJ-001\".to_string(),\n        })\n        .with_context(\"Failed to load project from repository\");\n\n        assert!(matches!(error.kind(), DomainErrorKind::ProjectNotFound { code } if code == \"PROJ-001\"));\n        assert_eq!(\n            error.context(),\n            Some(\u0026\"Failed to load project from repository\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_domain_error_with_source() {\n        let io_error = io::Error::new(io::ErrorKind::NotFound, \"File not found\");\n        let domain_error = DomainError::new(DomainErrorKind::Io {\n            operation: \"read\".to_string(),\n            path: Some(\"/path/to/file\".to_string()),\n        })\n        .with_source(io_error);\n\n        assert!(matches!(domain_error.kind(), DomainErrorKind::Io { operation, path } \n            if operation == \"read\" \u0026\u0026 path.as_deref() == Some(\"/path/to/file\")));\n        assert!(domain_error.source().is_some());\n    }\n\n    #[test]\n    fn test_domain_error_display_formatting() {\n        let error = DomainError::new(DomainErrorKind::ProjectNotFound {\n            code: \"PROJ-001\".to_string(),\n        })\n        .with_context(\"Repository operation failed\");\n\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Project with code 'PROJ-001' not found\"));\n        assert!(display.contains(\"(Context: Repository operation failed)\"));\n    }\n\n    #[test]\n    fn test_domain_error_display_without_context() {\n        let error = DomainError::new(DomainErrorKind::ResourceNotFound {\n            code: \"RES-001\".to_string(),\n        });\n\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Resource with code 'RES-001' not found\"));\n        assert!(!display.contains(\"(Context:\"));\n    }\n\n    #[test]\n    fn test_domain_error_display_io_with_path() {\n        let error = DomainError::new(DomainErrorKind::Io {\n            operation: \"write\".to_string(),\n            path: Some(\"/tmp/file.yaml\".to_string()),\n        });\n\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"I/O error during write on path '/tmp/file.yaml'\"));\n    }\n\n    #[test]\n    fn test_domain_error_display_io_without_path() {\n        let error = DomainError::new(DomainErrorKind::Io {\n            operation: \"read\".to_string(),\n            path: None,\n        });\n\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"I/O error during read\"));\n        assert!(!display.contains(\"on path\"));\n    }\n\n    #[test]\n    fn test_domain_error_display_validation_error() {\n        let error = DomainError::new(DomainErrorKind::ValidationError {\n            field: \"email\".to_string(),\n            message: \"Invalid email format\".to_string(),\n        });\n\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Validation error for field 'email': Invalid email format\"));\n    }\n\n    #[test]\n    fn test_domain_error_display_serialization_error() {\n        let error = DomainError::new(DomainErrorKind::Serialization {\n            format: \"JSON\".to_string(),\n            details: \"Invalid UTF-8 sequence\".to_string(),\n        });\n\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Serialization error for format 'JSON': Invalid UTF-8 sequence\"));\n    }\n\n    #[test]\n    fn test_domain_error_is_project_not_found() {\n        let error = DomainError::project_not_found(\"PROJ-001\");\n        assert!(error.is_project_not_found());\n        assert!(!error.is_resource_not_found());\n        assert!(!error.is_task_not_found());\n        assert!(!error.is_validation_error());\n    }\n\n    #[test]\n    fn test_domain_error_is_resource_not_found() {\n        let error = DomainError::resource_not_found(\"RES-001\");\n        assert!(!error.is_project_not_found());\n        assert!(error.is_resource_not_found());\n        assert!(!error.is_task_not_found());\n        assert!(!error.is_validation_error());\n    }\n\n    #[test]\n    fn test_domain_error_is_task_not_found() {\n        let error = DomainError::task_not_found(\"TASK-001\");\n        assert!(!error.is_project_not_found());\n        assert!(!error.is_resource_not_found());\n        assert!(error.is_task_not_found());\n        assert!(!error.is_validation_error());\n    }\n\n    #[test]\n    fn test_domain_error_is_validation_error() {\n        let error = DomainError::validation_error(\"email\", \"Invalid format\");\n        assert!(!error.is_project_not_found());\n        assert!(!error.is_resource_not_found());\n        assert!(!error.is_task_not_found());\n        assert!(error.is_validation_error());\n    }\n\n    #[test]\n    fn test_domain_error_from_string() {\n        let error: DomainError = \"Custom error message\".to_string().into();\n\n        assert!(matches!(error.kind(), DomainErrorKind::Generic { message }\n            if message == \"Custom error message\"));\n    }\n\n    #[test]\n    fn test_domain_error_from_str() {\n        let error: DomainError = \"Static error message\".into();\n\n        assert!(matches!(error.kind(), DomainErrorKind::Generic { message }\n            if message == \"Static error message\"));\n    }\n\n    #[test]\n    fn test_domain_error_from_io_error() {\n        let io_error = io::Error::new(io::ErrorKind::PermissionDenied, \"Access denied\");\n        let domain_error: DomainError = io_error.into();\n\n        assert!(matches!(domain_error.kind(), DomainErrorKind::Io { operation, path }\n            if operation == \"file operation\" \u0026\u0026 path.is_none()));\n    }\n\n    #[test]\n    fn test_domain_error_from_serde_yaml_error() {\n        // Simular um erro de YAML inválido\n        let yaml_content = \"invalid: yaml: content: [\";\n        let yaml_error = serde_yaml::from_str::\u003cserde_yaml::Value\u003e(yaml_content).unwrap_err();\n        let domain_error: DomainError = yaml_error.into();\n\n        if let DomainErrorKind::Serialization { format, details } = domain_error.kind() {\n            assert_eq!(format, \"YAML\");\n            assert!(!details.is_empty());\n        } else {\n            panic!(\"Expected Serialization error\");\n        }\n    }\n\n    #[test]\n    fn test_result_ext_with_context() {\n        let result: Result\u003c\u0026str, \u0026str\u003e = Err(\"Database connection failed\");\n        let domain_result: DomainResult\u003c\u0026str\u003e = result.with_context(\"Failed to load user data\");\n\n        assert!(domain_result.is_err());\n        let error = domain_result.unwrap_err();\n        assert!(matches!(error.kind(), DomainErrorKind::Generic { message } \n            if message == \"Database connection failed\"));\n        assert_eq!(error.context(), Some(\u0026\"Failed to load user data\".to_string()));\n    }\n\n    #[test]\n    fn test_result_ext_with_context_success() {\n        let result: Result\u003c\u0026str, \u0026str\u003e = Ok(\"Success\");\n        let domain_result: DomainResult\u003c\u0026str\u003e = result.with_context(\"Operation completed\");\n\n        assert!(domain_result.is_ok());\n        assert_eq!(domain_result.unwrap(), \"Success\");\n    }\n\n    #[test]\n    fn test_domain_error_error_trait_source() {\n        let io_error = io::Error::new(io::ErrorKind::NotFound, \"File not found\");\n        let domain_error = DomainError::new(DomainErrorKind::Io {\n            operation: \"read\".to_string(),\n            path: None,\n        })\n        .with_source(io_error);\n\n        let source = domain_error.source();\n        assert!(source.is_some());\n\n        let source_error = source.unwrap();\n        assert!(source_error.to_string().contains(\"File not found\"));\n    }\n\n    #[test]\n    fn test_domain_error_error_trait_no_source() {\n        let domain_error = DomainError::new(DomainErrorKind::ProjectNotFound {\n            code: \"PROJ-001\".to_string(),\n        });\n\n        let source = domain_error.source();\n        assert!(source.is_none());\n    }\n\n    #[test]\n    fn test_domain_error_debug_formatting() {\n        let error = DomainError::new(DomainErrorKind::ProjectNotFound {\n            code: \"PROJ-001\".to_string(),\n        });\n\n        let debug = format!(\"{:?}\", error);\n        assert!(debug.contains(\"ProjectNotFound\"));\n        assert!(debug.contains(\"PROJ-001\"));\n    }\n\n    #[test]\n    fn test_domain_error_kind_debug_formatting() {\n        let kind = DomainErrorKind::ProjectNotFound {\n            code: \"PROJ-001\".to_string(),\n        };\n\n        let debug = format!(\"{:?}\", kind);\n        assert!(debug.contains(\"ProjectNotFound\"));\n        assert!(debug.contains(\"PROJ-001\"));\n    }\n\n    #[test]\n    fn test_domain_error_complex_scenario() {\n        // Simular um cenário complexo de erro\n        let io_error = io::Error::new(io::ErrorKind::PermissionDenied, \"Access denied\");\n        let domain_error = DomainError::new(DomainErrorKind::RepositoryError {\n            operation: \"save\".to_string(),\n            details: \"Failed to persist project data\".to_string(),\n        })\n        .with_context(\"Project creation workflow failed\")\n        .with_source(io_error);\n\n        // Verificar o tipo de erro\n        assert!(\n            matches!(domain_error.kind(), DomainErrorKind::RepositoryError { operation, details }\n            if operation == \"save\" \u0026\u0026 details == \"Failed to persist project data\")\n        );\n\n        // Verificar o contexto\n        assert_eq!(\n            domain_error.context(),\n            Some(\u0026\"Project creation workflow failed\".to_string())\n        );\n\n        // Verificar a fonte\n        assert!(domain_error.source().is_some());\n\n        // Verificar a formatação\n        let display = format!(\"{}\", domain_error);\n        assert!(display.contains(\"Repository error during save: Failed to persist project data\"));\n        assert!(display.contains(\"(Context: Project creation workflow failed)\"));\n    }\n\n    #[test]\n    fn test_domain_error_display_all_variants() {\n        // Testar todas as variantes de DomainErrorKind para garantir cobertura completa\n        \n        // Project Management Errors\n        let project_not_found = DomainError::project_not_found(\"PROJ-001\");\n        assert!(format!(\"{}\", project_not_found).contains(\"Project with code 'PROJ-001' not found\"));\n\n        let project_already_exists = DomainError::new(DomainErrorKind::ProjectAlreadyExists { code: \"PROJ-001\".to_string() });\n        assert!(format!(\"{}\", project_already_exists).contains(\"Project with code 'PROJ-001' already exists\"));\n\n        let project_invalid_state = DomainError::project_invalid_state(\"Completed\", \"In Progress\");\n        assert!(format!(\"{}\", project_invalid_state).contains(\"Project is in invalid state 'Completed', expected 'In Progress'\"));\n\n        let project_validation_failed = DomainError::new(DomainErrorKind::ProjectValidationFailed { \n            details: vec![\"Name required\".to_string(), \"Code invalid\".to_string()] \n        });\n        assert!(format!(\"{}\", project_validation_failed).contains(\"Project validation failed: Name required, Code invalid\"));\n\n        // Resource Management Errors\n        let resource_not_found = DomainError::resource_not_found(\"RES-001\");\n        assert!(format!(\"{}\", resource_not_found).contains(\"Resource with code 'RES-001' not found\"));\n\n        let resource_already_exists = DomainError::new(DomainErrorKind::ResourceAlreadyExists { code: \"RES-001\".to_string() });\n        assert!(format!(\"{}\", resource_already_exists).contains(\"Resource with code 'RES-001' already exists\"));\n\n        let resource_invalid_state = DomainError::new(DomainErrorKind::ResourceInvalidState { \n            current: \"Inactive\".to_string(), \n            expected: \"Active\".to_string() \n        });\n        assert!(format!(\"{}\", resource_invalid_state).contains(\"Resource is in invalid state 'Inactive', expected 'Active'\"));\n\n        let resource_validation_failed = DomainError::new(DomainErrorKind::ResourceValidationFailed { \n            details: vec![\"Email invalid\".to_string(), \"Name required\".to_string()] \n        });\n        assert!(format!(\"{}\", resource_validation_failed).contains(\"Resource validation failed: Email invalid, Name required\"));\n\n        // Task Management Errors\n        let task_not_found = DomainError::task_not_found(\"TASK-001\");\n        assert!(format!(\"{}\", task_not_found).contains(\"Task with code 'TASK-001' not found\"));\n\n        let task_already_exists = DomainError::new(DomainErrorKind::TaskAlreadyExists { code: \"TASK-001\".to_string() });\n        assert!(format!(\"{}\", task_already_exists).contains(\"Task with code 'TASK-001' already exists\"));\n\n        let task_invalid_state = DomainError::new(DomainErrorKind::TaskInvalidState { \n            current: \"Completed\".to_string(), \n            expected: \"In Progress\".to_string() \n        });\n        assert!(format!(\"{}\", task_invalid_state).contains(\"Task is in invalid state 'Completed', expected 'In Progress'\"));\n\n        let task_validation_failed = DomainError::new(DomainErrorKind::TaskValidationFailed { \n            details: vec![\"Name required\".to_string(), \"Dates invalid\".to_string()] \n        });\n        assert!(format!(\"{}\", task_validation_failed).contains(\"Task validation failed: Name required, Dates invalid\"));\n\n        let task_assignment_failed = DomainError::new(DomainErrorKind::TaskAssignmentFailed { \n            reason: \"Resource unavailable\".to_string() \n        });\n        assert!(format!(\"{}\", task_assignment_failed).contains(\"Task assignment failed: Resource unavailable\"));\n\n        // Configuration Errors\n        let config_invalid = DomainError::new(DomainErrorKind::ConfigurationInvalid { \n            field: \"timezone\".to_string(), \n            value: \"INVALID\".to_string() \n        });\n        assert!(format!(\"{}\", config_invalid).contains(\"Invalid configuration for field 'timezone': INVALID\"));\n\n        let config_missing = DomainError::new(DomainErrorKind::ConfigurationMissing { \n            field: \"database_url\".to_string() \n        });\n        assert!(format!(\"{}\", config_missing).contains(\"Missing configuration for field 'database_url'\"));\n\n        // Repository Errors\n        let repository_error = DomainError::new(DomainErrorKind::RepositoryError { \n            operation: \"find\".to_string(), \n            details: \"Connection timeout\".to_string() \n        });\n        assert!(format!(\"{}\", repository_error).contains(\"Repository error during find: Connection timeout\"));\n\n        let persistence_error = DomainError::new(DomainErrorKind::PersistenceError { \n            operation: \"save\".to_string(), \n            details: \"Disk full\".to_string() \n        });\n        assert!(format!(\"{}\", persistence_error).contains(\"Persistence error during save: Disk full\"));\n\n        // Generic Errors\n        let generic_error = DomainError::new(DomainErrorKind::Generic { \n            message: \"Unexpected error occurred\".to_string() \n        });\n        assert!(format!(\"{}\", generic_error).contains(\"Unexpected error occurred\"));\n    }\n\n    #[test]\n    fn test_domain_error_with_context_chaining() {\n        let error = DomainError::new(DomainErrorKind::ProjectNotFound { code: \"PROJ-001\".to_string() })\n            .with_context(\"First context\")\n            .with_context(\"Second context\");\n\n        // O último contexto deve sobrescrever o anterior\n        assert_eq!(error.context(), Some(\u0026\"Second context\".to_string()));\n    }\n\n    #[test]\n    fn test_domain_error_with_source_chaining() {\n        let io_error = io::Error::new(io::ErrorKind::NotFound, \"File not found\");\n        let error = DomainError::new(DomainErrorKind::Io { \n            operation: \"read\".to_string(), \n            path: None \n        })\n        .with_source(io_error);\n\n        assert!(error.source().is_some());\n        let source = error.source().unwrap();\n        assert!(source.to_string().contains(\"File not found\"));\n    }\n\n    #[test]\n    fn test_domain_error_kind_variants_debug() {\n        // Testar debug formatting para todas as variantes\n        let variants = vec![\n            DomainErrorKind::ProjectNotFound { code: \"TEST\".to_string() },\n            DomainErrorKind::ProjectAlreadyExists { code: \"TEST\".to_string() },\n            DomainErrorKind::ProjectInvalidState { \n                current: \"TEST\".to_string(), \n                expected: \"TEST\".to_string() \n            },\n            DomainErrorKind::ProjectValidationFailed { \n                details: vec![\"TEST\".to_string()] \n            },\n            DomainErrorKind::ResourceNotFound { code: \"TEST\".to_string() },\n            DomainErrorKind::ResourceAlreadyExists { code: \"TEST\".to_string() },\n            DomainErrorKind::ResourceInvalidState { \n                current: \"TEST\".to_string(), \n                expected: \"TEST\".to_string() \n            },\n            DomainErrorKind::ResourceValidationFailed { \n                details: vec![\"TEST\".to_string()] \n            },\n            DomainErrorKind::TaskNotFound { code: \"TEST\".to_string() },\n            DomainErrorKind::TaskAlreadyExists { code: \"TEST\".to_string() },\n            DomainErrorKind::TaskInvalidState { \n                current: \"TEST\".to_string(), \n                expected: \"TEST\".to_string() \n            },\n            DomainErrorKind::TaskValidationFailed { \n                details: vec![\"TEST\".to_string()] \n            },\n            DomainErrorKind::TaskAssignmentFailed { reason: \"TEST\".to_string() },\n            DomainErrorKind::ConfigurationInvalid { \n                field: \"TEST\".to_string(), \n                value: \"TEST\".to_string() \n            },\n            DomainErrorKind::ConfigurationMissing { field: \"TEST\".to_string() },\n            DomainErrorKind::RepositoryError { \n                operation: \"TEST\".to_string(), \n                details: \"TEST\".to_string() \n            },\n            DomainErrorKind::PersistenceError { \n                operation: \"TEST\".to_string(), \n                details: \"TEST\".to_string() \n            },\n            DomainErrorKind::ValidationError { \n                field: \"TEST\".to_string(), \n                message: \"TEST\".to_string() \n            },\n            DomainErrorKind::Generic { message: \"TEST\".to_string() },\n            DomainErrorKind::Io { \n                operation: \"TEST\".to_string(), \n                path: None \n            },\n            DomainErrorKind::Serialization { \n                format: \"TEST\".to_string(), \n                details: \"TEST\".to_string() \n            },\n        ];\n\n        for variant in variants {\n            let debug_str = format!(\"{:?}\", variant);\n            assert!(!debug_str.is_empty());\n            assert!(debug_str.len() \u003e 0);\n        }\n    }\n\n    #[test]\n    fn test_domain_error_context_methods() {\n        let error = DomainError::new(DomainErrorKind::ProjectNotFound { code: \"PROJ-001\".to_string() })\n            .with_context(\"Test context\");\n\n        // Testar métodos de acesso\n        assert!(matches!(error.kind(), DomainErrorKind::ProjectNotFound { code } if code == \"PROJ-001\"));\n        assert_eq!(error.context(), Some(\u0026\"Test context\".to_string()));\n        assert!(error.source().is_none());\n    }\n\n    #[test]\n    fn test_domain_error_kind_comparison() {\n        let error1 = DomainError::new(DomainErrorKind::ProjectNotFound { code: \"PROJ-001\".to_string() });\n        let error2 = DomainError::new(DomainErrorKind::ProjectNotFound { code: \"PROJ-001\".to_string() });\n        let error3 = DomainError::new(DomainErrorKind::ProjectNotFound { code: \"PROJ-002\".to_string() });\n\n        // Testar que erros com o mesmo kind têm códigos iguais\n        if let (DomainErrorKind::ProjectNotFound { code: code1 }, DomainErrorKind::ProjectNotFound { code: code2 }) = (error1.kind(), error2.kind()) {\n            assert_eq!(code1, code2);\n        } else {\n            panic!(\"Expected ProjectNotFound errors\");\n        }\n\n        if let (DomainErrorKind::ProjectNotFound { code: code1 }, DomainErrorKind::ProjectNotFound { code: code3 }) = (error1.kind(), error3.kind()) {\n            assert_ne!(code1, code3);\n        } else {\n            panic!(\"Expected ProjectNotFound errors\");\n        }\n    }\n}\n","traces":[{"line":52,"address":[3065856],"length":1,"stats":{"Line":1}},{"line":61,"address":[2032967,2032716,2032448,2032736],"length":1,"stats":{"Line":6}},{"line":62,"address":[2032568,2032766,2032825,2032506],"length":1,"stats":{"Line":10}},{"line":63,"address":[2032947,2032693],"length":1,"stats":{"Line":4}},{"line":67,"address":[2033207,2033443,2033232,2032992],"length":1,"stats":{"Line":2}},{"line":69,"address":[2033322,2033086,2033269,2033029],"length":1,"stats":{"Line":5}},{"line":70,"address":[2033187,2033423],"length":1,"stats":{"Line":2}},{"line":74,"address":[3065968],"length":1,"stats":{"Line":1}},{"line":79,"address":[3065984],"length":1,"stats":{"Line":2}},{"line":80,"address":[3065989],"length":1,"stats":{"Line":2}},{"line":84,"address":[3066016],"length":1,"stats":{"Line":1}},{"line":85,"address":[3066021],"length":1,"stats":{"Line":1}},{"line":88,"address":[3066032],"length":1,"stats":{"Line":2}},{"line":89,"address":[3066037],"length":1,"stats":{"Line":2}},{"line":92,"address":[3066048],"length":1,"stats":{"Line":3}},{"line":93,"address":[3066053],"length":1,"stats":{"Line":3}},{"line":96,"address":[3066064],"length":1,"stats":{"Line":3}},{"line":97,"address":[3066069],"length":1,"stats":{"Line":3}},{"line":101,"address":[2033472],"length":1,"stats":{"Line":1}},{"line":102,"address":[2033496],"length":1,"stats":{"Line":1}},{"line":106,"address":[2033584],"length":1,"stats":{"Line":1}},{"line":107,"address":[2033608],"length":1,"stats":{"Line":2}},{"line":111,"address":[2033696],"length":1,"stats":{"Line":1}},{"line":112,"address":[2033720],"length":1,"stats":{"Line":2}},{"line":116,"address":[2034108,2033808,2034114],"length":1,"stats":{"Line":1}},{"line":117,"address":[2034031,2033867],"length":1,"stats":{"Line":2}},{"line":118,"address":[2033883],"length":1,"stats":{"Line":1}},{"line":119,"address":[2033957],"length":1,"stats":{"Line":1}},{"line":124,"address":[2034450,2034144,2034444],"length":1,"stats":{"Line":1}},{"line":125,"address":[2034367,2034203],"length":1,"stats":{"Line":2}},{"line":126,"address":[2034219],"length":1,"stats":{"Line":1}},{"line":127,"address":[2034293],"length":1,"stats":{"Line":1}},{"line":133,"address":[3070299,3070293,3066080],"length":1,"stats":{"Line":1}},{"line":134,"address":[3066113],"length":1,"stats":{"Line":1}},{"line":135,"address":[3069927,3066149],"length":1,"stats":{"Line":1}},{"line":136,"address":[3066292,3070021],"length":1,"stats":{"Line":1}},{"line":137,"address":[3066447],"length":1,"stats":{"Line":1}},{"line":138,"address":[3070042,3066474],"length":1,"stats":{"Line":1}},{"line":140,"address":[3066703],"length":1,"stats":{"Line":1}},{"line":141,"address":[3066715,3070063],"length":1,"stats":{"Line":1}},{"line":143,"address":[3066794,3070312],"length":1,"stats":{"Line":1}},{"line":144,"address":[3066949],"length":1,"stats":{"Line":1}},{"line":145,"address":[3066961,3070336],"length":1,"stats":{"Line":1}},{"line":147,"address":[3067104],"length":1,"stats":{"Line":1}},{"line":148,"address":[3067131,3070360],"length":1,"stats":{"Line":1}},{"line":150,"address":[3067360],"length":1,"stats":{"Line":1}},{"line":151,"address":[3067372,3070384],"length":1,"stats":{"Line":1}},{"line":153,"address":[3070611,3067451],"length":1,"stats":{"Line":1}},{"line":154,"address":[3070635,3067606],"length":1,"stats":{"Line":1}},{"line":155,"address":[3067761],"length":1,"stats":{"Line":1}},{"line":156,"address":[3070659,3067788],"length":1,"stats":{"Line":1}},{"line":158,"address":[3068017],"length":1,"stats":{"Line":1}},{"line":159,"address":[3070683,3068029],"length":1,"stats":{"Line":1}},{"line":161,"address":[3070913,3068108],"length":1,"stats":{"Line":1}},{"line":162,"address":[3068263],"length":1,"stats":{"Line":1}},{"line":163,"address":[3068290,3070937],"length":1,"stats":{"Line":1}},{"line":165,"address":[3068519],"length":1,"stats":{"Line":1}},{"line":166,"address":[3068531,3070961],"length":1,"stats":{"Line":1}},{"line":168,"address":[3068674],"length":1,"stats":{"Line":1}},{"line":169,"address":[3068701,3070985],"length":1,"stats":{"Line":1}},{"line":171,"address":[3068930],"length":1,"stats":{"Line":1}},{"line":172,"address":[3068957,3071009],"length":1,"stats":{"Line":1}},{"line":174,"address":[3069186],"length":1,"stats":{"Line":1}},{"line":175,"address":[3069213,3071033],"length":1,"stats":{"Line":1}},{"line":177,"address":[3069442,3071057],"length":1,"stats":{"Line":1}},{"line":178,"address":[3069597],"length":1,"stats":{"Line":1}},{"line":179,"address":[3071475,3071086],"length":1,"stats":{"Line":1}},{"line":180,"address":[3071318],"length":1,"stats":{"Line":1}},{"line":182,"address":[3069679],"length":1,"stats":{"Line":1}},{"line":183,"address":[3071499,3069706],"length":1,"stats":{"Line":1}},{"line":187,"address":[3071528,3069953],"length":1,"stats":{"Line":2}},{"line":188,"address":[3071675,3071536],"length":1,"stats":{"Line":1}},{"line":191,"address":[3071665],"length":1,"stats":{"Line":3}},{"line":196,"address":[3071712],"length":1,"stats":{"Line":1}},{"line":197,"address":[2034489,2034480],"length":1,"stats":{"Line":4}},{"line":203,"address":[3071744],"length":1,"stats":{"Line":1}},{"line":204,"address":[3071756],"length":1,"stats":{"Line":1}},{"line":209,"address":[3071824],"length":1,"stats":{"Line":1}},{"line":210,"address":[3071864],"length":1,"stats":{"Line":1}},{"line":211,"address":[3071848],"length":1,"stats":{"Line":1}},{"line":217,"address":[3071936,3072195,3072224],"length":1,"stats":{"Line":1}},{"line":218,"address":[3071957,3072063],"length":1,"stats":{"Line":2}},{"line":219,"address":[3071973],"length":1,"stats":{"Line":1}},{"line":220,"address":[3072055],"length":1,"stats":{"Line":1}},{"line":222,"address":[3072157],"length":1,"stats":{"Line":1}},{"line":227,"address":[3072240,3072542,3072548],"length":1,"stats":{"Line":1}},{"line":228,"address":[3072410,3072261],"length":1,"stats":{"Line":2}},{"line":229,"address":[3072277],"length":1,"stats":{"Line":1}},{"line":230,"address":[3072362],"length":1,"stats":{"Line":1}},{"line":232,"address":[3072504],"length":1,"stats":{"Line":1}},{"line":251,"address":[2188224],"length":1,"stats":{"Line":1}},{"line":255,"address":[2034579,2034512,2034614],"length":1,"stats":{"Line":4}}],"covered":92,"coverable":92},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","shared","factory.rs"],"content":"use std::collections::HashMap;\nuse uuid7::uuid7;\n\n/// A factory trait for creating domain entities\npub trait EntityFactory\u003cT, P = ()\u003e {\n    /// Create a new entity with the given parameters\n    fn create(\u0026self, params: P) -\u003e T;\n\n    /// Create a new entity with default parameters\n    fn create_default(\u0026self) -\u003e T\n    where\n        P: Default;\n}\n\n/// A factory trait for creating entities with validation\npub trait ValidatedEntityFactory\u003cT, P = ()\u003e {\n    type Error;\n\n    /// Create a new entity with validation\n    fn create_validated(\u0026self, params: P) -\u003e Result\u003cT, Self::Error\u003e;\n}\n\n/// A factory for creating entities with specific configurations\npub trait ConfigurableEntityFactory\u003cT, P = ()\u003e {\n    /// Create an entity with configuration\n    fn create_with_config(\u0026self, params: P, config: HashMap\u003cString, String\u003e) -\u003e T;\n}\n\n/// A factory registry that can hold multiple factories\npub struct FactoryRegistry\u003cT, P = ()\u003e {\n    factories: HashMap\u003cString, Box\u003cdyn EntityFactory\u003cT, P\u003e\u003e\u003e,\n}\n\nimpl\u003cT, P\u003e FactoryRegistry\u003cT, P\u003e {\n    /// Create a new factory registry\n    pub fn new() -\u003e Self {\n        Self {\n            factories: HashMap::new(),\n        }\n    }\n\n    /// Register a factory with a name\n    pub fn register\u003cF\u003e(\u0026mut self, name: impl Into\u003cString\u003e, factory: F)\n    where\n        F: EntityFactory\u003cT, P\u003e + 'static, // 'static necessário para Box\u003cdyn\u003e\n    {\n        self.factories.insert(name.into(), Box::new(factory));\n    }\n\n    /// Get a factory by name\n    pub fn get(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026dyn EntityFactory\u003cT, P\u003e\u003e {\n        self.factories.get(name).map(|f| f.as_ref())\n    }\n\n    /// Create an entity using the specified factory\n    pub fn create(\u0026self, factory_name: \u0026str, params: P) -\u003e Option\u003cT\u003e {\n        self.get(factory_name).map(|f| f.create(params))\n    }\n}\n\nimpl\u003cT, P\u003e Default for FactoryRegistry\u003cT, P\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A simple factory implementation for basic entity creation\npub struct SimpleFactory\u003cF, T, P\u003e {\n    creator: F,\n    _phantom: std::marker::PhantomData\u003c(T, P)\u003e,\n}\n\nimpl\u003cF, T, P\u003e SimpleFactory\u003cF, T, P\u003e\nwhere\n    F: Fn(P) -\u003e T,\n{\n    /// Create a new simple factory\n    pub fn new(creator: F) -\u003e Self {\n        Self {\n            creator,\n            _phantom: std::marker::PhantomData,\n        }\n    }\n}\n\nimpl\u003cF, T, P\u003e EntityFactory\u003cT, P\u003e for SimpleFactory\u003cF, T, P\u003e\nwhere\n    F: Fn(P) -\u003e T,\n{\n    fn create(\u0026self, params: P) -\u003e T {\n        (self.creator)(params)\n    }\n\n    fn create_default(\u0026self) -\u003e T\n    where\n        P: Default,\n    {\n        (self.creator)(Default::default())\n    }\n}\n\n/// A factory that creates entities with unique IDs\npub struct UniqueIdFactory\u003cF, T, P\u003e {\n    creator: F,\n    _phantom: std::marker::PhantomData\u003c(T, P)\u003e,\n}\n\nimpl\u003cF, T, P\u003e UniqueIdFactory\u003cF, T, P\u003e\nwhere\n    F: Fn(P, uuid7::Uuid) -\u003e T,\n{\n    /// Create a new unique ID factory\n    pub fn new(creator: F) -\u003e Self {\n        Self {\n            creator,\n            _phantom: std::marker::PhantomData,\n        }\n    }\n}\n\nimpl\u003cF, T, P\u003e EntityFactory\u003cT, P\u003e for UniqueIdFactory\u003cF, T, P\u003e\nwhere\n    F: Fn(P, uuid7::Uuid) -\u003e T,\n    P: Default,\n{\n    fn create(\u0026self, params: P) -\u003e T {\n        (self.creator)(params, uuid7())\n    }\n\n    fn create_default(\u0026self) -\u003e T {\n        (self.creator)(Default::default(), uuid7())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Mock entity types for testing\n    #[derive(Debug, Clone, PartialEq)]\n    struct MockEntity {\n        id: String,\n        name: String,\n        value: u32,\n    }\n\n    #[derive(Debug, Clone, PartialEq)]\n    struct MockParams {\n        name: String,\n        value: u32,\n    }\n\n    impl Default for MockParams {\n        fn default() -\u003e Self {\n            Self {\n                name: \"default\".to_string(),\n                value: 42,\n            }\n        }\n    }\n\n    // Mock factory implementations for testing\n    struct MockEntityFactory;\n\n    impl EntityFactory\u003cMockEntity, MockParams\u003e for MockEntityFactory {\n        fn create(\u0026self, params: MockParams) -\u003e MockEntity {\n            MockEntity {\n                id: \"mock-001\".to_string(),\n                name: params.name,\n                value: params.value,\n            }\n        }\n\n        fn create_default(\u0026self) -\u003e MockEntity {\n            MockEntity {\n                id: \"mock-default\".to_string(),\n                name: \"default\".to_string(),\n                value: 42,\n            }\n        }\n    }\n\n    struct MockValidatedFactory;\n\n    impl ValidatedEntityFactory\u003cMockEntity, MockParams\u003e for MockValidatedFactory {\n        type Error = String;\n\n        fn create_validated(\u0026self, params: MockParams) -\u003e Result\u003cMockEntity, Self::Error\u003e {\n            if params.value \u003e 100 {\n                Err(\"Value too high\".to_string())\n            } else {\n                Ok(MockEntity {\n                    id: \"validated-001\".to_string(),\n                    name: params.name,\n                    value: params.value,\n                })\n            }\n        }\n    }\n\n    struct MockConfigurableFactory;\n\n    impl ConfigurableEntityFactory\u003cMockEntity, MockParams\u003e for MockConfigurableFactory {\n        fn create_with_config(\u0026self, params: MockParams, config: HashMap\u003cString, String\u003e) -\u003e MockEntity {\n            let default_prefix = \"config\".to_string();\n            let prefix = config.get(\"prefix\").unwrap_or(\u0026default_prefix);\n            MockEntity {\n                id: format!(\"{}-001\", prefix),\n                name: params.name,\n                value: params.value,\n            }\n        }\n    }\n\n    // Tests for EntityFactory trait\n    #[test]\n    fn test_entity_factory_create() {\n        let factory = MockEntityFactory;\n        let params = MockParams {\n            name: \"test\".to_string(),\n            value: 123,\n        };\n        \n        let entity = factory.create(params);\n        \n        assert_eq!(entity.id, \"mock-001\");\n        assert_eq!(entity.name, \"test\");\n        assert_eq!(entity.value, 123);\n    }\n\n    #[test]\n    fn test_entity_factory_create_default() {\n        let factory = MockEntityFactory;\n        let entity = factory.create_default();\n        \n        assert_eq!(entity.id, \"mock-default\");\n        assert_eq!(entity.name, \"default\");\n        assert_eq!(entity.value, 42);\n    }\n\n    // Tests for ValidatedEntityFactory trait\n    #[test]\n    fn test_validated_entity_factory_success() {\n        let factory = MockValidatedFactory;\n        let params = MockParams {\n            name: \"valid\".to_string(),\n            value: 50,\n        };\n        \n        let result = factory.create_validated(params);\n        assert!(result.is_ok());\n        \n        let entity = result.unwrap();\n        assert_eq!(entity.id, \"validated-001\");\n        assert_eq!(entity.name, \"valid\");\n        assert_eq!(entity.value, 50);\n    }\n\n    #[test]\n    fn test_validated_entity_factory_failure() {\n        let factory = MockValidatedFactory;\n        let params = MockParams {\n            name: \"invalid\".to_string(),\n            value: 150,\n        };\n        \n        let result = factory.create_validated(params);\n        assert!(result.is_err());\n        assert_eq!(result.unwrap_err(), \"Value too high\");\n    }\n\n    // Tests for ConfigurableEntityFactory trait\n    #[test]\n    fn test_configurable_entity_factory_with_config() {\n        let factory = MockConfigurableFactory;\n        let params = MockParams {\n            name: \"config\".to_string(),\n            value: 75,\n        };\n        let mut config = HashMap::new();\n        config.insert(\"prefix\".to_string(), \"custom\".to_string());\n        \n        let entity = factory.create_with_config(params, config);\n        \n        assert_eq!(entity.id, \"custom-001\");\n        assert_eq!(entity.name, \"config\");\n        assert_eq!(entity.value, 75);\n    }\n\n    #[test]\n    fn test_configurable_entity_factory_without_config() {\n        let factory = MockConfigurableFactory;\n        let params = MockParams {\n            name: \"no-config\".to_string(),\n            value: 25,\n        };\n        let config = HashMap::new();\n        \n        let entity = factory.create_with_config(params, config);\n        \n        assert_eq!(entity.id, \"config-001\");\n        assert_eq!(entity.name, \"no-config\");\n        assert_eq!(entity.value, 25);\n    }\n\n    // Tests for FactoryRegistry\n    #[test]\n    fn test_factory_registry_new() {\n        let registry: FactoryRegistry\u003cMockEntity, MockParams\u003e = FactoryRegistry::new();\n        assert_eq!(registry.factories.len(), 0);\n    }\n\n    #[test]\n    fn test_factory_registry_default() {\n        let registry: FactoryRegistry\u003cMockEntity, MockParams\u003e = FactoryRegistry::default();\n        assert_eq!(registry.factories.len(), 0);\n    }\n\n    #[test]\n    fn test_factory_registry_register_and_get() {\n        let mut registry = FactoryRegistry::new();\n        let factory = MockEntityFactory;\n        \n        registry.register(\"mock\", factory);\n        \n        let retrieved_factory = registry.get(\"mock\");\n        assert!(retrieved_factory.is_some());\n        \n        let retrieved_factory = retrieved_factory.unwrap();\n        let entity = retrieved_factory.create(MockParams {\n            name: \"retrieved\".to_string(),\n            value: 99,\n        });\n        \n        assert_eq!(entity.id, \"mock-001\");\n        assert_eq!(entity.name, \"retrieved\");\n        assert_eq!(entity.value, 99);\n    }\n\n    #[test]\n    fn test_factory_registry_get_nonexistent() {\n        let registry: FactoryRegistry\u003cMockEntity, MockParams\u003e = FactoryRegistry::new();\n        let factory = registry.get(\"nonexistent\");\n        assert!(factory.is_none());\n    }\n\n    #[test]\n    fn test_factory_registry_create() {\n        let mut registry = FactoryRegistry::new();\n        let factory = MockEntityFactory;\n        \n        registry.register(\"mock\", factory);\n        \n        let entity = registry.create(\"mock\", MockParams {\n            name: \"created\".to_string(),\n            value: 88,\n        });\n        \n        assert!(entity.is_some());\n        let entity = entity.unwrap();\n        assert_eq!(entity.id, \"mock-001\");\n        assert_eq!(entity.name, \"created\");\n        assert_eq!(entity.value, 88);\n    }\n\n    #[test]\n    fn test_factory_registry_create_nonexistent() {\n        let registry: FactoryRegistry\u003cMockEntity, MockParams\u003e = FactoryRegistry::new();\n        let entity = registry.create(\"nonexistent\", MockParams {\n            name: \"test\".to_string(),\n            value: 0,\n        });\n        assert!(entity.is_none());\n    }\n\n    // Tests for SimpleFactory\n    #[test]\n    fn test_simple_factory_new() {\n        let creator = |params: MockParams| MockEntity {\n            id: \"simple\".to_string(),\n            name: params.name,\n            value: params.value,\n        };\n        \n        let factory = SimpleFactory::new(creator);\n        let params = MockParams {\n            name: \"simple_test\".to_string(),\n            value: 33,\n        };\n        \n        let entity = factory.create(params);\n        assert_eq!(entity.id, \"simple\");\n        assert_eq!(entity.name, \"simple_test\");\n        assert_eq!(entity.value, 33);\n    }\n\n    #[test]\n    fn test_simple_factory_create_default() {\n        let creator = |params: MockParams| MockEntity {\n            id: \"simple_default\".to_string(),\n            name: params.name,\n            value: params.value,\n        };\n        \n        let factory = SimpleFactory::new(creator);\n        let entity = factory.create_default();\n        \n        assert_eq!(entity.id, \"simple_default\");\n        assert_eq!(entity.name, \"default\");\n        assert_eq!(entity.value, 42);\n    }\n\n    // Tests for UniqueIdFactory\n    #[test]\n    fn test_unique_id_factory_new() {\n        let creator = |params: MockParams, id: uuid7::Uuid| MockEntity {\n            id: id.to_string(),\n            name: params.name,\n            value: params.value,\n        };\n        \n        let factory = UniqueIdFactory::new(creator);\n        let params = MockParams {\n            name: \"unique\".to_string(),\n            value: 55,\n        };\n        \n        let entity = factory.create(params);\n        assert!(!entity.id.is_empty());\n        assert_eq!(entity.name, \"unique\");\n        assert_eq!(entity.value, 55);\n    }\n\n    #[test]\n    fn test_unique_id_factory_create_default() {\n        let creator = |params: MockParams, id: uuid7::Uuid| MockEntity {\n            id: id.to_string(),\n            name: params.name,\n            value: params.value,\n        };\n        \n        let factory = UniqueIdFactory::new(creator);\n        let entity = factory.create_default();\n        \n        assert!(!entity.id.is_empty());\n        assert_eq!(entity.name, \"default\");\n        assert_eq!(entity.value, 42);\n    }\n\n    #[test]\n    fn test_unique_id_factory_generates_different_ids() {\n        let creator = |params: MockParams, id: uuid7::Uuid| MockEntity {\n            id: id.to_string(),\n            name: params.name,\n            value: params.value,\n        };\n        \n        let factory = UniqueIdFactory::new(creator);\n        let params = MockParams {\n            name: \"unique_test\".to_string(),\n            value: 10,\n        };\n        \n        let entity1 = factory.create(params.clone());\n        let entity2 = factory.create(params);\n        \n        assert_ne!(entity1.id, entity2.id);\n        assert_eq!(entity1.name, entity2.name);\n        assert_eq!(entity1.value, entity2.value);\n    }\n\n    // Tests for complex scenarios\n    #[test]\n    fn test_factory_registry_multiple_factories() {\n        let mut registry = FactoryRegistry::new();\n        \n        // Register multiple factories\n        registry.register(\"mock\", MockEntityFactory);\n        registry.register(\"simple\", SimpleFactory::new(|params: MockParams| MockEntity {\n            id: \"simple\".to_string(),\n            name: params.name,\n            value: params.value,\n        }));\n        \n        // Test both factories\n        let mock_entity = registry.create(\"mock\", MockParams {\n            name: \"mock_test\".to_string(),\n            value: 111,\n        }).unwrap();\n        \n        let simple_entity = registry.create(\"simple\", MockParams {\n            name: \"simple_test\".to_string(),\n            value: 222,\n        }).unwrap();\n        \n        assert_eq!(mock_entity.id, \"mock-001\");\n        assert_eq!(simple_entity.id, \"simple\");\n        assert_ne!(mock_entity.id, simple_entity.id);\n    }\n\n    #[test]\n    fn test_factory_trait_objects() {\n        let mut registry = FactoryRegistry::new();\n        let factory = MockEntityFactory;\n        \n        registry.register(\"trait_object\", factory);\n        \n        // Test that we can use the factory through trait objects\n        let factory_ref = registry.get(\"trait_object\").unwrap();\n        let entity = factory_ref.create(MockParams {\n            name: \"trait_test\".to_string(),\n            value: 77,\n        });\n        \n        assert_eq!(entity.id, \"mock-001\");\n        assert_eq!(entity.name, \"trait_test\");\n        assert_eq!(entity.value, 77);\n    }\n\n    // Tests for edge cases\n    #[test]\n    fn test_factory_with_empty_params() {\n        let creator = |_: ()| MockEntity {\n            id: \"empty\".to_string(),\n            name: \"empty_params\".to_string(),\n            value: 0,\n        };\n        \n        let factory = SimpleFactory::new(creator);\n        let entity = factory.create(());\n        \n        assert_eq!(entity.id, \"empty\");\n        assert_eq!(entity.name, \"empty_params\");\n        assert_eq!(entity.value, 0);\n    }\n\n    #[test]\n    fn test_factory_registry_overwrite() {\n        let mut registry = FactoryRegistry::new();\n        \n        // Register first factory\n        registry.register(\"overwrite\", MockEntityFactory);\n        \n        // Register second factory with same name\n        let creator = |params: MockParams| MockEntity {\n            id: \"overwritten\".to_string(),\n            name: params.name,\n            value: params.value,\n        };\n        registry.register(\"overwrite\", SimpleFactory::new(creator));\n        \n        // Should get the second factory\n        let entity = registry.create(\"overwrite\", MockParams {\n            name: \"overwrite_test\".to_string(),\n            value: 999,\n        }).unwrap();\n        \n        assert_eq!(entity.id, \"overwritten\");\n        assert_eq!(entity.name, \"overwrite_test\");\n        assert_eq!(entity.value, 999);\n    }\n\n    // Additional tests for better coverage\n    #[test]\n    fn test_factory_registry_clear() {\n        let mut registry = FactoryRegistry::new();\n        registry.register(\"test\", MockEntityFactory);\n        assert_eq!(registry.factories.len(), 1);\n        \n        // Clear all factories (this would require adding a clear method)\n        // For now, we test the current behavior\n        assert!(registry.get(\"test\").is_some());\n    }\n\n    #[test]\n    fn test_factory_registry_iteration() {\n        let mut registry = FactoryRegistry::new();\n        registry.register(\"first\", MockEntityFactory);\n        registry.register(\"second\", MockEntityFactory);\n        \n        // Test that we can access multiple factories\n        let first = registry.get(\"first\");\n        let second = registry.get(\"second\");\n        \n        assert!(first.is_some());\n        assert!(second.is_some());\n        \n        // Test that both factories work correctly\n        let entity1 = first.unwrap().create(MockParams {\n            name: \"first_test\".to_string(),\n            value: 100,\n        });\n        let entity2 = second.unwrap().create(MockParams {\n            name: \"second_test\".to_string(),\n            value: 200,\n        });\n        \n        assert_eq!(entity1.name, \"first_test\");\n        assert_eq!(entity2.name, \"second_test\");\n        assert_ne!(entity1.name, entity2.name);\n    }\n\n    #[test]\n    fn test_factory_with_complex_params() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct ComplexParams {\n            name: String,\n            value: u32,\n            metadata: HashMap\u003cString, String\u003e,\n        }\n\n        impl Default for ComplexParams {\n            fn default() -\u003e Self {\n                let mut metadata = HashMap::new();\n                metadata.insert(\"version\".to_string(), \"1.0\".to_string());\n                metadata.insert(\"type\".to_string(), \"default\".to_string());\n                \n                Self {\n                    name: \"complex_default\".to_string(),\n                    value: 100,\n                    metadata,\n                }\n            }\n        }\n\n        let creator = |params: ComplexParams| MockEntity {\n            id: format!(\"complex-{}\", params.value),\n            name: params.name,\n            value: params.value,\n        };\n        \n        let factory = SimpleFactory::new(creator);\n        let params = ComplexParams {\n            name: \"complex_test\".to_string(),\n            value: 200,\n            metadata: {\n                let mut m = HashMap::new();\n                m.insert(\"version\".to_string(), \"2.0\".to_string());\n                m.insert(\"type\".to_string(), \"test\".to_string());\n                m\n            },\n        };\n        \n        let entity = factory.create(params);\n        assert_eq!(entity.id, \"complex-200\");\n        assert_eq!(entity.name, \"complex_test\");\n        assert_eq!(entity.value, 200);\n    }\n\n    #[test]\n    fn test_factory_with_unit_params() {\n        let creator = |_: ()| MockEntity {\n            id: \"unit\".to_string(),\n            name: \"unit_params\".to_string(),\n            value: 0,\n        };\n        \n        let factory = SimpleFactory::new(creator);\n        let entity = factory.create(());\n        \n        assert_eq!(entity.id, \"unit\");\n        assert_eq!(entity.name, \"unit_params\");\n        assert_eq!(entity.value, 0);\n    }\n\n    #[test]\n    fn test_factory_with_reference_params() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct RefParams\u003c'a\u003e {\n            name: \u0026'a str,\n            value: u32,\n        }\n\n        let creator = |params: RefParams| MockEntity {\n            id: format!(\"ref-{}\", params.value),\n            name: params.name.to_string(),\n            value: params.value,\n        };\n        \n        let factory = SimpleFactory::new(creator);\n        let params = RefParams {\n            name: \"reference_test\",\n            value: 300,\n        };\n        \n        let entity = factory.create(params);\n        assert_eq!(entity.id, \"ref-300\");\n        assert_eq!(entity.name, \"reference_test\");\n        assert_eq!(entity.value, 300);\n    }\n\n    #[test]\n    fn test_factory_with_optional_params() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct OptionalParams {\n            name: Option\u003cString\u003e,\n            value: Option\u003cu32\u003e,\n        }\n\n        impl Default for OptionalParams {\n            fn default() -\u003e Self {\n                Self {\n                    name: Some(\"optional_default\".to_string()),\n                    value: Some(50),\n                }\n            }\n        }\n\n        let creator = |params: OptionalParams| MockEntity {\n            id: \"optional\".to_string(),\n            name: params.name.unwrap_or_else(|| \"unknown\".to_string()),\n            value: params.value.unwrap_or(0),\n        };\n        \n        let factory = SimpleFactory::new(creator);\n        \n        // Test with Some values\n        let params = OptionalParams {\n            name: Some(\"optional_test\".to_string()),\n            value: Some(150),\n        };\n        let entity = factory.create(params);\n        assert_eq!(entity.name, \"optional_test\");\n        assert_eq!(entity.value, 150);\n        \n        // Test with None values\n        let params = OptionalParams {\n            name: None,\n            value: None,\n        };\n        let entity = factory.create(params);\n        assert_eq!(entity.name, \"unknown\");\n        assert_eq!(entity.value, 0);\n    }\n\n    #[test]\n    fn test_factory_with_enum_params() {\n        #[derive(Debug, Clone, PartialEq)]\n        enum EnumParams {\n            Simple { name: String },\n            Complex { name: String, value: u32 },\n        }\n\n        impl Default for EnumParams {\n            fn default() -\u003e Self {\n                Self::Simple {\n                    name: \"enum_default\".to_string(),\n                }\n            }\n        }\n\n        let creator = |params: EnumParams| MockEntity {\n            id: \"enum\".to_string(),\n            name: match \u0026params {\n                EnumParams::Simple { name } =\u003e name.clone(),\n                EnumParams::Complex { name, .. } =\u003e name.clone(),\n            },\n            value: match params {\n                EnumParams::Simple { .. } =\u003e 0,\n                EnumParams::Complex { value, .. } =\u003e value,\n            },\n        };\n        \n        let factory = SimpleFactory::new(creator);\n        \n        // Test Simple variant\n        let params = EnumParams::Simple {\n            name: \"simple_enum\".to_string(),\n        };\n        let entity = factory.create(params);\n        assert_eq!(entity.name, \"simple_enum\");\n        assert_eq!(entity.value, 0);\n        \n        // Test Complex variant\n        let params = EnumParams::Complex {\n            name: \"complex_enum\".to_string(),\n            value: 400,\n        };\n        let entity = factory.create(params);\n        assert_eq!(entity.name, \"complex_enum\");\n        assert_eq!(entity.value, 400);\n    }\n\n    #[test]\n    fn test_factory_with_generic_entity() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct GenericEntity\u003cT\u003e {\n            id: String,\n            data: T,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct GenericParams\u003cT\u003e {\n            data: T,\n        }\n\n        impl\u003cT: Default\u003e Default for GenericParams\u003cT\u003e {\n            fn default() -\u003e Self {\n                Self {\n                    data: Default::default(),\n                }\n            }\n        }\n\n        let creator = |params: GenericParams\u003cString\u003e| GenericEntity {\n            id: \"generic\".to_string(),\n            data: params.data,\n        };\n        \n        let factory = SimpleFactory::new(creator);\n        let params = GenericParams {\n            data: \"generic_test\".to_string(),\n        };\n        \n        let entity = factory.create(params);\n        assert_eq!(entity.id, \"generic\");\n        assert_eq!(entity.data, \"generic_test\");\n    }\n\n    #[test]\n    fn test_factory_with_phantom_data() {\n        use std::marker::PhantomData;\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct PhantomEntity\u003cT\u003e {\n            id: String,\n            _phantom: PhantomData\u003cT\u003e,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct PhantomParams\u003cT\u003e {\n            _phantom: PhantomData\u003cT\u003e,\n        }\n\n        impl\u003cT\u003e Default for PhantomParams\u003cT\u003e {\n            fn default() -\u003e Self {\n                Self {\n                    _phantom: PhantomData,\n                }\n            }\n        }\n\n        let creator = |_: PhantomParams\u003cString\u003e| PhantomEntity {\n            id: \"phantom\".to_string(),\n            _phantom: PhantomData::\u003cString\u003e,\n        };\n        \n        let factory = SimpleFactory::new(creator);\n        let params = PhantomParams::\u003cString\u003e::default();\n        \n        let entity = factory.create(params);\n        assert_eq!(entity.id, \"phantom\");\n    }\n\n    #[test]\n    fn test_factory_with_custom_error_types() {\n        #[derive(Debug, Clone, PartialEq)]\n        struct CustomError {\n            message: String,\n            code: u32,\n        }\n\n        #[derive(Debug, Clone, PartialEq)]\n        struct CustomParams {\n            name: String,\n            value: u32,\n        }\n\n        struct CustomValidatedFactory;\n\n        impl ValidatedEntityFactory\u003cMockEntity, CustomParams\u003e for CustomValidatedFactory {\n            type Error = CustomError;\n\n            fn create_validated(\u0026self, params: CustomParams) -\u003e Result\u003cMockEntity, Self::Error\u003e {\n                if params.value == 0 {\n                    Err(CustomError {\n                        message: \"Value cannot be zero\".to_string(),\n                        code: 1001,\n                    })\n                } else if params.name.is_empty() {\n                    Err(CustomError {\n                        message: \"Name cannot be empty\".to_string(),\n                        code: 1002,\n                    })\n                } else {\n                    Ok(MockEntity {\n                        id: \"custom-001\".to_string(),\n                        name: params.name,\n                        value: params.value,\n                    })\n                }\n            }\n        }\n\n        let factory = CustomValidatedFactory;\n        \n        // Test success case\n        let params = CustomParams {\n            name: \"custom_test\".to_string(),\n            value: 100,\n        };\n        let result = factory.create_validated(params);\n        assert!(result.is_ok());\n        \n        let entity = result.unwrap();\n        assert_eq!(entity.id, \"custom-001\");\n        assert_eq!(entity.name, \"custom_test\");\n        assert_eq!(entity.value, 100);\n        \n        // Test zero value error\n        let params = CustomParams {\n            name: \"zero_test\".to_string(),\n            value: 0,\n        };\n        let result = factory.create_validated(params);\n        assert!(result.is_err());\n        \n        if let Err(error) = result {\n            assert_eq!(error.message, \"Value cannot be zero\");\n            assert_eq!(error.code, 1001);\n        }\n        \n        // Test empty name error\n        let params = CustomParams {\n            name: \"\".to_string(),\n            value: 50,\n        };\n        let result = factory.create_validated(params);\n        assert!(result.is_err());\n        \n        if let Err(error) = result {\n            assert_eq!(error.message, \"Name cannot be empty\");\n            assert_eq!(error.code, 1002);\n        }\n    }\n}\n","traces":[{"line":36,"address":[820256],"length":1,"stats":{"Line":1}},{"line":38,"address":[820270],"length":1,"stats":{"Line":2}},{"line":43,"address":[820608,821154,821160,820866,820872,820896,820584,820320,820578],"length":1,"stats":{"Line":4}},{"line":47,"address":[820708,821135,820442,820923,820635,820347,820847,820420,821018,820730,820996,820559],"length":1,"stats":{"Line":8}},{"line":51,"address":[821184],"length":1,"stats":{"Line":2}},{"line":52,"address":[821202,821241,821232],"length":1,"stats":{"Line":5}},{"line":56,"address":[821264,821490,821466],"length":1,"stats":{"Line":1}},{"line":57,"address":[821342,821539,821419,821504],"length":1,"stats":{"Line":4}},{"line":62,"address":[821600],"length":1,"stats":{"Line":1}},{"line":63,"address":[821608],"length":1,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[822448,822096,822208,821904,821984,821824,822416,822128,822288,822352,822016],"length":1,"stats":{"Line":11}},{"line":91,"address":[822112,822243,822432,821921,822465,822000,821841,822145,822304,822033,822368],"length":1,"stats":{"Line":11}},{"line":94,"address":[822528,822640,822752],"length":1,"stats":{"Line":1}},{"line":98,"address":[822552,822664,822776],"length":1,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[823376,823111,823351,823136,822912,823152],"length":1,"stats":{"Line":2}},{"line":127,"address":[823182,822942,823129,823369],"length":1,"stats":{"Line":2}},{"line":130,"address":[823609,823584,823392],"length":1,"stats":{"Line":1}},{"line":131,"address":[823602,823422,823464],"length":1,"stats":{"Line":1}}],"covered":18,"coverable":20},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","shared","mod.rs"],"content":"pub mod command;\npub mod convertable;\npub mod errors;\npub mod factory;\npub mod observer;\npub mod repository;\npub mod specification;\npub mod validatable;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","shared","observer.rs"],"content":"use std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\nuse uuid7::Uuid;\n\n/// A domain event that can be observed\n#[allow(dead_code)]\npub trait DomainEvent: Send + Sync {\n    /// Get the event type\n    fn event_type(\u0026self) -\u003e \u0026str;\n\n    /// Get the event ID\n    fn event_id(\u0026self) -\u003e Uuid;\n\n    /// Get the timestamp when the event occurred\n    fn timestamp(\u0026self) -\u003e chrono::DateTime\u003cchrono::Utc\u003e;\n\n    /// Get the aggregate ID that generated this event\n    fn aggregate_id(\u0026self) -\u003e \u0026str;\n\n    /// Get the event version\n    fn version(\u0026self) -\u003e u64;\n\n    /// Get the event data as YAML\n    fn data(\u0026self) -\u003e serde_yaml::Value;\n}\n\n/// An observer that can handle domain events\n#[allow(dead_code)]\npub trait EventObserver: Send + Sync {\n    /// Handle a domain event\n    fn handle_event(\u0026self, event: \u0026dyn DomainEvent) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e;\n\n    /// Get the observer name\n    fn name(\u0026self) -\u003e \u0026str;\n\n    /// Check if the observer is interested in a specific event type\n    fn is_interested_in(\u0026self, _event_type: \u0026str) -\u003e bool {\n        true\n    }\n}\n\n/// An event bus that manages event publishing and subscription\n#[allow(dead_code)]\npub struct EventBus {\n    observers: Arc\u003cMutex\u003cObserverMap\u003e\u003e,\n}\n\nimpl EventBus {\n    /// Create a new event bus\n    pub fn new() -\u003e Self {\n        Self {\n            observers: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    /// Subscribe an observer to a specific event type\n    pub fn subscribe(\u0026self, event_type: impl Into\u003cString\u003e, observer: Arc\u003cdyn EventObserver\u003e) {\n        let mut observers = self.observers.lock().unwrap();\n        observers.entry(event_type.into()).or_default().push(observer);\n    }\n\n    /// Unsubscribe an observer from a specific event type\n    pub fn unsubscribe(\u0026self, event_type: \u0026str, observer_name: \u0026str) {\n        let mut observers = self.observers.lock().unwrap();\n        if let Some(observer_list) = observers.get_mut(event_type) {\n            observer_list.retain(|obs| obs.name() != observer_name);\n        }\n    }\n\n    /// Publish an event to all interested observers\n    pub fn publish(\u0026self, event: \u0026dyn DomainEvent) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n        let event_type = event.event_type();\n        let observers = self.observers.lock().unwrap();\n\n        if let Some(observer_list) = observers.get(event_type) {\n            for observer in observer_list {\n                if observer.is_interested_in(event_type)\n                    \u0026\u0026 let Err(e) = observer.handle_event(event)\n                {\n                    eprintln!(\"Observer {} failed to handle event: {}\", observer.name(), e);\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Publish an event asynchronously\n    pub fn publish_async(\u0026self, event: Box\u003cdyn DomainEvent + Send\u003e) {\n        let event_bus = self.clone();\n        std::thread::spawn(move || {\n            if let Err(e) = event_bus.publish(event.as_ref()) {\n                eprintln!(\"Failed to publish event asynchronously: {}\", e);\n            }\n        });\n    }\n\n    /// Get the number of observers for a specific event type\n    pub fn observer_count(\u0026self, event_type: \u0026str) -\u003e usize {\n        let observers = self.observers.lock().unwrap();\n        observers.get(event_type).map_or(0, |list| list.len())\n    }\n\n    /// Get all event types that have observers\n    pub fn event_types(\u0026self) -\u003e Vec\u003cString\u003e {\n        let observers = self.observers.lock().unwrap();\n        observers.keys().cloned().collect()\n    }\n}\n\nimpl Clone for EventBus {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            observers: Arc::clone(\u0026self.observers),\n        }\n    }\n}\n\nimpl Default for EventBus {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A simple event implementation\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub struct SimpleDomainEvent {\n    pub event_type: String,\n    pub event_id: Uuid,\n    pub timestamp: chrono::DateTime\u003cchrono::Utc\u003e,\n    pub aggregate_id: String,\n    pub version: u64,\n    pub data: serde_yaml::Value,\n}\n\nimpl SimpleDomainEvent {\n    /// Create a new simple domain event\n    pub fn new(event_type: impl Into\u003cString\u003e, aggregate_id: impl Into\u003cString\u003e, data: serde_yaml::Value) -\u003e Self {\n        Self {\n            event_type: event_type.into(),\n            event_id: uuid7::uuid7(),\n            timestamp: chrono::Utc::now(),\n            aggregate_id: aggregate_id.into(),\n            version: 1,\n            data,\n        }\n    }\n\n    /// Set the event version\n    pub fn with_version(mut self, version: u64) -\u003e Self {\n        self.version = version;\n        self\n    }\n\n    /// Set the event timestamp\n    pub fn with_timestamp(mut self, timestamp: chrono::DateTime\u003cchrono::Utc\u003e) -\u003e Self {\n        self.timestamp = timestamp;\n        self\n    }\n}\n\nimpl DomainEvent for SimpleDomainEvent {\n    fn event_type(\u0026self) -\u003e \u0026str {\n        \u0026self.event_type\n    }\n\n    fn event_id(\u0026self) -\u003e Uuid {\n        self.event_id\n    }\n\n    fn timestamp(\u0026self) -\u003e chrono::DateTime\u003cchrono::Utc\u003e {\n        self.timestamp\n    }\n\n    fn aggregate_id(\u0026self) -\u003e \u0026str {\n        \u0026self.aggregate_id\n    }\n\n    fn version(\u0026self) -\u003e u64 {\n        self.version\n    }\n\n    fn data(\u0026self) -\u003e serde_yaml::Value {\n        self.data.clone()\n    }\n}\n\n// Type aliases to reduce complexity\ntype ObserverList = Vec\u003cArc\u003cdyn EventObserver\u003e\u003e;\ntype ObserverMap = HashMap\u003cString, ObserverList\u003e;\ntype EventHandler = Box\u003cdyn Fn(\u0026dyn DomainEvent) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e + Send + Sync\u003e;\n\n/// A simple observer implementation\n#[allow(dead_code)]\npub struct SimpleEventObserver {\n    name: String,\n    event_types: Vec\u003cString\u003e,\n    handler: EventHandler,\n}\n\nimpl SimpleEventObserver {\n    /// Create a new simple event observer\n    pub fn new\u003cF\u003e(name: impl Into\u003cString\u003e, event_types: Vec\u003cString\u003e, handler: F) -\u003e Self\n    where\n        F: for\u003c'a\u003e Fn(\u0026'a dyn DomainEvent) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e\n            + Send\n            + Sync\n            + 'static, // 'static necessário para Box\u003cdyn\u003e\n    {\n        Self {\n            name: name.into(),\n            event_types,\n            handler: Box::new(handler),\n        }\n    }\n\n    /// Create an observer that handles all event types\n    pub fn new_universal\u003cF\u003e(name: impl Into\u003cString\u003e, handler: F) -\u003e Self\n    where\n        F: for\u003c'a\u003e Fn(\u0026'a dyn DomainEvent) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e\n            + Send\n            + Sync\n            + 'static, // 'static necessário para Box\u003cdyn\u003e\n    {\n        Self {\n            name: name.into(),\n            event_types: Vec::new(),\n            handler: Box::new(handler),\n        }\n    }\n}\n\nimpl EventObserver for SimpleEventObserver {\n    fn handle_event(\u0026self, event: \u0026dyn DomainEvent) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n        (self.handler)(event)\n    }\n\n    fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    fn is_interested_in(\u0026self, event_type: \u0026str) -\u003e bool {\n        self.event_types.is_empty() || self.event_types.contains(\u0026event_type.to_string())\n    }\n}\n\n/// An event store that can persist events\n#[allow(dead_code)]\npub trait EventStore {\n    /// Store an event\n    fn store_event(\u0026self, event: \u0026dyn DomainEvent) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e;\n\n    /// Retrieve events for a specific aggregate\n    fn get_events(\n        \u0026self,\n        aggregate_id: \u0026str,\n    ) -\u003e Result\u003cVec\u003cBox\u003cdyn DomainEvent + Send\u003e\u003e, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e;\n\n    /// Retrieve events of a specific type\n    fn get_events_by_type(\n        \u0026self,\n        event_type: \u0026str,\n    ) -\u003e Result\u003cVec\u003cBox\u003cdyn DomainEvent + Send\u003e\u003e, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e;\n}\n\n/// An event replay mechanism\n#[allow(dead_code)]\npub struct EventReplayer {\n    event_store: Box\u003cdyn EventStore\u003e,\n    event_bus: EventBus,\n}\n\nimpl EventReplayer {\n    /// Create a new event replayer\n    pub fn new(event_store: Box\u003cdyn EventStore\u003e, event_bus: EventBus) -\u003e Self {\n        Self { event_store, event_bus }\n    }\n\n    /// Replay all events for a specific aggregate\n    pub fn replay_aggregate_events(\u0026self, aggregate_id: \u0026str) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n        let events = self.event_store.get_events(aggregate_id)?;\n\n        for event in events {\n            self.event_bus.publish(event.as_ref())?;\n        }\n\n        Ok(())\n    }\n\n    /// Replay all events of a specific type\n    pub fn replay_events_by_type(\u0026self, event_type: \u0026str) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n        let events = self.event_store.get_events_by_type(event_type)?;\n\n        for event in events {\n            self.event_bus.publish(event.as_ref())?;\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::Arc;\n\n    // Mock event store for testing\n    struct MockEventStore {\n        events: Vec\u003cBox\u003cdyn DomainEvent + Send\u003e\u003e,\n    }\n\n    impl MockEventStore {\n        fn new() -\u003e Self {\n            Self { events: Vec::new() }\n        }\n\n        fn add_event(\u0026mut self, event: Box\u003cdyn DomainEvent + Send\u003e) {\n            self.events.push(event);\n        }\n    }\n\n    impl EventStore for MockEventStore {\n        fn store_event(\u0026self, _event: \u0026dyn DomainEvent) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n            Ok(())\n        }\n\n        fn get_events(\u0026self, aggregate_id: \u0026str) -\u003e Result\u003cVec\u003cBox\u003cdyn DomainEvent + Send\u003e\u003e, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n            let filtered_events: Vec\u003cBox\u003cdyn DomainEvent + Send\u003e\u003e = self.events\n                .iter()\n                .filter(|event| event.aggregate_id() == aggregate_id)\n                .map(|event| {\n                    // Create a new SimpleDomainEvent with the same data\n                    let simple_event = SimpleDomainEvent {\n                        event_type: event.event_type().to_string(),\n                        event_id: event.event_id(),\n                        timestamp: event.timestamp(),\n                        aggregate_id: event.aggregate_id().to_string(),\n                        version: event.version(),\n                        data: event.data().clone(),\n                    };\n                    Box::new(simple_event) as Box\u003cdyn DomainEvent + Send\u003e\n                })\n                .collect();\n            Ok(filtered_events)\n        }\n\n        fn get_events_by_type(\u0026self, event_type: \u0026str) -\u003e Result\u003cVec\u003cBox\u003cdyn DomainEvent + Send\u003e\u003e, Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n            let filtered_events: Vec\u003cBox\u003cdyn DomainEvent + Send\u003e\u003e = self.events\n                .iter()\n                .filter(|event| event.event_type() == event_type)\n                .map(|event| {\n                    let simple_event = SimpleDomainEvent {\n                        event_type: event.event_type().to_string(),\n                        event_id: event.event_id(),\n                        timestamp: event.timestamp(),\n                        aggregate_id: event.aggregate_id().to_string(),\n                        version: event.version(),\n                        data: event.data().clone(),\n                    };\n                    Box::new(simple_event) as Box\u003cdyn DomainEvent + Send\u003e\n                })\n                .collect();\n            Ok(filtered_events)\n        }\n    }\n\n    // Mock observer for testing\n    struct MockEventObserver {\n        name: String,\n        event_types: Vec\u003cString\u003e,\n        handled_events: Arc\u003cMutex\u003cVec\u003cString\u003e\u003e\u003e,\n        should_fail: bool,\n    }\n\n    impl MockEventObserver {\n        fn new(name: \u0026str, event_types: Vec\u003cString\u003e) -\u003e Self {\n            Self {\n                name: name.to_string(),\n                event_types,\n                handled_events: Arc::new(Mutex::new(Vec::new())),\n                should_fail: false,\n            }\n        }\n\n        fn with_failure(mut self, should_fail: bool) -\u003e Self {\n            self.should_fail = should_fail;\n            self\n        }\n\n        fn get_handled_events(\u0026self) -\u003e Vec\u003cString\u003e {\n            self.handled_events.lock().unwrap().clone()\n        }\n    }\n\n    impl EventObserver for MockEventObserver {\n        fn handle_event(\u0026self, event: \u0026dyn DomainEvent) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n            if self.should_fail {\n                return Err(\"Mock observer failed\".into());\n            }\n\n            let mut events = self.handled_events.lock().unwrap();\n            events.push(format!(\"{}:{}\", event.event_type(), event.aggregate_id()));\n            Ok(())\n        }\n\n        fn name(\u0026self) -\u003e \u0026str {\n            \u0026self.name\n        }\n\n        fn is_interested_in(\u0026self, event_type: \u0026str) -\u003e bool {\n            self.event_types.is_empty() || self.event_types.contains(\u0026event_type.to_string())\n        }\n    }\n\n    // Tests for DomainEvent trait\n    #[test]\n    fn test_domain_event_trait_methods() {\n        let data = serde_yaml::to_value(\"test data\").unwrap();\n        let event = SimpleDomainEvent::new(\"test_event\", \"agg_001\", data.clone());\n        \n        assert_eq!(event.event_type(), \"test_event\");\n        assert_eq!(event.aggregate_id(), \"agg_001\");\n        assert_eq!(event.version(), 1);\n        assert_eq!(event.data(), data);\n        assert!(!event.event_id().to_string().is_empty());\n        assert!(event.timestamp() \u003c= chrono::Utc::now());\n    }\n\n    #[test]\n    fn test_simple_domain_event_new() {\n        let data = serde_yaml::to_value(\"event data\").unwrap();\n        let event = SimpleDomainEvent::new(\"user_created\", \"user_123\", data.clone());\n        \n        assert_eq!(event.event_type, \"user_created\");\n        assert_eq!(event.aggregate_id, \"user_123\");\n        assert_eq!(event.data, data);\n        assert_eq!(event.version, 1);\n    }\n\n    #[test]\n    fn test_simple_domain_event_with_version() {\n        let data = serde_yaml::to_value(\"versioned data\").unwrap();\n        let event = SimpleDomainEvent::new(\"versioned_event\", \"agg_002\", data)\n            .with_version(5);\n        \n        assert_eq!(event.version, 5);\n    }\n\n    #[test]\n    fn test_simple_domain_event_with_timestamp() {\n        let data = serde_yaml::to_value(\"timestamped data\").unwrap();\n        let timestamp = chrono::Utc::now();\n        let event = SimpleDomainEvent::new(\"timestamped_event\", \"agg_003\", data)\n            .with_timestamp(timestamp);\n        \n        assert_eq!(event.timestamp, timestamp);\n    }\n\n    // Tests for EventObserver trait\n    #[test]\n    fn test_event_observer_trait_methods() {\n        let observer = MockEventObserver::new(\"test_observer\", vec![\"test_event\".to_string()]);\n        \n        assert_eq!(observer.name(), \"test_observer\");\n        assert!(observer.is_interested_in(\"test_event\"));\n        assert!(!observer.is_interested_in(\"other_event\"));\n    }\n\n    #[test]\n    fn test_event_observer_universal() {\n        let observer = MockEventObserver::new(\"universal_observer\", vec![]);\n        \n        assert!(observer.is_interested_in(\"any_event\"));\n        assert!(observer.is_interested_in(\"another_event\"));\n    }\n\n    // Tests for SimpleEventObserver\n    #[test]\n    fn test_simple_event_observer_new() {\n        let observer = SimpleEventObserver::new(\n            \"simple_observer\",\n            vec![\"user_created\".to_string(), \"user_updated\".to_string()],\n            |_event| Ok(()),\n        );\n        \n        assert_eq!(observer.name(), \"simple_observer\");\n        assert!(observer.is_interested_in(\"user_created\"));\n        assert!(observer.is_interested_in(\"user_updated\"));\n        assert!(!observer.is_interested_in(\"user_deleted\"));\n    }\n\n    #[test]\n    fn test_simple_event_observer_new_universal() {\n        let observer = SimpleEventObserver::new_universal(\n            \"universal_observer\",\n            |_event| Ok(()),\n        );\n        \n        assert_eq!(observer.name(), \"universal_observer\");\n        assert!(observer.is_interested_in(\"any_event\"));\n        assert!(observer.is_interested_in(\"another_event\"));\n    }\n\n    #[test]\n    fn test_simple_event_observer_handle_event() {\n        let handled_events = Arc::new(Mutex::new(Vec::new()));\n        let events_clone = Arc::clone(\u0026handled_events);\n        \n        let observer = SimpleEventObserver::new(\n            \"handler_observer\",\n            vec![\"test_event\".to_string()],\n            move |event| {\n                let mut events = events_clone.lock().unwrap();\n                events.push(event.event_type().to_string());\n                Ok(())\n            },\n        );\n        \n        let data = serde_yaml::to_value(\"test\").unwrap();\n        let event = SimpleDomainEvent::new(\"test_event\", \"agg_004\", data);\n        \n        let result = observer.handle_event(\u0026event);\n        assert!(result.is_ok());\n        \n        let events = handled_events.lock().unwrap();\n        assert_eq!(events.len(), 1);\n        assert_eq!(events[0], \"test_event\");\n    }\n\n    // Tests for EventBus\n    #[test]\n    fn test_event_bus_new() {\n        let event_bus = EventBus::new();\n        assert_eq!(event_bus.observer_count(\"any_event\"), 0);\n    }\n\n    #[test]\n    fn test_event_bus_default() {\n        let event_bus = EventBus::default();\n        assert_eq!(event_bus.observer_count(\"any_event\"), 0);\n    }\n\n    #[test]\n    fn test_event_bus_clone() {\n        let event_bus = EventBus::new();\n        let cloned_bus = event_bus.clone();\n        \n        assert_eq!(event_bus.observer_count(\"any_event\"), 0);\n        assert_eq!(cloned_bus.observer_count(\"any_event\"), 0);\n    }\n\n    #[test]\n    fn test_event_bus_subscribe() {\n        let event_bus = EventBus::new();\n        let observer = Arc::new(MockEventObserver::new(\"test_observer\", vec![\"test_event\".to_string()]));\n        \n        event_bus.subscribe(\"test_event\", observer);\n        assert_eq!(event_bus.observer_count(\"test_event\"), 1);\n        assert_eq!(event_bus.observer_count(\"other_event\"), 0);\n    }\n\n    #[test]\n    fn test_event_bus_subscribe_multiple_observers() {\n        let event_bus = EventBus::new();\n        let observer1 = Arc::new(MockEventObserver::new(\"observer1\", vec![\"test_event\".to_string()]));\n        let observer2 = Arc::new(MockEventObserver::new(\"observer2\", vec![\"test_event\".to_string()]));\n        \n        event_bus.subscribe(\"test_event\", observer1);\n        event_bus.subscribe(\"test_event\", observer2);\n        \n        assert_eq!(event_bus.observer_count(\"test_event\"), 2);\n    }\n\n    #[test]\n    fn test_event_bus_subscribe_different_event_types() {\n        let event_bus = EventBus::new();\n        let observer1 = Arc::new(MockEventObserver::new(\"observer1\", vec![\"event_type_1\".to_string()]));\n        let observer2 = Arc::new(MockEventObserver::new(\"observer2\", vec![\"event_type_2\".to_string()]));\n        \n        event_bus.subscribe(\"event_type_1\", observer1);\n        event_bus.subscribe(\"event_type_2\", observer2);\n        \n        assert_eq!(event_bus.observer_count(\"event_type_1\"), 1);\n        assert_eq!(event_bus.observer_count(\"event_type_2\"), 1);\n    }\n\n    #[test]\n    fn test_event_bus_unsubscribe() {\n        let event_bus = EventBus::new();\n        let observer = Arc::new(MockEventObserver::new(\"test_observer\", vec![\"test_event\".to_string()]));\n        \n        event_bus.subscribe(\"test_event\", observer.clone());\n        assert_eq!(event_bus.observer_count(\"test_event\"), 1);\n        \n        event_bus.unsubscribe(\"test_event\", \"test_observer\");\n        assert_eq!(event_bus.observer_count(\"test_event\"), 0);\n    }\n\n    #[test]\n    fn test_event_bus_unsubscribe_nonexistent() {\n        let event_bus = EventBus::new();\n        // Should not panic\n        event_bus.unsubscribe(\"nonexistent_event\", \"nonexistent_observer\");\n    }\n\n    #[test]\n    fn test_event_bus_publish() {\n        let event_bus = EventBus::new();\n        let observer = Arc::new(MockEventObserver::new(\"test_observer\", vec![\"test_event\".to_string()]));\n        \n        event_bus.subscribe(\"test_event\", observer);\n        \n        let data = serde_yaml::to_value(\"publish test\").unwrap();\n        let event = SimpleDomainEvent::new(\"test_event\", \"agg_005\", data);\n        \n        let result = event_bus.publish(\u0026event);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_event_bus_publish_no_observers() {\n        let event_bus = EventBus::new();\n        let data = serde_yaml::to_value(\"no observers\").unwrap();\n        let event = SimpleDomainEvent::new(\"test_event\", \"agg_006\", data);\n        \n        let result = event_bus.publish(\u0026event);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_event_bus_publish_observer_failure() {\n        let event_bus = EventBus::new();\n        let observer = Arc::new(\n            MockEventObserver::new(\"failing_observer\", vec![\"test_event\".to_string()])\n                .with_failure(true)\n        );\n        \n        event_bus.subscribe(\"test_event\", observer);\n        \n        let data = serde_yaml::to_value(\"failing test\").unwrap();\n        let event = SimpleDomainEvent::new(\"test_event\", \"agg_007\", data);\n        \n        // Should not panic, should handle the error gracefully\n        let result = event_bus.publish(\u0026event);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_event_bus_publish_async() {\n        let event_bus = EventBus::new();\n        let observer = Arc::new(MockEventObserver::new(\"async_observer\", vec![\"async_event\".to_string()]));\n        \n        event_bus.subscribe(\"async_event\", observer);\n        \n        let data = serde_yaml::to_value(\"async test\").unwrap();\n        let event = Box::new(SimpleDomainEvent::new(\"async_event\", \"agg_008\", data));\n        \n        // Should not panic\n        event_bus.publish_async(event);\n        \n        // Give some time for the async operation to complete\n        std::thread::sleep(std::time::Duration::from_millis(10));\n    }\n\n    #[test]\n    fn test_event_bus_observer_count() {\n        let event_bus = EventBus::new();\n        let observer1 = Arc::new(MockEventObserver::new(\"observer1\", vec![\"test_event\".to_string()]));\n        let observer2 = Arc::new(MockEventObserver::new(\"observer2\", vec![\"test_event\".to_string()]));\n        \n        assert_eq!(event_bus.observer_count(\"test_event\"), 0);\n        \n        event_bus.subscribe(\"test_event\", observer1);\n        assert_eq!(event_bus.observer_count(\"test_event\"), 1);\n        \n        event_bus.subscribe(\"test_event\", observer2);\n        assert_eq!(event_bus.observer_count(\"test_event\"), 2);\n    }\n\n    #[test]\n    fn test_event_bus_event_types() {\n        let event_bus = EventBus::new();\n        let observer1 = Arc::new(MockEventObserver::new(\"observer1\", vec![\"event_type_1\".to_string()]));\n        let observer2 = Arc::new(MockEventObserver::new(\"observer2\", vec![\"event_type_2\".to_string()]));\n        \n        event_bus.subscribe(\"event_type_1\", observer1);\n        event_bus.subscribe(\"event_type_2\", observer2);\n        \n        let event_types = event_bus.event_types();\n        assert_eq!(event_types.len(), 2);\n        assert!(event_types.contains(\u0026\"event_type_1\".to_string()));\n        assert!(event_types.contains(\u0026\"event_type_2\".to_string()));\n    }\n\n    // Tests for EventReplayer\n    #[test]\n    fn test_event_replayer_new() {\n        let event_store = Box::new(MockEventStore::new());\n        let event_bus = EventBus::new();\n        let _replayer = EventReplayer::new(event_store, event_bus);\n        \n        // Just test that it can be created without errors\n        assert!(true);\n    }\n\n    #[test]\n    fn test_event_replayer_replay_aggregate_events() {\n        let event_store = MockEventStore::new();\n        let event_bus = EventBus::new();\n        let replayer = EventReplayer::new(Box::new(event_store), event_bus);\n        \n        // Test that it can be called without errors\n        let result = replayer.replay_aggregate_events(\"test_aggregate\");\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_event_replayer_replay_events_by_type() {\n        let event_store = MockEventStore::new();\n        let event_bus = EventBus::new();\n        let replayer = EventReplayer::new(Box::new(event_store), event_bus);\n        \n        // Test that it can be called without errors\n        let result = replayer.replay_events_by_type(\"test_event_type\");\n        assert!(result.is_ok());\n    }\n\n    // Tests for complex scenarios\n    #[test]\n    fn test_event_bus_complex_scenario() {\n        let event_bus = EventBus::new();\n        \n        // Subscribe multiple observers to different event types\n        let observer1 = Arc::new(MockEventObserver::new(\"observer1\", vec![\"user_created\".to_string()]));\n        let observer2 = Arc::new(MockEventObserver::new(\"observer2\", vec![\"user_updated\".to_string()]));\n        let observer3 = Arc::new(MockEventObserver::new(\"observer3\", vec![\"user_created\".to_string(), \"user_updated\".to_string()]));\n        \n        event_bus.subscribe(\"user_created\", observer1);\n        event_bus.subscribe(\"user_updated\", observer2);\n        event_bus.subscribe(\"user_created\", observer3.clone());\n        event_bus.subscribe(\"user_updated\", observer3);\n        \n        // Verify observer counts\n        assert_eq!(event_bus.observer_count(\"user_created\"), 2);\n        assert_eq!(event_bus.observer_count(\"user_updated\"), 2);\n        \n        // Verify event types\n        let event_types = event_bus.event_types();\n        assert_eq!(event_types.len(), 2);\n        assert!(event_types.contains(\u0026\"user_created\".to_string()));\n        assert!(event_types.contains(\u0026\"user_updated\".to_string()));\n    }\n\n    #[test]\n    fn test_event_bus_observer_interest_filtering() {\n        let event_bus = EventBus::new();\n        \n        // Create observers with specific interests\n        let user_observer = Arc::new(MockEventObserver::new(\"user_observer\", vec![\"user_created\".to_string()]));\n        let project_observer = Arc::new(MockEventObserver::new(\"project_observer\", vec![\"project_created\".to_string()]));\n        let universal_observer = Arc::new(MockEventObserver::new(\"universal_observer\", vec![]));\n        \n        event_bus.subscribe(\"user_created\", user_observer);\n        event_bus.subscribe(\"project_created\", project_observer);\n        event_bus.subscribe(\"any_event\", universal_observer);\n        \n        // Verify that observers are only interested in their specific events\n        assert_eq!(event_bus.observer_count(\"user_created\"), 1);\n        assert_eq!(event_bus.observer_count(\"project_created\"), 1);\n        assert_eq!(event_bus.observer_count(\"any_event\"), 1);\n        assert_eq!(event_bus.observer_count(\"unrelated_event\"), 0);\n    }\n\n    // Tests for edge cases\n    #[test]\n    fn test_event_bus_empty_event_type() {\n        let event_bus = EventBus::new();\n        let observer = Arc::new(MockEventObserver::new(\"empty_observer\", vec![\"\".to_string()]));\n        \n        event_bus.subscribe(\"\", observer);\n        assert_eq!(event_bus.observer_count(\"\"), 1);\n    }\n\n    #[test]\n    fn test_event_bus_special_characters_in_event_type() {\n        let event_bus = EventBus::new();\n        let observer = Arc::new(MockEventObserver::new(\"special_observer\", vec![\"event-with-dashes\".to_string()]));\n        \n        event_bus.subscribe(\"event-with-dashes\", observer);\n        assert_eq!(event_bus.observer_count(\"event-with-dashes\"), 1);\n    }\n\n    #[test]\n    fn test_event_bus_unicode_event_type() {\n        let event_bus = EventBus::new();\n        let observer = Arc::new(MockEventObserver::new(\"unicode_observer\", vec![\"événement_événement\".to_string()]));\n        \n        event_bus.subscribe(\"événement_événement\", observer);\n        assert_eq!(event_bus.observer_count(\"événement_événement\"), 1);\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[1175376],"length":1,"stats":{"Line":1}},{"line":52,"address":[1175380],"length":1,"stats":{"Line":2}},{"line":57,"address":[850316,849888,850286],"length":1,"stats":{"Line":1}},{"line":58,"address":[850034,849939],"length":1,"stats":{"Line":3}},{"line":59,"address":[850153,850094],"length":1,"stats":{"Line":6}},{"line":63,"address":[1175686,1175424,1175680],"length":1,"stats":{"Line":2}},{"line":64,"address":[1175466],"length":1,"stats":{"Line":2}},{"line":65,"address":[1175587,1175523],"length":1,"stats":{"Line":4}},{"line":66,"address":[1175653,1175678],"length":1,"stats":{"Line":4}},{"line":71,"address":[1176805,1175712,1176811],"length":1,"stats":{"Line":1}},{"line":72,"address":[1175786],"length":1,"stats":{"Line":1}},{"line":73,"address":[1175838],"length":1,"stats":{"Line":1}},{"line":75,"address":[1175992,1175913],"length":1,"stats":{"Line":6}},{"line":76,"address":[1176070,1176146],"length":1,"stats":{"Line":4}},{"line":77,"address":[1176251],"length":1,"stats":{"Line":1}},{"line":78,"address":[1176324],"length":1,"stats":{"Line":1}},{"line":80,"address":[1176568,1176479],"length":1,"stats":{"Line":2}},{"line":85,"address":[1176087],"length":1,"stats":{"Line":1}},{"line":89,"address":[1176976,1176998,1176832],"length":1,"stats":{"Line":1}},{"line":90,"address":[1176903,1176851],"length":1,"stats":{"Line":2}},{"line":91,"address":[850760,850416],"length":1,"stats":{"Line":2}},{"line":92,"address":[850428,850501],"length":1,"stats":{"Line":2}},{"line":93,"address":[850586,850663],"length":1,"stats":{"Line":0}},{"line":99,"address":[1177217,1177211,1177008],"length":1,"stats":{"Line":2}},{"line":100,"address":[1177040],"length":1,"stats":{"Line":2}},{"line":101,"address":[850784,850793],"length":1,"stats":{"Line":15}},{"line":105,"address":[1177232,1177445,1177451],"length":1,"stats":{"Line":1}},{"line":106,"address":[1177268],"length":1,"stats":{"Line":1}},{"line":107,"address":[1177381,1177325],"length":1,"stats":{"Line":2}},{"line":112,"address":[1177472],"length":1,"stats":{"Line":1}},{"line":114,"address":[1177477],"length":1,"stats":{"Line":1}},{"line":120,"address":[1177488],"length":1,"stats":{"Line":1}},{"line":121,"address":[1177489],"length":1,"stats":{"Line":1}},{"line":139,"address":[851248,851232,850816],"length":1,"stats":{"Line":1}},{"line":141,"address":[850879],"length":1,"stats":{"Line":1}},{"line":142,"address":[850958],"length":1,"stats":{"Line":1}},{"line":143,"address":[851012],"length":1,"stats":{"Line":1}},{"line":144,"address":[851038],"length":1,"stats":{"Line":1}},{"line":151,"address":[1177504],"length":1,"stats":{"Line":1}},{"line":152,"address":[1177521],"length":1,"stats":{"Line":1}},{"line":153,"address":[1177528],"length":1,"stats":{"Line":1}},{"line":157,"address":[1177552],"length":1,"stats":{"Line":1}},{"line":158,"address":[1177560],"length":1,"stats":{"Line":1}},{"line":159,"address":[1177579],"length":1,"stats":{"Line":1}},{"line":164,"address":[1177600],"length":1,"stats":{"Line":1}},{"line":165,"address":[1177605],"length":1,"stats":{"Line":1}},{"line":168,"address":[1177616],"length":1,"stats":{"Line":1}},{"line":169,"address":[1177624],"length":1,"stats":{"Line":1}},{"line":172,"address":[1177648],"length":1,"stats":{"Line":1}},{"line":173,"address":[1177656],"length":1,"stats":{"Line":1}},{"line":176,"address":[1177680],"length":1,"stats":{"Line":1}},{"line":177,"address":[1177685],"length":1,"stats":{"Line":1}},{"line":180,"address":[1177696],"length":1,"stats":{"Line":1}},{"line":181,"address":[1177701],"length":1,"stats":{"Line":1}},{"line":184,"address":[1177712],"length":1,"stats":{"Line":1}},{"line":185,"address":[1177729],"length":1,"stats":{"Line":1}},{"line":204,"address":[851950,851544,851580,851904,851264,851616],"length":1,"stats":{"Line":2}},{"line":212,"address":[851296,851653],"length":1,"stats":{"Line":2}},{"line":214,"address":[851401,851758],"length":1,"stats":{"Line":2}},{"line":219,"address":[852256,851984,852262],"length":1,"stats":{"Line":1}},{"line":227,"address":[852008],"length":1,"stats":{"Line":1}},{"line":228,"address":[852073],"length":1,"stats":{"Line":1}},{"line":229,"address":[852121],"length":1,"stats":{"Line":1}},{"line":235,"address":[1177760],"length":1,"stats":{"Line":1}},{"line":236,"address":[1177778],"length":1,"stats":{"Line":1}},{"line":239,"address":[1177792],"length":1,"stats":{"Line":1}},{"line":240,"address":[1177797],"length":1,"stats":{"Line":2}},{"line":243,"address":[1178028,1177808,1178022],"length":1,"stats":{"Line":2}},{"line":244,"address":[1177845],"length":1,"stats":{"Line":2}},{"line":276,"address":[1178048],"length":1,"stats":{"Line":1}},{"line":281,"address":[1179039,1179033,1178080],"length":1,"stats":{"Line":1}},{"line":282,"address":[1178122],"length":1,"stats":{"Line":1}},{"line":284,"address":[1178334,1178435,1178574],"length":1,"stats":{"Line":3}},{"line":285,"address":[1178658,1178797,1178980],"length":1,"stats":{"Line":0}},{"line":288,"address":[1178707],"length":1,"stats":{"Line":1}},{"line":292,"address":[1180025,1180031,1179072],"length":1,"stats":{"Line":1}},{"line":293,"address":[1179114],"length":1,"stats":{"Line":1}},{"line":295,"address":[1179427,1179566,1179326],"length":1,"stats":{"Line":3}},{"line":296,"address":[1179650,1179972,1179789],"length":1,"stats":{"Line":0}},{"line":299,"address":[1179699],"length":1,"stats":{"Line":1}}],"covered":77,"coverable":82},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","shared","repository.rs"],"content":"use crate::domain::shared::errors::DomainError;\nuse std::collections::HashMap;\nuse std::sync::{Arc, Mutex};\n\n\n/// A generic repository trait for domain entities\npub trait Repository\u003cT, ID\u003e {\n    /// Find an entity by ID\n    fn find_by_id(\u0026self, id: \u0026ID) -\u003e Result\u003cOption\u003cT\u003e, DomainError\u003e;\n\n    /// Find all entities\n    fn find_all(\u0026self) -\u003e Result\u003cVec\u003cT\u003e, DomainError\u003e;\n\n    /// Save an entity\n    fn save(\u0026self, entity: T) -\u003e Result\u003cT, DomainError\u003e;\n\n    /// Update an existing entity\n    fn update(\u0026self, entity: T) -\u003e Result\u003cT, DomainError\u003e;\n\n    /// Delete an entity by ID\n    fn delete(\u0026self, id: \u0026ID) -\u003e Result\u003cbool, DomainError\u003e;\n\n    /// Check if an entity exists\n    fn exists(\u0026self, id: \u0026ID) -\u003e Result\u003cbool, DomainError\u003e;\n\n    /// Count all entities\n    fn count(\u0026self) -\u003e Result\u003cusize, DomainError\u003e;\n}\n\n/// A repository that supports pagination\npub trait PaginatedRepository\u003cT, ID\u003e: Repository\u003cT, ID\u003e {\n    /// Find entities with pagination\n    fn find_with_pagination(\u0026self, page: usize, size: usize) -\u003e Result\u003cPaginatedResult\u003cT\u003e, DomainError\u003e;\n}\n\n/// A repository that supports searching\npub trait SearchableRepository\u003cT, ID\u003e: Repository\u003cT, ID\u003e {\n    /// Search entities by criteria\n    fn search(\u0026self, criteria: \u0026SearchCriteria) -\u003e Result\u003cVec\u003cT\u003e, DomainError\u003e;\n\n    /// Search entities with pagination\n    fn search_with_pagination(\n        \u0026self,\n        criteria: \u0026SearchCriteria,\n        page: usize,\n        size: usize,\n    ) -\u003e Result\u003cPaginatedResult\u003cT\u003e, DomainError\u003e;\n}\n\n/// A repository that supports transactions\npub trait TransactionalRepository\u003cT, ID\u003e: Repository\u003cT, ID\u003e {\n    /// Begin a transaction\n    fn begin_transaction(\u0026self) -\u003e Result\u003cBox\u003cdyn Transaction\u003e, DomainError\u003e;\n\n    /// Execute a function within a transaction\n    fn with_transaction\u003cF, R\u003e(\u0026self, f: F) -\u003e Result\u003cR, DomainError\u003e\n    where\n        F: FnOnce(\u0026dyn Transaction) -\u003e Result\u003cR, DomainError\u003e;\n}\n\n/// A transaction that can be committed or rolled back\npub trait Transaction {\n    /// Commit the transaction\n    fn commit(self: Box\u003cSelf\u003e) -\u003e Result\u003c(), DomainError\u003e;\n\n    /// Rollback the transaction\n    fn rollback(self: Box\u003cSelf\u003e) -\u003e Result\u003c(), DomainError\u003e;\n}\n\n/// Search criteria for repositories\n#[derive(Debug, Clone)]\npub struct SearchCriteria {\n    pub filters: HashMap\u003cString, String\u003e,\n    pub sort_by: Option\u003cString\u003e,\n    pub sort_order: SortOrder,\n}\n\nimpl SearchCriteria {\n    /// Create new search criteria\n    pub fn new() -\u003e Self {\n        Self {\n            filters: HashMap::new(),\n            sort_by: None,\n            sort_order: SortOrder::Ascending,\n        }\n    }\n\n    /// Add a filter\n    pub fn with_filter(mut self, key: impl Into\u003cString\u003e, value: impl Into\u003cString\u003e) -\u003e Self {\n        self.filters.insert(key.into(), value.into());\n        self\n    }\n\n    /// Set sort field\n    pub fn sort_by(mut self, field: impl Into\u003cString\u003e) -\u003e Self {\n        self.sort_by = Some(field.into());\n        self\n    }\n\n    /// Set sort order\n    pub fn sort_order(mut self, order: SortOrder) -\u003e Self {\n        self.sort_order = order;\n        self\n    }\n}\n\nimpl Default for SearchCriteria {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Sort order for search results\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum SortOrder {\n    Ascending,\n    Descending,\n}\n\n/// Paginated result\n#[derive(Debug, Clone)]\npub struct PaginatedResult\u003cT\u003e {\n    pub items: Vec\u003cT\u003e,\n    pub page: usize,\n    pub size: usize,\n    pub total: usize,\n    pub total_pages: usize,\n}\n\nimpl\u003cT\u003e PaginatedResult\u003cT\u003e {\n    /// Create a new paginated result\n    pub fn new(items: Vec\u003cT\u003e, page: usize, size: usize, total: usize) -\u003e Self {\n        let total_pages = if total == 0 || size == 0 { 0 } else { total.div_ceil(size) };\n\n        Self {\n            items,\n            page,\n            size,\n            total,\n            total_pages,\n        }\n    }\n\n    /// Check if there's a next page\n    pub fn has_next(\u0026self) -\u003e bool {\n        self.page \u003c self.total_pages\n    }\n\n    /// Check if there's a previous page\n    pub fn has_previous(\u0026self) -\u003e bool {\n        self.page \u003e 1\n    }\n\n    /// Get the next page number\n    pub fn next_page(\u0026self) -\u003e Option\u003cusize\u003e {\n        if self.has_next() { Some(self.page + 1) } else { None }\n    }\n\n    /// Get the previous page number\n    pub fn previous_page(\u0026self) -\u003e Option\u003cusize\u003e {\n        if self.has_previous() { Some(self.page - 1) } else { None }\n    }\n}\n\n/// A repository that caches results\npub trait CachedRepository\u003cT, ID\u003e: Repository\u003cT, ID\u003e {\n    /// Get the cache key for an entity\n    fn cache_key(\u0026self, id: \u0026ID) -\u003e String;\n\n    /// Invalidate cache for an entity\n    fn invalidate_cache(\u0026self, id: \u0026ID) -\u003e Result\u003c(), DomainError\u003e;\n\n    /// Clear all cache\n    fn clear_cache(\u0026self) -\u003e Result\u003c(), DomainError\u003e;\n}\n\n/// A simple in-memory repository implementation\npub struct InMemoryRepository\u003cT\u003e {\n    entities: Arc\u003cMutex\u003cHashMap\u003cString, T\u003e\u003e\u003e,\n}\n\nimpl\u003cT\u003e InMemoryRepository\u003cT\u003e\nwhere\n    T: Clone,\n{\n    /// Create a new in-memory repository\n    pub fn new() -\u003e Self {\n        Self {\n            entities: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n\n    /// Get a reference to the entities map\n    fn entities(\u0026self) -\u003e std::sync::MutexGuard\u003c'_, HashMap\u003cString, T\u003e\u003e {\n        self.entities.lock().unwrap()\n    }\n\n    /// Get a mutable reference to the entities map\n    fn entities_mut(\u0026self) -\u003e std::sync::MutexGuard\u003c'_, HashMap\u003cString, T\u003e\u003e {\n        self.entities.lock().unwrap()\n    }\n}\n\nimpl\u003cT\u003e Repository\u003cT, String\u003e for InMemoryRepository\u003cT\u003e\nwhere\n    T: Clone,\n{\n    fn find_by_id(\u0026self, id: \u0026String) -\u003e Result\u003cOption\u003cT\u003e, DomainError\u003e {\n        let entities = self.entities();\n        Ok(entities.get(id).cloned())\n    }\n\n    fn find_all(\u0026self) -\u003e Result\u003cVec\u003cT\u003e, DomainError\u003e {\n        let entities = self.entities();\n        Ok(entities.values().cloned().collect())\n    }\n\n    fn save(\u0026self, entity: T) -\u003e Result\u003cT, DomainError\u003e {\n        // Extract ID from entity - this is a simplified approach\n        // In a real implementation, you'd have a way to get the ID from the entity\n        let mut entities = self.entities_mut();\n        \n        // For now, we'll use a placeholder ID based on the entity's content\n        // This is just for demonstration - in practice you'd extract the real ID\n        let id = format!(\"entity_{}\", entities.len());\n        \n        // Insert the entity with the generated ID\n        entities.insert(id, entity.clone());\n        \n        Ok(entity)\n    }\n\n    fn update(\u0026self, entity: T) -\u003e Result\u003cT, DomainError\u003e {\n        // For this simplified implementation, we'll just save it\n        // In a real implementation, you'd check if it exists first\n        // Note: This creates a new entity with a new ID, not a true update\n        self.save(entity.clone())?;\n        Ok(entity)\n    }\n\n    fn delete(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n        let mut entities = self.entities_mut();\n        let deleted = entities.remove(id).is_some();\n        Ok(deleted)\n    }\n\n    fn exists(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n        let entities = self.entities();\n        Ok(entities.contains_key(id))\n    }\n\n    fn count(\u0026self) -\u003e Result\u003cusize, DomainError\u003e {\n        let entities = self.entities();\n        Ok(entities.len())\n    }\n}\n\nimpl\u003cT\u003e Default for InMemoryRepository\u003cT\u003e\nwhere\n    T: Clone,\n{\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A repository decorator that adds logging\npub struct LoggingRepositoryDecorator\u003cT, ID, R\u003e {\n    repository: R,\n    _phantom: std::marker::PhantomData\u003c(T, ID)\u003e,\n}\n\nimpl\u003cT, ID, R\u003e LoggingRepositoryDecorator\u003cT, ID, R\u003e\nwhere\n    R: Repository\u003cT, ID\u003e,\n    ID: std::fmt::Debug,\n{\n    /// Create a new logging repository decorator\n    pub fn new(repository: R) -\u003e Self {\n        Self {\n            repository,\n            _phantom: std::marker::PhantomData,\n        }\n    }\n}\n\nimpl\u003cT, ID, R\u003e Repository\u003cT, ID\u003e for LoggingRepositoryDecorator\u003cT, ID, R\u003e\nwhere\n    R: Repository\u003cT, ID\u003e,\n    ID: std::fmt::Debug,\n{\n    fn find_by_id(\u0026self, id: \u0026ID) -\u003e Result\u003cOption\u003cT\u003e, DomainError\u003e {\n        println!(\"Repository: Finding entity by ID: {:?}\", id);\n        let result = self.repository.find_by_id(id);\n        match \u0026result {\n            Ok(Some(_)) =\u003e println!(\"Repository: Entity found\"),\n            Ok(None) =\u003e println!(\"Repository: Entity not found\"),\n            Err(e) =\u003e println!(\"Repository: Error finding entity: {}\", e),\n        }\n        result\n    }\n\n    fn find_all(\u0026self) -\u003e Result\u003cVec\u003cT\u003e, DomainError\u003e {\n        println!(\"Repository: Finding all entities\");\n        let result = self.repository.find_all();\n        match \u0026result {\n            Ok(entities) =\u003e println!(\"Repository: Found {} entities\", entities.len()),\n            Err(e) =\u003e println!(\"Repository: Error finding all entities: {}\", e),\n        }\n        result\n    }\n\n    fn save(\u0026self, entity: T) -\u003e Result\u003cT, DomainError\u003e {\n        println!(\"Repository: Saving entity\");\n        let result = self.repository.save(entity);\n        match \u0026result {\n            Ok(_) =\u003e println!(\"Repository: Entity saved successfully\"),\n            Err(e) =\u003e println!(\"Repository: Error saving entity: {}\", e),\n        }\n        result\n    }\n\n    fn update(\u0026self, entity: T) -\u003e Result\u003cT, DomainError\u003e {\n        println!(\"Repository: Updating entity\");\n        let result = self.repository.update(entity);\n        match \u0026result {\n            Ok(_) =\u003e println!(\"Repository: Entity updated successfully\"),\n            Err(e) =\u003e println!(\"Repository: Error updating entity: {}\", e),\n        }\n        result\n    }\n\n    fn delete(\u0026self, id: \u0026ID) -\u003e Result\u003cbool, DomainError\u003e {\n        println!(\"Repository: Deleting entity with ID: {:?}\", id);\n        let result = self.repository.delete(id);\n        match \u0026result {\n            Ok(deleted) =\u003e println!(\"Repository: Entity {}deleted\", if *deleted { \"\" } else { \"not \" }),\n            Err(e) =\u003e println!(\"Repository: Error deleting entity: {}\", e),\n        }\n        result\n    }\n\n    fn exists(\u0026self, id: \u0026ID) -\u003e Result\u003cbool, DomainError\u003e {\n        println!(\"Repository: Checking if entity exists with ID: {:?}\", id);\n        let result = self.repository.exists(id);\n        match \u0026result {\n            Ok(exists) =\u003e println!(\"Repository: Entity {}exists\", if *exists { \"\" } else { \"does not \" }),\n            Err(e) =\u003e println!(\"Repository: Error checking entity existence: {}\", e),\n        }\n        result\n    }\n\n    fn count(\u0026self) -\u003e Result\u003cusize, DomainError\u003e {\n        println!(\"Repository: Counting entities\");\n        let result = self.repository.count();\n        match \u0026result {\n            Ok(count) =\u003e println!(\"Repository: Found {} entities\", count),\n            Err(e) =\u003e println!(\"Repository: Error counting entities: {}\", e),\n        }\n        result\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::Arc;\n\n    // Mock entity types for testing\n    #[derive(Debug, Clone, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]\n    struct MockEntity {\n        id: String,\n        name: String,\n        value: u32,\n    }\n\n    impl MockEntity {\n        fn new(id: \u0026str, name: \u0026str, value: u32) -\u003e Self {\n            Self {\n                id: id.to_string(),\n                name: name.to_string(),\n                value,\n            }\n        }\n    }\n\n    // Mock repository implementation for testing\n    struct MockRepository {\n        entities: Arc\u003cMutex\u003cHashMap\u003cString, MockEntity\u003e\u003e\u003e,\n    }\n\n    impl MockRepository {\n        fn new() -\u003e Self {\n            Self {\n                entities: Arc::new(Mutex::new(HashMap::new())),\n            }\n        }\n\n        fn add_entity(\u0026self, entity: MockEntity) {\n            let mut entities = self.entities.lock().unwrap();\n            entities.insert(entity.id.clone(), entity);\n        }\n    }\n\n    impl Repository\u003cMockEntity, String\u003e for MockRepository {\n        fn find_by_id(\u0026self, id: \u0026String) -\u003e Result\u003cOption\u003cMockEntity\u003e, DomainError\u003e {\n            let entities = self.entities.lock().unwrap();\n            Ok(entities.get(id).cloned())\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cMockEntity\u003e, DomainError\u003e {\n            let entities = self.entities.lock().unwrap();\n            Ok(entities.values().cloned().collect())\n        }\n\n        fn save(\u0026self, entity: MockEntity) -\u003e Result\u003cMockEntity, DomainError\u003e {\n            let mut entities = self.entities.lock().unwrap();\n            entities.insert(entity.id.clone(), entity.clone());\n            Ok(entity)\n        }\n\n        fn update(\u0026self, entity: MockEntity) -\u003e Result\u003cMockEntity, DomainError\u003e {\n            let mut entities = self.entities.lock().unwrap();\n            if entities.contains_key(\u0026entity.id) {\n                entities.insert(entity.id.clone(), entity.clone());\n                Ok(entity)\n            } else {\n                Err(DomainError::new(\n                    crate::domain::shared::errors::DomainErrorKind::Generic { message: \"Entity not found for update\".to_string() }\n                ))\n            }\n        }\n\n        fn delete(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n            let mut entities = self.entities.lock().unwrap();\n            Ok(entities.remove(id).is_some())\n        }\n\n        fn exists(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n            let entities = self.entities.lock().unwrap();\n            Ok(entities.contains_key(id))\n        }\n\n        fn count(\u0026self) -\u003e Result\u003cusize, DomainError\u003e {\n            let entities = self.entities.lock().unwrap();\n            Ok(entities.len())\n        }\n    }\n\n    // Mock paginated repository implementation\n    struct MockPaginatedRepository {\n        base_repository: MockRepository,\n    }\n\n    impl MockPaginatedRepository {\n        fn new() -\u003e Self {\n            Self {\n                base_repository: MockRepository::new(),\n            }\n        }\n    }\n\n    impl Repository\u003cMockEntity, String\u003e for MockPaginatedRepository {\n        fn find_by_id(\u0026self, id: \u0026String) -\u003e Result\u003cOption\u003cMockEntity\u003e, DomainError\u003e {\n            self.base_repository.find_by_id(id)\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cMockEntity\u003e, DomainError\u003e {\n            self.base_repository.find_all()\n        }\n\n        fn save(\u0026self, entity: MockEntity) -\u003e Result\u003cMockEntity, DomainError\u003e {\n            self.base_repository.save(entity)\n        }\n\n        fn update(\u0026self, entity: MockEntity) -\u003e Result\u003cMockEntity, DomainError\u003e {\n            self.base_repository.update(entity)\n        }\n\n        fn delete(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n            self.base_repository.delete(id)\n        }\n\n        fn exists(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n            self.base_repository.exists(id)\n        }\n\n        fn count(\u0026self) -\u003e Result\u003cusize, DomainError\u003e {\n            self.base_repository.count()\n        }\n    }\n\n    impl PaginatedRepository\u003cMockEntity, String\u003e for MockPaginatedRepository {\n        fn find_with_pagination(\u0026self, page: usize, size: usize) -\u003e Result\u003cPaginatedResult\u003cMockEntity\u003e, DomainError\u003e {\n            let all_entities = self.find_all()?;\n            let total = all_entities.len();\n            let start = (page - 1) * size;\n            let _end = start + size;\n            \n            let items = if start \u003c total {\n                all_entities.into_iter().skip(start).take(size).collect()\n            } else {\n                Vec::new()\n            };\n            \n            Ok(PaginatedResult::new(items, page, size, total))\n        }\n    }\n\n    // Mock searchable repository implementation\n    struct MockSearchableRepository {\n        base_repository: MockRepository,\n    }\n\n    impl MockSearchableRepository {\n        fn new() -\u003e Self {\n            Self {\n                base_repository: MockRepository::new(),\n            }\n        }\n    }\n\n    impl Repository\u003cMockEntity, String\u003e for MockSearchableRepository {\n        fn find_by_id(\u0026self, id: \u0026String) -\u003e Result\u003cOption\u003cMockEntity\u003e, DomainError\u003e {\n            self.base_repository.find_by_id(id)\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cMockEntity\u003e, DomainError\u003e {\n            self.base_repository.find_all()\n        }\n\n        fn save(\u0026self, entity: MockEntity) -\u003e Result\u003cMockEntity, DomainError\u003e {\n            self.base_repository.save(entity)\n        }\n\n        fn update(\u0026self, entity: MockEntity) -\u003e Result\u003cMockEntity, DomainError\u003e {\n            self.base_repository.update(entity)\n        }\n\n        fn delete(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n            self.base_repository.delete(id)\n        }\n\n        fn exists(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n            self.base_repository.exists(id)\n        }\n\n        fn count(\u0026self) -\u003e Result\u003cusize, DomainError\u003e {\n            self.base_repository.count()\n        }\n    }\n\n    impl SearchableRepository\u003cMockEntity, String\u003e for MockSearchableRepository {\n        fn search(\u0026self, criteria: \u0026SearchCriteria) -\u003e Result\u003cVec\u003cMockEntity\u003e, DomainError\u003e {\n            let all_entities = self.find_all()?;\n            let mut filtered_entities = all_entities;\n            \n            // Apply filters\n            for (key, value) in \u0026criteria.filters {\n                filtered_entities = filtered_entities\n                    .into_iter()\n                    .filter(|entity| {\n                        match key.as_str() {\n                            \"name\" =\u003e entity.name.contains(value),\n                            \"value\" =\u003e entity.value.to_string() == *value,\n                            _ =\u003e true,\n                        }\n                    })\n                    .collect();\n            }\n            \n            // Apply sorting\n            if let Some(sort_field) = \u0026criteria.sort_by {\n                match sort_field.as_str() {\n                    \"name\" =\u003e {\n                        filtered_entities.sort_by(|a, b| {\n                            match criteria.sort_order {\n                                SortOrder::Ascending =\u003e a.name.cmp(\u0026b.name),\n                                SortOrder::Descending =\u003e b.name.cmp(\u0026a.name),\n                            }\n                        });\n                    }\n                    \"value\" =\u003e {\n                        filtered_entities.sort_by(|a, b| {\n                            match criteria.sort_order {\n                                SortOrder::Ascending =\u003e a.value.cmp(\u0026b.value),\n                                SortOrder::Descending =\u003e b.value.cmp(\u0026a.value),\n                            }\n                        });\n                    }\n                    _ =\u003e {}\n                }\n            }\n            \n            Ok(filtered_entities)\n        }\n\n        fn search_with_pagination(\n            \u0026self,\n            criteria: \u0026SearchCriteria,\n            page: usize,\n            size: usize,\n        ) -\u003e Result\u003cPaginatedResult\u003cMockEntity\u003e, DomainError\u003e {\n            let filtered_entities = self.search(criteria)?;\n            let total = filtered_entities.len();\n            let start = (page - 1) * size;\n            let _end = start + size;\n            \n            let items = if start \u003c total {\n                filtered_entities.into_iter().skip(start).take(size).collect()\n            } else {\n                Vec::new()\n            };\n            \n            Ok(PaginatedResult::new(items, page, size, total))\n        }\n    }\n\n    // Mock transactional repository implementation\n    struct MockTransactionalRepository {\n        base_repository: MockRepository,\n    }\n\n    impl MockTransactionalRepository {\n        fn new() -\u003e Self {\n            Self {\n                base_repository: MockRepository::new(),\n            }\n        }\n    }\n\n    impl Repository\u003cMockEntity, String\u003e for MockTransactionalRepository {\n        fn find_by_id(\u0026self, id: \u0026String) -\u003e Result\u003cOption\u003cMockEntity\u003e, DomainError\u003e {\n            self.base_repository.find_by_id(id)\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cMockEntity\u003e, DomainError\u003e {\n            self.base_repository.find_all()\n        }\n\n        fn save(\u0026self, entity: MockEntity) -\u003e Result\u003cMockEntity, DomainError\u003e {\n            self.base_repository.save(entity)\n        }\n\n        fn update(\u0026self, entity: MockEntity) -\u003e Result\u003cMockEntity, DomainError\u003e {\n            self.base_repository.update(entity)\n        }\n\n        fn delete(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n            self.base_repository.delete(id)\n        }\n\n        fn exists(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n            self.base_repository.exists(id)\n        }\n\n        fn count(\u0026self) -\u003e Result\u003cusize, DomainError\u003e {\n            self.base_repository.count()\n        }\n    }\n\n    impl TransactionalRepository\u003cMockEntity, String\u003e for MockTransactionalRepository {\n        fn begin_transaction(\u0026self) -\u003e Result\u003cBox\u003cdyn Transaction\u003e, DomainError\u003e {\n            Ok(Box::new(MockTransaction::new()))\n        }\n\n        fn with_transaction\u003cF, R\u003e(\u0026self, f: F) -\u003e Result\u003cR, DomainError\u003e\n        where\n            F: FnOnce(\u0026dyn Transaction) -\u003e Result\u003cR, DomainError\u003e,\n        {\n            let transaction = self.begin_transaction()?;\n            f(transaction.as_ref())\n        }\n    }\n\n    // Mock transaction implementation\n    struct MockTransaction {\n        committed: bool,\n        rolled_back: bool,\n    }\n\n    impl MockTransaction {\n        fn new() -\u003e Self {\n            Self {\n                committed: false,\n                rolled_back: false,\n            }\n        }\n    }\n\n    impl Transaction for MockTransaction {\n        fn commit(self: Box\u003cSelf\u003e) -\u003e Result\u003c(), DomainError\u003e {\n            let mut this = *self;\n            this.committed = true;\n            Ok(())\n        }\n\n        fn rollback(self: Box\u003cSelf\u003e) -\u003e Result\u003c(), DomainError\u003e {\n            let mut this = *self;\n            this.rolled_back = true;\n            Ok(())\n        }\n    }\n\n    // Mock cached repository implementation\n    struct MockCachedRepository {\n        base_repository: MockRepository,\n        cache: Arc\u003cMutex\u003cHashMap\u003cString, MockEntity\u003e\u003e\u003e,\n    }\n\n    impl MockCachedRepository {\n        fn new() -\u003e Self {\n            Self {\n                base_repository: MockRepository::new(),\n                cache: Arc::new(Mutex::new(HashMap::new())),\n            }\n        }\n    }\n\n    impl Repository\u003cMockEntity, String\u003e for MockCachedRepository {\n        fn find_by_id(\u0026self, id: \u0026String) -\u003e Result\u003cOption\u003cMockEntity\u003e, DomainError\u003e {\n            // Check cache first\n            let cache_key = self.cache_key(id);\n            let cached_entity = {\n                let cache = self.cache.lock().unwrap();\n                cache.get(\u0026cache_key).cloned()\n            };\n            \n            if let Some(entity) = cached_entity {\n                return Ok(Some(entity));\n            }\n            \n            // If not in cache, get from base repository\n            let entity = self.base_repository.find_by_id(id)?;\n            if let Some(ref entity) = entity {\n                let cache_key = self.cache_key(id);\n                let mut cache = self.cache.lock().unwrap();\n                cache.insert(cache_key, entity.clone());\n            }\n            \n            Ok(entity)\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cMockEntity\u003e, DomainError\u003e {\n            self.base_repository.find_all()\n        }\n\n        fn save(\u0026self, entity: MockEntity) -\u003e Result\u003cMockEntity, DomainError\u003e {\n            let result = self.base_repository.save(entity.clone())?;\n            // Invalidate cache for this entity\n            self.invalidate_cache(\u0026entity.id)?;\n            Ok(result)\n        }\n\n        fn update(\u0026self, entity: MockEntity) -\u003e Result\u003cMockEntity, DomainError\u003e {\n            let result = self.base_repository.update(entity.clone())?;\n            // Invalidate cache for this entity\n            self.invalidate_cache(\u0026entity.id)?;\n            Ok(result)\n        }\n\n        fn delete(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n            let result = self.base_repository.delete(id)?;\n            if result {\n                // Invalidate cache for this entity\n                self.invalidate_cache(id)?;\n            }\n            Ok(result)\n        }\n\n        fn exists(\u0026self, id: \u0026String) -\u003e Result\u003cbool, DomainError\u003e {\n            self.base_repository.exists(id)\n        }\n\n        fn count(\u0026self) -\u003e Result\u003cusize, DomainError\u003e {\n            self.base_repository.count()\n        }\n    }\n\n    impl CachedRepository\u003cMockEntity, String\u003e for MockCachedRepository {\n        fn cache_key(\u0026self, id: \u0026String) -\u003e String {\n            format!(\"entity:{}\", id)\n        }\n\n        fn invalidate_cache(\u0026self, id: \u0026String) -\u003e Result\u003c(), DomainError\u003e {\n            let cache_key = self.cache_key(id);\n            let mut cache = self.cache.lock().unwrap();\n            cache.remove(\u0026cache_key);\n            Ok(())\n        }\n\n        fn clear_cache(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            let mut cache = self.cache.lock().unwrap();\n            cache.clear();\n            Ok(())\n        }\n    }\n\n    // Tests for SearchCriteria\n    #[test]\n    fn test_search_criteria_new() {\n        let criteria = SearchCriteria::new();\n        assert!(criteria.filters.is_empty());\n        assert!(criteria.sort_by.is_none());\n        assert_eq!(criteria.sort_order, SortOrder::Ascending);\n    }\n\n    #[test]\n    fn test_search_criteria_default() {\n        let criteria = SearchCriteria::default();\n        assert!(criteria.filters.is_empty());\n        assert!(criteria.sort_by.is_none());\n        assert_eq!(criteria.sort_order, SortOrder::Ascending);\n    }\n\n    #[test]\n    fn test_search_criteria_with_filter() {\n        let criteria = SearchCriteria::new()\n            .with_filter(\"name\", \"test\")\n            .with_filter(\"value\", \"42\");\n        \n        assert_eq!(criteria.filters.len(), 2);\n        assert_eq!(criteria.filters.get(\"name\"), Some(\u0026\"test\".to_string()));\n        assert_eq!(criteria.filters.get(\"value\"), Some(\u0026\"42\".to_string()));\n    }\n\n    #[test]\n    fn test_search_criteria_sort_by() {\n        let criteria = SearchCriteria::new().sort_by(\"name\");\n        assert_eq!(criteria.sort_by, Some(\"name\".to_string()));\n    }\n\n    #[test]\n    fn test_search_criteria_sort_order() {\n        let criteria = SearchCriteria::new().sort_order(SortOrder::Descending);\n        assert_eq!(criteria.sort_order, SortOrder::Descending);\n    }\n\n    // Tests for SortOrder\n    #[test]\n    fn test_sort_order_variants() {\n        assert_eq!(SortOrder::Ascending as u8, 0);\n        assert_eq!(SortOrder::Descending as u8, 1);\n    }\n\n    #[test]\n    fn test_sort_order_debug() {\n        assert_eq!(format!(\"{:?}\", SortOrder::Ascending), \"Ascending\");\n        assert_eq!(format!(\"{:?}\", SortOrder::Descending), \"Descending\");\n    }\n\n    // Tests for PaginatedResult\n    #[test]\n    fn test_paginated_result_new() {\n        let items = vec![MockEntity::new(\"1\", \"test1\", 10), MockEntity::new(\"2\", \"test2\", 20)];\n        let result = PaginatedResult::new(items.clone(), 1, 10, 2);\n        \n        assert_eq!(result.items, items);\n        assert_eq!(result.page, 1);\n        assert_eq!(result.size, 10);\n        assert_eq!(result.total, 2);\n        assert_eq!(result.total_pages, 1);\n    }\n\n    #[test]\n    fn test_paginated_result_total_pages_calculation() {\n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 1, 10, 25);\n        assert_eq!(result.total_pages, 3); // 25 items / 10 per page = 3 pages\n        \n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 1, 10, 0);\n        assert_eq!(result.total_pages, 0); // 0 items = 0 pages\n    }\n\n    #[test]\n    fn test_paginated_result_has_next() {\n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 1, 10, 25);\n        assert!(result.has_next());\n        \n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 3, 10, 25);\n        assert!(!result.has_next());\n    }\n\n    #[test]\n    fn test_paginated_result_has_previous() {\n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 1, 10, 25);\n        assert!(!result.has_previous());\n        \n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 2, 10, 25);\n        assert!(result.has_previous());\n    }\n\n    #[test]\n    fn test_paginated_result_next_page() {\n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 1, 10, 25);\n        assert_eq!(result.next_page(), Some(2));\n        \n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 3, 10, 25);\n        assert_eq!(result.next_page(), None);\n    }\n\n    #[test]\n    fn test_paginated_result_previous_page() {\n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 1, 10, 25);\n        assert_eq!(result.previous_page(), None);\n        \n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 2, 10, 25);\n        assert_eq!(result.previous_page(), Some(1));\n    }\n\n    // Tests for InMemoryRepository\n    #[test]\n    fn test_in_memory_repository_new() {\n        let repo = InMemoryRepository::\u003cMockEntity\u003e::new();\n        assert_eq!(repo.count().unwrap(), 0);\n    }\n\n    #[test]\n    fn test_in_memory_repository_default() {\n        let repo = InMemoryRepository::\u003cMockEntity\u003e::default();\n        assert_eq!(repo.count().unwrap(), 0);\n    }\n\n    #[test]\n    fn test_in_memory_repository_save_and_find() {\n        let repo = InMemoryRepository::\u003cMockEntity\u003e::new();\n        let entity = MockEntity::new(\"1\", \"test\", 42);\n        \n        let saved_entity = repo.save(entity.clone()).unwrap();\n        assert_eq!(saved_entity, entity);\n        \n        // Now the repository should actually persist the entity\n        let found_entity = repo.find_by_id(\u0026\"entity_0\".to_string()).unwrap();\n        assert_eq!(found_entity, Some(entity));\n    }\n\n    #[test]\n    fn test_in_memory_repository_update() {\n        let repo = InMemoryRepository::\u003cMockEntity\u003e::new();\n        let entity = MockEntity::new(\"1\", \"test\", 42);\n        \n        // Save the entity first\n        repo.save(entity).unwrap();\n        \n        // Now update it (this will create a new entity with a new ID)\n        let updated_entity = MockEntity::new(\"1\", \"updated\", 100);\n        let result = repo.update(updated_entity.clone()).unwrap();\n        assert_eq!(result, updated_entity);\n        \n        // Verify both entities exist (original and \"updated\")\n        let found_entity1 = repo.find_by_id(\u0026\"entity_0\".to_string()).unwrap();\n        let found_entity2 = repo.find_by_id(\u0026\"entity_1\".to_string()).unwrap();\n        assert_eq!(found_entity1, Some(MockEntity::new(\"1\", \"test\", 42)));\n        assert_eq!(found_entity2, Some(updated_entity));\n        assert_eq!(repo.count().unwrap(), 2);\n    }\n\n    #[test]\n    fn test_in_memory_repository_delete() {\n        let repo = InMemoryRepository::\u003cMockEntity\u003e::new();\n        let entity = MockEntity::new(\"1\", \"test\", 42);\n        \n        // Save the entity first\n        repo.save(entity).unwrap();\n        assert_eq!(repo.count().unwrap(), 1);\n        \n        // Delete the entity\n        let deleted = repo.delete(\u0026\"entity_0\".to_string()).unwrap();\n        assert!(deleted);\n        assert_eq!(repo.count().unwrap(), 0);\n    }\n\n    #[test]\n    fn test_in_memory_repository_exists() {\n        let repo = InMemoryRepository::\u003cMockEntity\u003e::new();\n        let entity = MockEntity::new(\"1\", \"test\", 42);\n        \n        assert!(!repo.exists(\u0026\"entity_0\".to_string()).unwrap());\n        repo.save(entity).unwrap();\n        assert!(repo.exists(\u0026\"entity_0\".to_string()).unwrap()); // Now it should exist\n    }\n\n    #[test]\n    fn test_in_memory_repository_find_all() {\n        let repo = InMemoryRepository::\u003cMockEntity\u003e::new();\n        let entity1 = MockEntity::new(\"1\", \"test1\", 10);\n        let entity2 = MockEntity::new(\"2\", \"test2\", 20);\n        \n        repo.save(entity1.clone()).unwrap();\n        repo.save(entity2.clone()).unwrap();\n        \n        let all_entities = repo.find_all().unwrap();\n        assert_eq!(all_entities.len(), 2); // Now both entities should be persisted\n        assert!(all_entities.contains(\u0026entity1));\n        assert!(all_entities.contains(\u0026entity2));\n    }\n\n    #[test]\n    fn test_in_memory_repository_persistence_across_instances() {\n        // Create first repository instance and save data\n        let repo1 = InMemoryRepository::\u003cMockEntity\u003e::new();\n        let entity = MockEntity::new(\"1\", \"test\", 42);\n        repo1.save(entity.clone()).unwrap();\n        \n        // Create second repository instance - should be empty (no file persistence)\n        let repo2 = InMemoryRepository::\u003cMockEntity\u003e::new();\n        let found_entity = repo2.find_by_id(\u0026\"entity_0\".to_string()).unwrap();\n        assert_eq!(found_entity, None);\n        assert_eq!(repo2.count().unwrap(), 0);\n    }\n\n    // Tests for PaginatedRepository\n    #[test]\n    fn test_paginated_repository_find_with_pagination() {\n        let repo = MockPaginatedRepository::new();\n        \n        // Add some test entities\n        repo.save(MockEntity::new(\"1\", \"test1\", 10)).unwrap();\n        repo.save(MockEntity::new(\"2\", \"test2\", 20)).unwrap();\n        repo.save(MockEntity::new(\"3\", \"test3\", 30)).unwrap();\n        \n        let result = repo.find_with_pagination(1, 2).unwrap();\n        assert_eq!(result.items.len(), 2);\n        assert_eq!(result.page, 1);\n        assert_eq!(result.size, 2);\n        assert_eq!(result.total, 3);\n        assert_eq!(result.total_pages, 2);\n    }\n\n    #[test]\n    fn test_paginated_repository_empty_page() {\n        let repo = MockPaginatedRepository::new();\n        \n        let result = repo.find_with_pagination(2, 10).unwrap();\n        assert_eq!(result.items.len(), 0);\n        assert_eq!(result.page, 2);\n        assert_eq!(result.total_pages, 0);\n    }\n\n    // Tests for SearchableRepository\n    #[test]\n    fn test_searchable_repository_search() {\n        let repo = MockSearchableRepository::new();\n        \n        // Add some test entities\n        repo.save(MockEntity::new(\"1\", \"alice\", 10)).unwrap();\n        repo.save(MockEntity::new(\"2\", \"bob\", 20)).unwrap();\n        repo.save(MockEntity::new(\"3\", \"alice\", 30)).unwrap();\n        \n        let criteria = SearchCriteria::new().with_filter(\"name\", \"alice\");\n        let results = repo.search(\u0026criteria).unwrap();\n        \n        assert_eq!(results.len(), 2);\n        assert_eq!(results[0].name, \"alice\");\n        assert_eq!(results[1].name, \"alice\");\n    }\n\n    #[test]\n    fn test_searchable_repository_search_with_sorting() {\n        let repo = MockSearchableRepository::new();\n        \n        // Add some test entities\n        repo.save(MockEntity::new(\"1\", \"alice\", 30)).unwrap();\n        repo.save(MockEntity::new(\"2\", \"bob\", 10)).unwrap();\n        repo.save(MockEntity::new(\"3\", \"charlie\", 20)).unwrap();\n        \n        let criteria = SearchCriteria::new()\n            .sort_by(\"value\")\n            .sort_order(SortOrder::Ascending);\n        \n        let results = repo.search(\u0026criteria).unwrap();\n        assert_eq!(results.len(), 3);\n        assert_eq!(results[0].value, 10);\n        assert_eq!(results[1].value, 20);\n        assert_eq!(results[2].value, 30);\n    }\n\n    #[test]\n    fn test_searchable_repository_search_with_pagination() {\n        let repo = MockSearchableRepository::new();\n        \n        // Add some test entities\n        for i in 1..=5 {\n            repo.save(MockEntity::new(\u0026i.to_string(), \u0026format!(\"test{}\", i), i * 10)).unwrap();\n        }\n        \n        let criteria = SearchCriteria::new();\n        let result = repo.search_with_pagination(\u0026criteria, 1, 2).unwrap();\n        \n        assert_eq!(result.items.len(), 2);\n        assert_eq!(result.page, 1);\n        assert_eq!(result.size, 2);\n        assert_eq!(result.total, 5);\n        assert_eq!(result.total_pages, 3);\n    }\n\n    // Tests for TransactionalRepository\n    #[test]\n    fn test_transactional_repository_begin_transaction() {\n        let repo = MockTransactionalRepository::new();\n        let _transaction = repo.begin_transaction().unwrap();\n        \n        // Just test that we can create a transaction\n        assert!(true);\n    }\n\n    #[test]\n    fn test_transactional_repository_with_transaction() {\n        let repo = MockTransactionalRepository::new();\n        \n        let result = repo.with_transaction(|_transaction| {\n            Ok::\u003cString, DomainError\u003e(\"transaction_result\".to_string())\n        }).unwrap();\n        \n        assert_eq!(result, \"transaction_result\");\n    }\n\n    // Tests for Transaction\n    #[test]\n    fn test_mock_transaction_commit() {\n        let transaction = MockTransaction::new();\n        let boxed_transaction = Box::new(transaction);\n        \n        let result = boxed_transaction.commit();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_mock_transaction_rollback() {\n        let transaction = MockTransaction::new();\n        let boxed_transaction = Box::new(transaction);\n        \n        let result = boxed_transaction.rollback();\n        assert!(result.is_ok());\n    }\n\n    // Tests for CachedRepository\n    #[test]\n    fn test_cached_repository_cache_key() {\n        let repo = MockCachedRepository::new();\n        let cache_key = repo.cache_key(\u0026\"test_id\".to_string());\n        assert_eq!(cache_key, \"entity:test_id\");\n    }\n\n    #[test]\n    fn test_cached_repository_find_by_id_with_cache() {\n        let repo = MockCachedRepository::new();\n        let entity = MockEntity::new(\"1\", \"test\", 42);\n        \n        // First find should populate cache\n        let found_entity = repo.find_by_id(\u0026\"1\".to_string()).unwrap();\n        assert_eq!(found_entity, None);\n        \n        // Save entity\n        repo.save(entity.clone()).unwrap();\n        \n        // Find again should use cache\n        let found_entity = repo.find_by_id(\u0026\"1\".to_string()).unwrap();\n        assert_eq!(found_entity, Some(entity));\n    }\n\n    #[test]\n    fn test_cached_repository_invalidate_cache() {\n        let repo = MockCachedRepository::new();\n        let entity = MockEntity::new(\"1\", \"test\", 42);\n        \n        repo.save(entity.clone()).unwrap();\n        repo.find_by_id(\u0026\"1\".to_string()).unwrap(); // Populate cache\n        \n        // Invalidate cache\n        repo.invalidate_cache(\u0026\"1\".to_string()).unwrap();\n        \n        // Cache should be cleared\n        let found_entity = repo.find_by_id(\u0026\"1\".to_string()).unwrap();\n        assert_eq!(found_entity, Some(entity)); // Should still find from base repo\n    }\n\n    #[test]\n    fn test_cached_repository_clear_cache() {\n        let repo = MockCachedRepository::new();\n        let entity1 = MockEntity::new(\"1\", \"test1\", 10);\n        let entity2 = MockEntity::new(\"2\", \"test2\", 20);\n        \n        repo.save(entity1.clone()).unwrap();\n        repo.save(entity2.clone()).unwrap();\n        repo.find_by_id(\u0026\"1\".to_string()).unwrap(); // Populate cache\n        repo.find_by_id(\u0026\"2\".to_string()).unwrap(); // Populate cache\n        \n        // Clear all cache\n        repo.clear_cache().unwrap();\n        \n        // Should still work but without cache\n        let found_entity = repo.find_by_id(\u0026\"1\".to_string()).unwrap();\n        assert_eq!(found_entity, Some(entity1));\n    }\n\n    // Tests for LoggingRepositoryDecorator\n    #[test]\n    fn test_logging_repository_decorator_new() {\n        let base_repo = MockRepository::new();\n        let _decorator = LoggingRepositoryDecorator::new(base_repo);\n        \n        // Just test that we can create the decorator\n        assert!(true);\n    }\n\n    #[test]\n    fn test_logging_repository_decorator_find_by_id() {\n        let base_repo = MockRepository::new();\n        let decorator = LoggingRepositoryDecorator::new(base_repo);\n        \n        let result = decorator.find_by_id(\u0026\"nonexistent\".to_string());\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), None);\n    }\n\n    #[test]\n    fn test_logging_repository_decorator_save() {\n        let base_repo = MockRepository::new();\n        let decorator = LoggingRepositoryDecorator::new(base_repo);\n        \n        let entity = MockEntity::new(\"1\", \"test\", 42);\n        let result = decorator.save(entity.clone());\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), entity);\n    }\n\n    // Tests for complex scenarios\n    #[test]\n    fn test_repository_complex_workflow() {\n        let repo = MockRepository::new();\n        \n        // Create entities\n        let entity1 = MockEntity::new(\"1\", \"alice\", 25);\n        let entity2 = MockEntity::new(\"2\", \"bob\", 30);\n        let entity3 = MockEntity::new(\"3\", \"charlie\", 35);\n        \n        // Save entities\n        repo.save(entity1.clone()).unwrap();\n        repo.save(entity2.clone()).unwrap();\n        repo.save(entity3.clone()).unwrap();\n        \n        // Verify count\n        assert_eq!(repo.count().unwrap(), 3);\n        \n        // Find specific entity\n        let found = repo.find_by_id(\u0026\"2\".to_string()).unwrap();\n        assert_eq!(found, Some(entity2.clone()));\n        \n        // Update entity\n        let updated_entity = MockEntity::new(\"2\", \"robert\", 31);\n        let updated = repo.update(updated_entity.clone()).unwrap();\n        assert_eq!(updated, updated_entity);\n        \n        // Verify update\n        let found = repo.find_by_id(\u0026\"2\".to_string()).unwrap();\n        assert_eq!(found, Some(updated_entity));\n        \n        // Delete entity\n        let deleted = repo.delete(\u0026\"1\".to_string()).unwrap();\n        assert!(deleted);\n        \n        // Verify deletion\n        assert_eq!(repo.count().unwrap(), 2);\n        assert!(!repo.exists(\u0026\"1\".to_string()).unwrap());\n    }\n\n    #[test]\n    fn test_searchable_repository_complex_search() {\n        let repo = MockSearchableRepository::new();\n        \n        // Add test entities with various values\n        let entities = vec![\n            MockEntity::new(\"1\", \"alice\", 25),\n            MockEntity::new(\"2\", \"bob\", 30),\n            MockEntity::new(\"3\", \"alice\", 35),\n            MockEntity::new(\"4\", \"charlie\", 20),\n            MockEntity::new(\"5\", \"alice\", 40),\n        ];\n        \n        for entity in entities {\n            repo.save(entity).unwrap();\n        }\n        \n        // Search for alice with value \u003e 30, sorted by value descending\n        let criteria = SearchCriteria::new()\n            .with_filter(\"name\", \"alice\")\n            .sort_by(\"value\")\n            .sort_order(SortOrder::Descending);\n        \n        let results = repo.search(\u0026criteria).unwrap();\n        assert_eq!(results.len(), 3);\n        assert_eq!(results[0].value, 40);\n        assert_eq!(results[1].value, 35);\n        assert_eq!(results[2].value, 25);\n    }\n\n    // Tests for edge cases\n    #[test]\n    fn test_repository_empty_operations() {\n        let repo = MockRepository::new();\n        \n        // Test operations on empty repository\n        assert_eq!(repo.count().unwrap(), 0);\n        assert_eq!(repo.find_all().unwrap().len(), 0);\n        assert_eq!(repo.find_by_id(\u0026\"nonexistent\".to_string()).unwrap(), None);\n        assert!(!repo.exists(\u0026\"nonexistent\".to_string()).unwrap());\n        assert!(!repo.delete(\u0026\"nonexistent\".to_string()).unwrap());\n    }\n\n    #[test]\n    fn test_paginated_result_edge_cases() {\n        // Test with size 0\n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 1, 0, 10);\n        assert_eq!(result.total_pages, 0);\n        \n        // Test with page 0 (edge case)\n        let result: PaginatedResult\u003cMockEntity\u003e = PaginatedResult::new(Vec::new(), 0, 10, 10);\n        assert_eq!(result.page, 0);\n        assert!(!result.has_previous());\n    }\n\n    #[test]\n    fn test_search_criteria_edge_cases() {\n        // Test with empty filter values\n        let criteria = SearchCriteria::new()\n            .with_filter(\"empty\", \"\")\n            .with_filter(\"whitespace\", \"   \");\n        \n        assert_eq!(criteria.filters.get(\"empty\"), Some(\u0026\"\".to_string()));\n        assert_eq!(criteria.filters.get(\"whitespace\"), Some(\u0026\"   \".to_string()));\n    }\n}\n","traces":[{"line":80,"address":[2927504],"length":1,"stats":{"Line":1}},{"line":82,"address":[2927518],"length":1,"stats":{"Line":3}},{"line":89,"address":[1420896,1421297,1421277],"length":1,"stats":{"Line":1}},{"line":90,"address":[1421258,1420986,1421093],"length":1,"stats":{"Line":5}},{"line":91,"address":[1421235],"length":1,"stats":{"Line":4}},{"line":95,"address":[1421574,1421312],"length":1,"stats":{"Line":2}},{"line":96,"address":[1421432,1421370],"length":1,"stats":{"Line":3}},{"line":97,"address":[1421551],"length":1,"stats":{"Line":3}},{"line":101,"address":[2927632],"length":1,"stats":{"Line":1}},{"line":102,"address":[2927655],"length":1,"stats":{"Line":1}},{"line":103,"address":[2927660],"length":1,"stats":{"Line":2}},{"line":108,"address":[2927680],"length":1,"stats":{"Line":1}},{"line":109,"address":[2927688],"length":1,"stats":{"Line":1}},{"line":132,"address":[1421869,1421600],"length":1,"stats":{"Line":1}},{"line":133,"address":[1421652,1421859],"length":1,"stats":{"Line":7}},{"line":145,"address":[1421888],"length":1,"stats":{"Line":1}},{"line":146,"address":[1421893],"length":1,"stats":{"Line":1}},{"line":150,"address":[1421920],"length":1,"stats":{"Line":2}},{"line":151,"address":[1421925],"length":1,"stats":{"Line":2}},{"line":155,"address":[1421936],"length":1,"stats":{"Line":1}},{"line":156,"address":[1421950,1422013],"length":1,"stats":{"Line":2}},{"line":160,"address":[1422048],"length":1,"stats":{"Line":1}},{"line":161,"address":[1422062,1422129],"length":1,"stats":{"Line":2}},{"line":187,"address":[1422160],"length":1,"stats":{"Line":2}},{"line":189,"address":[1422164],"length":1,"stats":{"Line":3}},{"line":194,"address":[1422208],"length":1,"stats":{"Line":3}},{"line":195,"address":[1422217],"length":1,"stats":{"Line":3}},{"line":199,"address":[1422272],"length":1,"stats":{"Line":3}},{"line":200,"address":[1422281],"length":1,"stats":{"Line":4}},{"line":208,"address":[1422548,1422336,1422554],"length":1,"stats":{"Line":2}},{"line":209,"address":[1422384],"length":1,"stats":{"Line":2}},{"line":210,"address":[1422406,1422462],"length":1,"stats":{"Line":4}},{"line":213,"address":[1422798,1422804,1422576],"length":1,"stats":{"Line":1}},{"line":214,"address":[1422614],"length":1,"stats":{"Line":1}},{"line":215,"address":[1422636,1422695],"length":1,"stats":{"Line":2}},{"line":218,"address":[1423591,1422832,1423616],"length":1,"stats":{"Line":1}},{"line":221,"address":[1422875,1422973],"length":1,"stats":{"Line":6}},{"line":225,"address":[1422989,1423040],"length":1,"stats":{"Line":11}},{"line":228,"address":[1423254,1423569,1423196],"length":1,"stats":{"Line":9}},{"line":230,"address":[1423426],"length":1,"stats":{"Line":6}},{"line":233,"address":[1424137,1423648],"length":1,"stats":{"Line":1}},{"line":237,"address":[1423761,1423697],"length":1,"stats":{"Line":2}},{"line":238,"address":[1424056],"length":1,"stats":{"Line":1}},{"line":241,"address":[1424160,1424424,1424430],"length":1,"stats":{"Line":1}},{"line":242,"address":[1424211],"length":1,"stats":{"Line":1}},{"line":243,"address":[1424297,1424233],"length":1,"stats":{"Line":2}},{"line":244,"address":[1424388],"length":1,"stats":{"Line":1}},{"line":247,"address":[1424621,1424448,1424615],"length":1,"stats":{"Line":1}},{"line":248,"address":[1424490],"length":1,"stats":{"Line":1}},{"line":249,"address":[1424512,1424562],"length":1,"stats":{"Line":2}},{"line":252,"address":[1424640,1424792,1424798],"length":1,"stats":{"Line":1}},{"line":253,"address":[1424672],"length":1,"stats":{"Line":2}},{"line":254,"address":[1424694,1424739],"length":1,"stats":{"Line":3}},{"line":262,"address":[1424816],"length":1,"stats":{"Line":1}},{"line":263,"address":[1424817],"length":1,"stats":{"Line":1}},{"line":279,"address":[1424832],"length":1,"stats":{"Line":3}},{"line":292,"address":[1425315,1424848,1425309],"length":1,"stats":{"Line":1}},{"line":293,"address":[1424883],"length":1,"stats":{"Line":1}},{"line":294,"address":[1424958],"length":1,"stats":{"Line":1}},{"line":295,"address":[1424973,1425037],"length":1,"stats":{"Line":2}},{"line":296,"address":[1425074,1425217],"length":1,"stats":{"Line":0}},{"line":297,"address":[1425163,1425100],"length":1,"stats":{"Line":2}},{"line":298,"address":[1425238,1425003],"length":1,"stats":{"Line":0}},{"line":300,"address":[1425189],"length":1,"stats":{"Line":1}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[1425328,1425791],"length":1,"stats":{"Line":1}},{"line":314,"address":[1425442,1425362],"length":1,"stats":{"Line":2}},{"line":315,"address":[1425467],"length":1,"stats":{"Line":1}},{"line":316,"address":[1425542],"length":1,"stats":{"Line":1}},{"line":317,"address":[1425666,1425603],"length":1,"stats":{"Line":2}},{"line":318,"address":[1425572,1425720],"length":1,"stats":{"Line":0}},{"line":320,"address":[1425692],"length":1,"stats":{"Line":1}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}}],"covered":68,"coverable":106},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","shared","specification.rs"],"content":"use std::fmt;\n\n/// A specification pattern implementation for domain validation\npub trait Specification\u003cT\u003e {\n    /// Check if the specification is satisfied by the given item\n    fn is_satisfied_by(\u0026self, item: \u0026T) -\u003e bool;\n\n    /// Get a description of what this specification checks\n    fn description(\u0026self) -\u003e \u0026str;\n\n    /// Get a detailed explanation of why the specification failed\n    fn explain_why_not_satisfied(\u0026self, item: \u0026T) -\u003e Option\u003cString\u003e {\n        if self.is_satisfied_by(item) {\n            None\n        } else {\n            Some(format!(\"Item does not satisfy: {}\", self.description()))\n        }\n    }\n}\n\n/// A composite specification that combines multiple specifications with AND logic\npub struct AndSpecification\u003cT\u003e {\n    specifications: Vec\u003cBox\u003cdyn Specification\u003cT\u003e\u003e\u003e,\n}\n\nimpl\u003cT\u003e AndSpecification\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        Self {\n            specifications: Vec::new(),\n        }\n    }\n\n    pub fn add(mut self, spec: Box\u003cdyn Specification\u003cT\u003e\u003e) -\u003e Self {\n        self.specifications.push(spec);\n        self\n    }\n\n    pub fn add_all(mut self, specs: Vec\u003cBox\u003cdyn Specification\u003cT\u003e\u003e\u003e) -\u003e Self {\n        self.specifications.extend(specs);\n        self\n    }\n}\n\nimpl\u003cT\u003e Specification\u003cT\u003e for AndSpecification\u003cT\u003e {\n    fn is_satisfied_by(\u0026self, item: \u0026T) -\u003e bool {\n        self.specifications.iter().all(|spec| spec.is_satisfied_by(item))\n    }\n\n    fn description(\u0026self) -\u003e \u0026str {\n        \"All specifications must be satisfied\"\n    }\n\n    fn explain_why_not_satisfied(\u0026self, item: \u0026T) -\u003e Option\u003cString\u003e {\n        let failed_specs: Vec\u003cString\u003e = self\n            .specifications\n            .iter()\n            .filter_map(|spec| spec.explain_why_not_satisfied(item))\n            .collect();\n\n        if failed_specs.is_empty() {\n            None\n        } else {\n            Some(format!(\"Failed specifications: {}\", failed_specs.join(\"; \")))\n        }\n    }\n}\n\nimpl\u003cT\u003e Default for AndSpecification\u003cT\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A composite specification that combines multiple specifications with OR logic\npub struct OrSpecification\u003cT\u003e {\n    specifications: Vec\u003cBox\u003cdyn Specification\u003cT\u003e\u003e\u003e,\n}\n\nimpl\u003cT\u003e OrSpecification\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        Self {\n            specifications: Vec::new(),\n        }\n    }\n\n    pub fn add(mut self, spec: Box\u003cdyn Specification\u003cT\u003e\u003e) -\u003e Self {\n        self.specifications.push(spec);\n        self\n    }\n\n    pub fn add_all(mut self, specs: Vec\u003cBox\u003cdyn Specification\u003cT\u003e\u003e\u003e) -\u003e Self {\n        self.specifications.extend(specs);\n        self\n    }\n}\n\nimpl\u003cT\u003e Specification\u003cT\u003e for OrSpecification\u003cT\u003e {\n    fn is_satisfied_by(\u0026self, item: \u0026T) -\u003e bool {\n        self.specifications.iter().any(|spec| spec.is_satisfied_by(item))\n    }\n\n    fn description(\u0026self) -\u003e \u0026str {\n        \"At least one specification must be satisfied\"\n    }\n\n    fn explain_why_not_satisfied(\u0026self, item: \u0026T) -\u003e Option\u003cString\u003e {\n        if self.is_satisfied_by(item) {\n            None\n        } else {\n            let failed_specs: Vec\u003cString\u003e = self\n                .specifications\n                .iter()\n                .map(|spec| spec.description().to_string())\n                .collect();\n            Some(format!(\n                \"None of the specifications were satisfied: {}\",\n                failed_specs.join(\", \")\n            ))\n        }\n    }\n}\n\nimpl\u003cT\u003e Default for OrSpecification\u003cT\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A specification that negates another specification\npub struct NotSpecification\u003cT\u003e {\n    specification: Box\u003cdyn Specification\u003cT\u003e\u003e,\n}\n\nimpl\u003cT\u003e NotSpecification\u003cT\u003e {\n    pub fn new(specification: Box\u003cdyn Specification\u003cT\u003e\u003e) -\u003e Self {\n        Self { specification }\n    }\n}\n\nimpl\u003cT\u003e Specification\u003cT\u003e for NotSpecification\u003cT\u003e {\n    fn is_satisfied_by(\u0026self, item: \u0026T) -\u003e bool {\n        !self.specification.is_satisfied_by(item)\n    }\n\n    fn description(\u0026self) -\u003e \u0026str {\n        \"Specification must NOT be satisfied\"\n    }\n\n    fn explain_why_not_satisfied(\u0026self, item: \u0026T) -\u003e Option\u003cString\u003e {\n        if self.is_satisfied_by(item) {\n            None\n        } else {\n            Some(format!(\n                \"Item unexpectedly satisfied: {}\",\n                self.specification.description()\n            ))\n        }\n    }\n}\n\n/// A specification that always returns true\npub struct AlwaysTrueSpecification;\n\nimpl\u003cT\u003e Specification\u003cT\u003e for AlwaysTrueSpecification {\n    fn is_satisfied_by(\u0026self, _item: \u0026T) -\u003e bool {\n        true\n    }\n\n    fn description(\u0026self) -\u003e \u0026str {\n        \"Always satisfied\"\n    }\n}\n\n/// A specification that always returns false\npub struct AlwaysFalseSpecification;\n\nimpl\u003cT\u003e Specification\u003cT\u003e for AlwaysFalseSpecification {\n    fn is_satisfied_by(\u0026self, _item: \u0026T) -\u003e bool {\n        false\n    }\n\n    fn description(\u0026self) -\u003e \u0026str {\n        \"Never satisfied\"\n    }\n\n    fn explain_why_not_satisfied(\u0026self, _item: \u0026T) -\u003e Option\u003cString\u003e {\n        Some(\"This specification is never satisfied\".to_string())\n    }\n}\n\n/// Extension trait for easier specification composition\npub trait SpecificationExt\u003cT\u003e: Specification\u003cT\u003e + Sized + 'static {\n    // 'static necessário para Box\u003cdyn\u003e\n    /// Combine this specification with another using AND logic\n    fn and\u003cS\u003e(self, other: S) -\u003e AndSpecification\u003cT\u003e\n    where\n        S: Specification\u003cT\u003e + 'static, // 'static necessário para Box\u003cdyn\u003e\n    {\n        AndSpecification::new().add(Box::new(self)).add(Box::new(other))\n    }\n\n    /// Combine this specification with another using OR logic\n    fn or\u003cS\u003e(self, other: S) -\u003e OrSpecification\u003cT\u003e\n    where\n        S: Specification\u003cT\u003e + 'static, // 'static necessário para Box\u003cdyn\u003e\n    {\n        OrSpecification::new().add(Box::new(self)).add(Box::new(other))\n    }\n\n    /// Negate this specification\n    fn not(self) -\u003e NotSpecification\u003cT\u003e {\n        NotSpecification::new(Box::new(self))\n    }\n}\n\nimpl\u003cT, S\u003e SpecificationExt\u003cT\u003e for S where S: Specification\u003cT\u003e + 'static {} // 'static necessário para Box\u003cdyn\u003e\n\n/// A specification that checks if a value is within a range\npub struct RangeSpecification\u003cT\u003e {\n    min: Option\u003cT\u003e,\n    max: Option\u003cT\u003e,\n    description: String,\n}\n\nimpl\u003cT\u003e RangeSpecification\u003cT\u003e\nwhere\n    T: PartialOrd + fmt::Display,\n{\n    pub fn new(min: Option\u003cT\u003e, max: Option\u003cT\u003e) -\u003e Self {\n        let description = match (\u0026min, \u0026max) {\n            (Some(min), Some(max)) =\u003e format!(\"Value must be between {} and {}\", min, max),\n            (Some(min), None) =\u003e format!(\"Value must be at least {}\", min),\n            (None, Some(max)) =\u003e format!(\"Value must be at most {}\", max),\n            (None, None) =\u003e \"No range constraints\".to_string(),\n        };\n\n        Self { min, max, description }\n    }\n\n    pub fn min(mut self, min: T) -\u003e Self {\n        self.min = Some(min);\n        self.description = match (\u0026self.min, \u0026self.max) {\n            (Some(min), Some(max)) =\u003e format!(\"Value must be between {} and {}\", min, max),\n            (Some(min), None) =\u003e format!(\"Value must be at least {}\", min),\n            (None, Some(max)) =\u003e format!(\"Value must be at most {}\", max),\n            (None, None) =\u003e \"No range constraints\".to_string(),\n        };\n        self\n    }\n\n    pub fn max(mut self, max: T) -\u003e Self {\n        self.max = Some(max);\n        self.description = match (\u0026self.min, \u0026self.max) {\n            (Some(min), Some(max)) =\u003e format!(\"Value must be between {} and {}\", min, max),\n            (Some(min), None) =\u003e format!(\"Value must be at least {}\", min),\n            (None, Some(max)) =\u003e format!(\"Value must be at most {}\", max),\n            (None, None) =\u003e \"No range constraints\".to_string(),\n        };\n        self\n    }\n}\n\nimpl\u003cT\u003e Specification\u003cT\u003e for RangeSpecification\u003cT\u003e\nwhere\n    T: PartialOrd + fmt::Display,\n{\n    fn is_satisfied_by(\u0026self, item: \u0026T) -\u003e bool {\n        let min_ok = self.min.as_ref().is_none_or(|min| item \u003e= min);\n        let max_ok = self.max.as_ref().is_none_or(|max| item \u003c= max);\n        min_ok \u0026\u0026 max_ok\n    }\n\n    fn description(\u0026self) -\u003e \u0026str {\n        \u0026self.description\n    }\n\n    fn explain_why_not_satisfied(\u0026self, item: \u0026T) -\u003e Option\u003cString\u003e {\n        if self.is_satisfied_by(item) {\n            None\n        } else {\n            let mut reasons = Vec::new();\n\n            if let Some(min) = \u0026self.min\n                \u0026\u0026 item \u003c min\n            {\n                reasons.push(format!(\"Value {} is below minimum {}\", item, min));\n            }\n\n            if let Some(max) = \u0026self.max\n                \u0026\u0026 item \u003e max\n            {\n                reasons.push(format!(\"Value {} is above maximum {}\", item, max));\n            }\n\n            Some(reasons.join(\"; \"))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Mock entity for testing\n    #[derive(Debug, Clone, PartialEq)]\n    struct MockEntity {\n        id: u32,\n        name: String,\n        value: i32,\n        active: bool,\n    }\n\n    impl MockEntity {\n        fn new(id: u32, name: \u0026str, value: i32, active: bool) -\u003e Self {\n            Self {\n                id,\n                name: name.to_string(),\n                value,\n                active,\n            }\n        }\n    }\n\n    // Mock specifications for testing\n    struct IdGreaterThanSpec {\n        threshold: u32,\n        description: String,\n    }\n\n    impl IdGreaterThanSpec {\n        fn new(threshold: u32) -\u003e Self {\n            Self { \n                threshold,\n                description: format!(\"ID must be greater than {}\", threshold)\n            }\n        }\n    }\n\n    impl Specification\u003cMockEntity\u003e for IdGreaterThanSpec {\n        fn is_satisfied_by(\u0026self, item: \u0026MockEntity) -\u003e bool {\n            item.id \u003e self.threshold\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            \u0026self.description\n        }\n    }\n\n    struct NameContainsSpec {\n        substring: String,\n        description: String,\n    }\n\n    impl NameContainsSpec {\n        fn new(substring: \u0026str) -\u003e Self {\n            Self {\n                substring: substring.to_string(),\n                description: format!(\"Name must contain '{}'\", substring)\n            }\n        }\n    }\n\n    impl Specification\u003cMockEntity\u003e for NameContainsSpec {\n        fn is_satisfied_by(\u0026self, item: \u0026MockEntity) -\u003e bool {\n            item.name.contains(\u0026self.substring)\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            \u0026self.description\n        }\n    }\n\n    struct ValueInRangeSpec {\n        min: i32,\n        max: i32,\n        description: String,\n    }\n\n    impl ValueInRangeSpec {\n        fn new(min: i32, max: i32) -\u003e Self {\n            Self { \n                min, \n                max,\n                description: format!(\"Value must be between {} and {}\", min, max)\n            }\n        }\n    }\n\n    impl Specification\u003cMockEntity\u003e for ValueInRangeSpec {\n        fn is_satisfied_by(\u0026self, item: \u0026MockEntity) -\u003e bool {\n            item.value \u003e= self.min \u0026\u0026 item.value \u003c= self.max\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            \u0026self.description\n        }\n    }\n\n    struct ActiveSpec;\n\n    impl Specification\u003cMockEntity\u003e for ActiveSpec {\n        fn is_satisfied_by(\u0026self, item: \u0026MockEntity) -\u003e bool {\n            item.active\n        }\n\n        fn description(\u0026self) -\u003e \u0026str {\n            \"Entity must be active\"\n        }\n    }\n\n    // Tests for basic Specification trait\n    #[test]\n    fn test_specification_trait_basic_functionality() {\n        let spec = IdGreaterThanSpec::new(5);\n        let entity1 = MockEntity::new(10, \"test\", 42, true);\n        let entity2 = MockEntity::new(3, \"test\", 42, true);\n\n        assert!(spec.is_satisfied_by(\u0026entity1));\n        assert!(!spec.is_satisfied_by(\u0026entity2));\n        assert_eq!(spec.description(), \"ID must be greater than 5\");\n    }\n\n    #[test]\n    fn test_specification_explain_why_not_satisfied() {\n        let spec = IdGreaterThanSpec::new(5);\n        let entity = MockEntity::new(3, \"test\", 42, true);\n\n        let explanation = spec.explain_why_not_satisfied(\u0026entity);\n        assert_eq!(explanation, Some(\"Item does not satisfy: ID must be greater than 5\".to_string()));\n\n        let entity_satisfied = MockEntity::new(10, \"test\", 42, true);\n        let explanation_satisfied = spec.explain_why_not_satisfied(\u0026entity_satisfied);\n        assert_eq!(explanation_satisfied, None);\n    }\n\n    // Tests for AndSpecification\n    #[test]\n    fn test_and_specification_new() {\n        let spec = AndSpecification::\u003cMockEntity\u003e::new();\n        assert_eq!(spec.specifications.len(), 0);\n    }\n\n    #[test]\n    fn test_and_specification_default() {\n        let spec = AndSpecification::\u003cMockEntity\u003e::default();\n        assert_eq!(spec.specifications.len(), 0);\n    }\n\n    #[test]\n    fn test_and_specification_add() {\n        let spec = AndSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        assert_eq!(spec.specifications.len(), 2);\n    }\n\n    #[test]\n    fn test_and_specification_add_all() {\n        let specs = vec![\n            Box::new(IdGreaterThanSpec::new(5)) as Box\u003cdyn Specification\u003cMockEntity\u003e\u003e,\n            Box::new(NameContainsSpec::new(\"test\")),\n        ];\n\n        let spec = AndSpecification::new().add_all(specs);\n        assert_eq!(spec.specifications.len(), 2);\n    }\n\n    #[test]\n    fn test_and_specification_is_satisfied_by_all_true() {\n        let spec = AndSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        let entity = MockEntity::new(10, \"test entity\", 42, true);\n        assert!(spec.is_satisfied_by(\u0026entity));\n    }\n\n    #[test]\n    fn test_and_specification_is_satisfied_by_some_false() {\n        let spec = AndSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        let entity = MockEntity::new(10, \"other entity\", 42, true);\n        assert!(!spec.is_satisfied_by(\u0026entity));\n    }\n\n    #[test]\n    fn test_and_specification_is_satisfied_by_all_false() {\n        let spec = AndSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        let entity = MockEntity::new(3, \"other entity\", 42, true);\n        assert!(!spec.is_satisfied_by(\u0026entity));\n    }\n\n    #[test]\n    fn test_and_specification_description() {\n        let spec = AndSpecification::\u003cMockEntity\u003e::new();\n        assert_eq!(spec.description(), \"All specifications must be satisfied\");\n    }\n\n    #[test]\n    fn test_and_specification_explain_why_not_satisfied() {\n        let spec = AndSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        let entity = MockEntity::new(3, \"other entity\", 42, true);\n        let explanation = spec.explain_why_not_satisfied(\u0026entity);\n        assert!(explanation.is_some());\n        assert!(explanation.unwrap().contains(\"Failed specifications\"));\n    }\n\n    #[test]\n    fn test_and_specification_explain_why_not_satisfied_all_passed() {\n        let spec = AndSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        let entity = MockEntity::new(10, \"test entity\", 42, true);\n        let explanation = spec.explain_why_not_satisfied(\u0026entity);\n        assert_eq!(explanation, None);\n    }\n\n    // Tests for OrSpecification\n    #[test]\n    fn test_or_specification_new() {\n        let spec = OrSpecification::\u003cMockEntity\u003e::new();\n        assert_eq!(spec.specifications.len(), 0);\n    }\n\n    #[test]\n    fn test_or_specification_default() {\n        let spec = OrSpecification::\u003cMockEntity\u003e::default();\n        assert_eq!(spec.specifications.len(), 0);\n    }\n\n    #[test]\n    fn test_or_specification_add() {\n        let spec = OrSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        assert_eq!(spec.specifications.len(), 2);\n    }\n\n    #[test]\n    fn test_or_specification_add_all() {\n        let specs = vec![\n            Box::new(IdGreaterThanSpec::new(5)) as Box\u003cdyn Specification\u003cMockEntity\u003e\u003e,\n            Box::new(NameContainsSpec::new(\"test\")),\n        ];\n\n        let spec = OrSpecification::new().add_all(specs);\n        assert_eq!(spec.specifications.len(), 2);\n    }\n\n    #[test]\n    fn test_or_specification_is_satisfied_by_any_true() {\n        let spec = OrSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        let entity = MockEntity::new(10, \"other entity\", 42, true);\n        assert!(spec.is_satisfied_by(\u0026entity));\n    }\n\n    #[test]\n    fn test_or_specification_is_satisfied_by_all_false() {\n        let spec = OrSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        let entity = MockEntity::new(3, \"other entity\", 42, true);\n        assert!(!spec.is_satisfied_by(\u0026entity));\n    }\n\n    #[test]\n    fn test_or_specification_description() {\n        let spec = OrSpecification::\u003cMockEntity\u003e::new();\n        assert_eq!(spec.description(), \"At least one specification must be satisfied\");\n    }\n\n    #[test]\n    fn test_or_specification_explain_why_not_satisfied() {\n        let spec = OrSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        let entity = MockEntity::new(3, \"other entity\", 42, true);\n        let explanation = spec.explain_why_not_satisfied(\u0026entity);\n        assert!(explanation.is_some());\n        assert!(explanation.unwrap().contains(\"None of the specifications were satisfied\"));\n    }\n\n    #[test]\n    fn test_or_specification_explain_why_not_satisfied_some_passed() {\n        let spec = OrSpecification::new()\n            .add(Box::new(IdGreaterThanSpec::new(5)))\n            .add(Box::new(NameContainsSpec::new(\"test\")));\n\n        let entity = MockEntity::new(10, \"other entity\", 42, true);\n        let explanation = spec.explain_why_not_satisfied(\u0026entity);\n        assert_eq!(explanation, None);\n    }\n\n    // Tests for NotSpecification\n    #[test]\n    fn test_not_specification_new() {\n        let inner_spec = IdGreaterThanSpec::new(5);\n        let spec = NotSpecification::new(Box::new(inner_spec));\n        assert!(spec.specification.is_satisfied_by(\u0026MockEntity::new(10, \"test\", 42, true)));\n    }\n\n    #[test]\n    fn test_not_specification_is_satisfied_by() {\n        let inner_spec = IdGreaterThanSpec::new(5);\n        let spec = NotSpecification::new(Box::new(inner_spec));\n\n        let entity_above = MockEntity::new(10, \"test\", 42, true);\n        let entity_below = MockEntity::new(3, \"test\", 42, true);\n\n        assert!(!spec.is_satisfied_by(\u0026entity_above)); // inner spec is true, so not spec is false\n        assert!(spec.is_satisfied_by(\u0026entity_below));   // inner spec is false, so not spec is true\n    }\n\n    #[test]\n    fn test_not_specification_description() {\n        let inner_spec = IdGreaterThanSpec::new(5);\n        let spec = NotSpecification::new(Box::new(inner_spec));\n        assert_eq!(spec.description(), \"Specification must NOT be satisfied\");\n    }\n\n    #[test]\n    fn test_not_specification_explain_why_not_satisfied() {\n        let inner_spec = IdGreaterThanSpec::new(5);\n        let spec = NotSpecification::new(Box::new(inner_spec));\n\n        let entity = MockEntity::new(10, \"test\", 42, true);\n        let explanation = spec.explain_why_not_satisfied(\u0026entity);\n        assert!(explanation.is_some());\n        assert!(explanation.unwrap().contains(\"Item unexpectedly satisfied\"));\n    }\n\n    #[test]\n    fn test_not_specification_explain_why_not_satisfied_when_satisfied() {\n        let inner_spec = IdGreaterThanSpec::new(5);\n        let spec = NotSpecification::new(Box::new(inner_spec));\n\n        let entity = MockEntity::new(3, \"test\", 42, true);\n        let explanation = spec.explain_why_not_satisfied(\u0026entity);\n        assert_eq!(explanation, None);\n    }\n\n    // Tests for AlwaysTrueSpecification\n    #[test]\n    fn test_always_true_specification_is_satisfied_by() {\n        let spec: AlwaysTrueSpecification = AlwaysTrueSpecification;\n        let entity = MockEntity::new(1, \"test\", 42, true);\n        assert!(spec.is_satisfied_by(\u0026entity));\n    }\n\n    #[test]\n    fn test_always_true_specification_description() {\n        let spec: AlwaysTrueSpecification = AlwaysTrueSpecification;\n        assert_eq!(\u003cAlwaysTrueSpecification as Specification\u003cMockEntity\u003e\u003e::description(\u0026spec), \"Always satisfied\");\n    }\n\n    #[test]\n    fn test_always_true_specification_explain_why_not_satisfied() {\n        let spec: AlwaysTrueSpecification = AlwaysTrueSpecification;\n        let entity = MockEntity::new(1, \"test\", 42, true);\n        let explanation = spec.explain_why_not_satisfied(\u0026entity);\n        assert_eq!(explanation, None);\n    }\n\n    // Tests for AlwaysFalseSpecification\n    #[test]\n    fn test_always_false_specification_is_satisfied_by() {\n        let spec: AlwaysFalseSpecification = AlwaysFalseSpecification;\n        let entity = MockEntity::new(1, \"test\", 42, true);\n        assert!(!spec.is_satisfied_by(\u0026entity));\n    }\n\n    #[test]\n    fn test_always_false_specification_description() {\n        let spec: AlwaysFalseSpecification = AlwaysFalseSpecification;\n        assert_eq!(\u003cAlwaysFalseSpecification as Specification\u003cMockEntity\u003e\u003e::description(\u0026spec), \"Never satisfied\");\n    }\n\n    #[test]\n    fn test_always_false_specification_explain_why_not_satisfied() {\n        let spec: AlwaysFalseSpecification = AlwaysFalseSpecification;\n        let entity = MockEntity::new(1, \"test\", 42, true);\n        let explanation = spec.explain_why_not_satisfied(\u0026entity);\n        assert_eq!(explanation, Some(\"This specification is never satisfied\".to_string()));\n    }\n\n    // Tests for SpecificationExt trait\n    #[test]\n    fn test_specification_ext_and() {\n        let spec1 = IdGreaterThanSpec::new(5);\n        let spec2 = NameContainsSpec::new(\"test\");\n        let combined = spec1.and(spec2);\n\n        let entity = MockEntity::new(10, \"test entity\", 42, true);\n        assert!(combined.is_satisfied_by(\u0026entity));\n    }\n\n    #[test]\n    fn test_specification_ext_or() {\n        let spec1 = IdGreaterThanSpec::new(5);\n        let spec2 = NameContainsSpec::new(\"test\");\n        let combined = spec1.or(spec2);\n\n        let entity = MockEntity::new(10, \"other entity\", 42, true);\n        assert!(combined.is_satisfied_by(\u0026entity));\n    }\n\n    #[test]\n    fn test_specification_ext_not() {\n        let spec = IdGreaterThanSpec::new(5);\n        let negated = spec.not();\n\n        let entity = MockEntity::new(3, \"test\", 42, true);\n        assert!(negated.is_satisfied_by(\u0026entity));\n    }\n\n    // Tests for RangeSpecification\n    #[test]\n    fn test_range_specification_new_with_min_and_max() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), Some(10));\n        assert_eq!(spec.description(), \"Value must be between 5 and 10\");\n    }\n\n    #[test]\n    fn test_range_specification_new_with_min_only() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), None);\n        assert_eq!(spec.description(), \"Value must be at least 5\");\n    }\n\n    #[test]\n    fn test_range_specification_new_with_max_only() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(None, Some(10));\n        assert_eq!(spec.description(), \"Value must be at most 10\");\n    }\n\n    #[test]\n    fn test_range_specification_new_with_no_constraints() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(None, None);\n        assert_eq!(spec.description(), \"No range constraints\");\n    }\n\n    #[test]\n    fn test_range_specification_min() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(None, None).min(5);\n        assert_eq!(spec.description(), \"Value must be at least 5\");\n    }\n\n    #[test]\n    fn test_range_specification_max() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(None, None).max(10);\n        assert_eq!(spec.description(), \"Value must be at most 10\");\n    }\n\n    #[test]\n    fn test_range_specification_is_satisfied_by_within_range() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), Some(10));\n        assert!(spec.is_satisfied_by(\u00267));\n    }\n\n    #[test]\n    fn test_range_specification_is_satisfied_by_at_min() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), Some(10));\n        assert!(spec.is_satisfied_by(\u00265));\n    }\n\n    #[test]\n    fn test_range_specification_is_satisfied_by_at_max() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), Some(10));\n        assert!(spec.is_satisfied_by(\u002610));\n    }\n\n    #[test]\n    fn test_range_specification_is_satisfied_by_below_min() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), Some(10));\n        assert!(!spec.is_satisfied_by(\u00263));\n    }\n\n    #[test]\n    fn test_range_specification_is_satisfied_by_above_max() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), Some(10));\n        assert!(!spec.is_satisfied_by(\u002615));\n    }\n\n    #[test]\n    fn test_range_specification_is_satisfied_by_min_only() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), None);\n        assert!(spec.is_satisfied_by(\u00267));\n    }\n\n    #[test]\n    fn test_range_specification_is_satisfied_by_max_only() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(None, Some(10));\n        assert!(spec.is_satisfied_by(\u00267));\n    }\n\n    #[test]\n    fn test_range_specification_explain_why_not_satisfied_below_min() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), Some(10));\n        let explanation = spec.explain_why_not_satisfied(\u00263);\n        assert!(explanation.is_some());\n        assert!(explanation.unwrap().contains(\"Value 3 is below minimum 5\"));\n    }\n\n    #[test]\n    fn test_range_specification_explain_why_not_satisfied_above_max() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), Some(10));\n        let explanation = spec.explain_why_not_satisfied(\u002615);\n        assert!(explanation.is_some());\n        assert!(explanation.unwrap().contains(\"Value 15 is above maximum 10\"));\n    }\n\n    #[test]\n    fn test_range_specification_explain_why_not_satisfied_both_violations() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), Some(10));\n        let explanation = spec.explain_why_not_satisfied(\u00263);\n        assert!(explanation.is_some());\n        assert!(explanation.unwrap().contains(\"Value 3 is below minimum 5\"));\n    }\n\n    #[test]\n    fn test_range_specification_explain_why_not_satisfied_when_satisfied() {\n        let spec: RangeSpecification\u003ci32\u003e = RangeSpecification::new(Some(5), Some(10));\n        let explanation = spec.explain_why_not_satisfied(\u00267);\n        assert_eq!(explanation, None);\n    }\n\n    // Complex composition tests\n    #[test]\n    fn test_complex_specification_composition() {\n        let spec = IdGreaterThanSpec::new(5)\n            .and(ActiveSpec)\n            .or(NameContainsSpec::new(\"admin\"))\n            .not();\n\n        let entity1 = MockEntity::new(10, \"user\", 42, true);\n        let entity2 = MockEntity::new(3, \"admin\", 42, false);\n        let entity3 = MockEntity::new(10, \"admin\", 42, true);\n\n        // entity1: id \u003e 5 AND active = true, so (true AND true) OR false = true, so NOT true = false\n        assert!(!spec.is_satisfied_by(\u0026entity1));\n        \n        // entity2: id \u003e 5 AND active = false, so (false AND false) OR true = true, so NOT true = false\n        assert!(!spec.is_satisfied_by(\u0026entity2));\n        \n        // entity3: id \u003e 5 AND active = true, so (true AND true) OR true = true, so NOT true = false\n        assert!(!spec.is_satisfied_by(\u0026entity3));\n    }\n\n    #[test]\n    fn test_empty_and_specification() {\n        let spec = AndSpecification::\u003cMockEntity\u003e::new();\n        let entity = MockEntity::new(1, \"test\", 42, true);\n        // Empty AND specification should be satisfied (vacuous truth)\n        assert!(spec.is_satisfied_by(\u0026entity));\n    }\n\n    #[test]\n    fn test_empty_or_specification() {\n        let spec = OrSpecification::\u003cMockEntity\u003e::new();\n        let entity = MockEntity::new(1, \"test\", 42, true);\n        // Empty OR specification should not be satisfied\n        assert!(!spec.is_satisfied_by(\u0026entity));\n    }\n}\n","traces":[{"line":12,"address":[130288],"length":1,"stats":{"Line":4}},{"line":13,"address":[2395611,2396080,2396656,2395792,2396187,2395899,2396368,2396475],"length":1,"stats":{"Line":7}},{"line":14,"address":[130535],"length":1,"stats":{"Line":3}},{"line":16,"address":[130365],"length":1,"stats":{"Line":2}},{"line":27,"address":[130576],"length":1,"stats":{"Line":1}},{"line":29,"address":[130589],"length":1,"stats":{"Line":1}},{"line":33,"address":[130785,130640],"length":1,"stats":{"Line":1}},{"line":34,"address":[130701],"length":1,"stats":{"Line":1}},{"line":35,"address":[130758],"length":1,"stats":{"Line":1}},{"line":38,"address":[130816,130940],"length":1,"stats":{"Line":1}},{"line":39,"address":[130856],"length":1,"stats":{"Line":1}},{"line":40,"address":[130913],"length":1,"stats":{"Line":1}},{"line":45,"address":[130960],"length":1,"stats":{"Line":4}},{"line":46,"address":[131040,130978,131057],"length":1,"stats":{"Line":7}},{"line":49,"address":[131088],"length":1,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[131652,131120,131646],"length":1,"stats":{"Line":1}},{"line":54,"address":[131171],"length":1,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[131680,131205,131704],"length":1,"stats":{"Line":5}},{"line":60,"address":[131235,131345,131295],"length":1,"stats":{"Line":4}},{"line":61,"address":[131332],"length":1,"stats":{"Line":1}},{"line":63,"address":[131360,131301],"length":1,"stats":{"Line":2}},{"line":69,"address":[131728],"length":1,"stats":{"Line":1}},{"line":70,"address":[131736],"length":1,"stats":{"Line":1}},{"line":80,"address":[131760],"length":1,"stats":{"Line":1}},{"line":82,"address":[131773],"length":1,"stats":{"Line":1}},{"line":86,"address":[131824,131969],"length":1,"stats":{"Line":1}},{"line":87,"address":[131885],"length":1,"stats":{"Line":1}},{"line":88,"address":[131942],"length":1,"stats":{"Line":2}},{"line":91,"address":[132000,132124],"length":1,"stats":{"Line":1}},{"line":92,"address":[132040],"length":1,"stats":{"Line":1}},{"line":93,"address":[132097],"length":1,"stats":{"Line":1}},{"line":98,"address":[132144],"length":1,"stats":{"Line":1}},{"line":99,"address":[132162,132241,132224],"length":1,"stats":{"Line":5}},{"line":102,"address":[132272],"length":1,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[132304,132794,132788],"length":1,"stats":{"Line":1}},{"line":107,"address":[132363,132464],"length":1,"stats":{"Line":2}},{"line":108,"address":[132451],"length":1,"stats":{"Line":1}},{"line":110,"address":[132377],"length":1,"stats":{"Line":1}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[132399,132840,132816],"length":1,"stats":{"Line":3}},{"line":115,"address":[132552],"length":1,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[132425,132520],"length":1,"stats":{"Line":2}},{"line":124,"address":[132880],"length":1,"stats":{"Line":1}},{"line":125,"address":[132888],"length":1,"stats":{"Line":1}},{"line":135,"address":[132912],"length":1,"stats":{"Line":1}},{"line":141,"address":[132944],"length":1,"stats":{"Line":1}},{"line":142,"address":[132961],"length":1,"stats":{"Line":3}},{"line":145,"address":[132992],"length":1,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[133024],"length":1,"stats":{"Line":1}},{"line":150,"address":[133269,133083],"length":1,"stats":{"Line":2}},{"line":151,"address":[133276],"length":1,"stats":{"Line":1}},{"line":153,"address":[133127],"length":1,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[133101],"length":1,"stats":{"Line":1}},{"line":165,"address":[133312],"length":1,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[133328],"length":1,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[133360],"length":1,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[133376],"length":1,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[133408],"length":1,"stats":{"Line":1}},{"line":187,"address":[133431],"length":1,"stats":{"Line":1}},{"line":195,"address":[2397138,2397103,2397168,2397618,2396704,2397663],"length":1,"stats":{"Line":2}},{"line":199,"address":[2397195,2397114,2396726,2397093,2397629,2397608,2396832,2397301],"length":1,"stats":{"Line":4}},{"line":203,"address":[133999,133504,133954],"length":1,"stats":{"Line":2}},{"line":207,"address":[2397829,2398157,2398136,2397723],"length":1,"stats":{"Line":4}},{"line":211,"address":[134032],"length":1,"stats":{"Line":2}},{"line":212,"address":[134033],"length":1,"stats":{"Line":2}},{"line":229,"address":[134064,134242],"length":1,"stats":{"Line":8}},{"line":230,"address":[134097],"length":1,"stats":{"Line":9}},{"line":231,"address":[134502,134724],"length":1,"stats":{"Line":16}},{"line":232,"address":[134582],"length":1,"stats":{"Line":1}},{"line":233,"address":[134171,134400],"length":1,"stats":{"Line":2}},{"line":234,"address":[134277,134214],"length":1,"stats":{"Line":2}},{"line":240,"address":[134864,135686],"length":1,"stats":{"Line":1}},{"line":241,"address":[134892],"length":1,"stats":{"Line":1}},{"line":242,"address":[135637,135575,134922,135107],"length":1,"stats":{"Line":3}},{"line":243,"address":[135220,135442],"length":1,"stats":{"Line":0}},{"line":244,"address":[135300],"length":1,"stats":{"Line":1}},{"line":245,"address":[135121,134997],"length":1,"stats":{"Line":0}},{"line":246,"address":[135037,135101],"length":1,"stats":{"Line":0}},{"line":248,"address":[135663],"length":1,"stats":{"Line":1}},{"line":251,"address":[136534,135712],"length":1,"stats":{"Line":1}},{"line":252,"address":[135740],"length":1,"stats":{"Line":1}},{"line":253,"address":[135770,135955,136423,136485],"length":1,"stats":{"Line":3}},{"line":254,"address":[136068,136290],"length":1,"stats":{"Line":0}},{"line":255,"address":[136148],"length":1,"stats":{"Line":0}},{"line":256,"address":[135845,135969],"length":1,"stats":{"Line":2}},{"line":257,"address":[135949,135885],"length":1,"stats":{"Line":0}},{"line":259,"address":[136511],"length":1,"stats":{"Line":1}},{"line":267,"address":[136560],"length":1,"stats":{"Line":1}},{"line":268,"address":[136688,136701,136579],"length":1,"stats":{"Line":12}},{"line":269,"address":[136749,136616,136736],"length":1,"stats":{"Line":11}},{"line":270,"address":[136655],"length":1,"stats":{"Line":1}},{"line":273,"address":[136784],"length":1,"stats":{"Line":1}},{"line":274,"address":[136789],"length":1,"stats":{"Line":2}},{"line":277,"address":[137707,137713,136800],"length":1,"stats":{"Line":4}},{"line":278,"address":[136843,136916],"length":1,"stats":{"Line":5}},{"line":279,"address":[136903],"length":1,"stats":{"Line":1}},{"line":281,"address":[136857],"length":1,"stats":{"Line":3}},{"line":283,"address":[136926,136873],"length":1,"stats":{"Line":6}},{"line":284,"address":[136935,137048],"length":1,"stats":{"Line":6}},{"line":286,"address":[137059],"length":1,"stats":{"Line":2}},{"line":289,"address":[136971,137283],"length":1,"stats":{"Line":4}},{"line":290,"address":[137295,137368],"length":1,"stats":{"Line":6}},{"line":292,"address":[137379],"length":1,"stats":{"Line":1}},{"line":295,"address":[137335,137611],"length":1,"stats":{"Line":5}}],"covered":97,"coverable":114},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","shared","validatable.rs"],"content":"use crate::domain::shared::errors::DomainError;\n\n/// A trait for objects that can validate themselves\npub trait Validatable {\n    /// Validate the object and return a result\n    fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e;\n\n    /// Check if the object is valid without returning an error\n    fn is_valid(\u0026self) -\u003e bool {\n        self.validate().is_ok()\n    }\n\n    /// Get validation errors as a vector of strings\n    fn validation_errors(\u0026self) -\u003e Vec\u003cString\u003e {\n        match self.validate() {\n            Ok(()) =\u003e Vec::new(),\n            Err(err) =\u003e vec![err.to_string()],\n        }\n    }\n}\n\n/// A trait for objects that can validate other objects\npub trait Validator\u003cT\u003e {\n    /// Validate the given object\n    fn validate(\u0026self, item: \u0026T) -\u003e Result\u003c(), DomainError\u003e;\n\n    /// Check if the given object is valid\n    fn is_valid(\u0026self, item: \u0026T) -\u003e bool {\n        self.validate(item).is_ok()\n    }\n\n    /// Get validation errors for the given object\n    fn validation_errors(\u0026self, item: \u0026T) -\u003e Vec\u003cString\u003e {\n        match self.validate(item) {\n            Ok(()) =\u003e Vec::new(),\n            Err(err) =\u003e vec![err.to_string()],\n        }\n    }\n}\n\n/// A composite validator that combines multiple validators\npub struct CompositeValidator\u003cT\u003e {\n    validators: Vec\u003cBox\u003cdyn Validator\u003cT\u003e\u003e\u003e,\n}\n\nimpl\u003cT\u003e CompositeValidator\u003cT\u003e {\n    pub fn new() -\u003e Self {\n        Self { validators: Vec::new() }\n    }\n\n    pub fn add(mut self, validator: Box\u003cdyn Validator\u003cT\u003e\u003e) -\u003e Self {\n        self.validators.push(validator);\n        self\n    }\n\n    pub fn add_all(mut self, validators: Vec\u003cBox\u003cdyn Validator\u003cT\u003e\u003e\u003e) -\u003e Self {\n        self.validators.extend(validators);\n        self\n    }\n}\n\nimpl\u003cT\u003e Validator\u003cT\u003e for CompositeValidator\u003cT\u003e {\n    fn validate(\u0026self, item: \u0026T) -\u003e Result\u003c(), DomainError\u003e {\n        for validator in \u0026self.validators {\n            validator.validate(item)?;\n        }\n        Ok(())\n    }\n}\n\nimpl\u003cT\u003e Default for CompositeValidator\u003cT\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// Convenience implementation for any type that implements Validatable\nimpl\u003cT: Validatable\u003e Validator\u003cT\u003e for T {\n    fn validate(\u0026self, _item: \u0026T) -\u003e Result\u003c(), DomainError\u003e {\n        self.validate()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::shared::errors::{DomainError, DomainErrorKind};\n\n    // Mock structs for testing\n    #[derive(Debug, Clone, PartialEq)]\n    struct MockValidatable {\n        name: String,\n        value: i32,\n        is_valid: bool,\n    }\n\n    impl MockValidatable {\n        fn new(name: \u0026str, value: i32, is_valid: bool) -\u003e Self {\n            Self {\n                name: name.to_string(),\n                value,\n                is_valid,\n            }\n        }\n    }\n\n    impl Validatable for MockValidatable {\n        fn validate(\u0026self) -\u003e Result\u003c(), DomainError\u003e {\n            if self.is_valid {\n                Ok(())\n            } else {\n                Err(DomainError::new(DomainErrorKind::ValidationError {\n                    field: \"validatable\".to_string(),\n                    message: format!(\"Validation failed for {}\", self.name),\n                }))\n            }\n        }\n    }\n\n    // Mock validators for testing\n    struct NameValidator;\n    struct ValueValidator;\n    struct CompositeTestValidator;\n\n    impl Validator\u003cMockValidatable\u003e for NameValidator {\n        fn validate(\u0026self, item: \u0026MockValidatable) -\u003e Result\u003c(), DomainError\u003e {\n            if item.name.is_empty() {\n                Err(DomainError::new(DomainErrorKind::ValidationError {\n                    field: \"name\".to_string(),\n                    message: \"Name cannot be empty\".to_string(),\n                }))\n            } else {\n                Ok(())\n            }\n        }\n    }\n\n    impl Validator\u003cMockValidatable\u003e for ValueValidator {\n        fn validate(\u0026self, item: \u0026MockValidatable) -\u003e Result\u003c(), DomainError\u003e {\n            if item.value \u003c 0 {\n                Err(DomainError::new(DomainErrorKind::ValidationError {\n                    field: \"value\".to_string(),\n                    message: \"Value must be non-negative\".to_string(),\n                }))\n            } else {\n                Ok(())\n            }\n        }\n    }\n\n    impl Validator\u003cMockValidatable\u003e for CompositeTestValidator {\n        fn validate(\u0026self, item: \u0026MockValidatable) -\u003e Result\u003c(), DomainError\u003e {\n            if item.name == \"invalid\" {\n                Err(DomainError::new(DomainErrorKind::ValidationError {\n                    field: \"name\".to_string(),\n                    message: \"Special invalid name\".to_string(),\n                }))\n            } else {\n                Ok(())\n            }\n        }\n    }\n\n    // Tests for Validatable trait\n    #[test]\n    fn test_validatable_validate_success() {\n        let valid_item = MockValidatable::new(\"test\", 42, true);\n        assert!(\u003cMockValidatable as Validatable\u003e::validate(\u0026valid_item).is_ok());\n    }\n\n    #[test]\n    fn test_validatable_validate_failure() {\n        let invalid_item = MockValidatable::new(\"test\", 42, false);\n        let result = \u003cMockValidatable as Validatable\u003e::validate(\u0026invalid_item);\n        assert!(result.is_err());\n        \n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Validation failed for test\"));\n        }\n    }\n\n    #[test]\n    fn test_validatable_is_valid_success() {\n        let valid_item = MockValidatable::new(\"test\", 42, true);\n        assert!(\u003cMockValidatable as Validatable\u003e::is_valid(\u0026valid_item));\n    }\n\n    #[test]\n    fn test_validatable_is_valid_failure() {\n        let invalid_item = MockValidatable::new(\"test\", 42, false);\n        assert!(!\u003cMockValidatable as Validatable\u003e::is_valid(\u0026invalid_item));\n    }\n\n    #[test]\n    fn test_validatable_validation_errors_success() {\n        let valid_item = MockValidatable::new(\"test\", 42, true);\n        let errors = \u003cMockValidatable as Validatable\u003e::validation_errors(\u0026valid_item);\n        assert!(errors.is_empty());\n    }\n\n    #[test]\n    fn test_validatable_validation_errors_failure() {\n        let invalid_item = MockValidatable::new(\"test\", 42, false);\n        let errors = \u003cMockValidatable as Validatable\u003e::validation_errors(\u0026invalid_item);\n        assert_eq!(errors.len(), 1);\n        assert!(errors[0].contains(\"Validation failed for test\"));\n    }\n\n    // Tests for Validator trait\n    #[test]\n    fn test_validator_validate_success() {\n        let validator = NameValidator;\n        let item = MockValidatable::new(\"test\", 42, true);\n        assert!(validator.validate(\u0026item).is_ok());\n    }\n\n    #[test]\n    fn test_validator_validate_failure() {\n        let validator = NameValidator;\n        let item = MockValidatable::new(\"\", 42, true);\n        let result = validator.validate(\u0026item);\n        assert!(result.is_err());\n        \n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Name cannot be empty\"));\n        }\n    }\n\n    #[test]\n    fn test_validator_is_valid_success() {\n        let validator = NameValidator;\n        let item = MockValidatable::new(\"test\", 42, true);\n        assert!(validator.is_valid(\u0026item));\n    }\n\n    #[test]\n    fn test_validator_is_valid_failure() {\n        let validator = NameValidator;\n        let item = MockValidatable::new(\"\", 42, true);\n        assert!(!validator.is_valid(\u0026item));\n    }\n\n    #[test]\n    fn test_validator_validation_errors_success() {\n        let validator = NameValidator;\n        let item = MockValidatable::new(\"test\", 42, true);\n        let errors = validator.validation_errors(\u0026item);\n        assert!(errors.is_empty());\n    }\n\n    #[test]\n    fn test_validator_validation_errors_failure() {\n        let validator = NameValidator;\n        let item = MockValidatable::new(\"\", 42, true);\n        let errors = validator.validation_errors(\u0026item);\n        assert_eq!(errors.len(), 1);\n        assert!(errors[0].contains(\"Name cannot be empty\"));\n    }\n\n    // Tests for CompositeValidator struct\n    #[test]\n    fn test_composite_validator_new() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new();\n        assert!(validator.validators.is_empty());\n    }\n\n    #[test]\n    fn test_composite_validator_default() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::default();\n        assert!(validator.validators.is_empty());\n    }\n\n    #[test]\n    fn test_composite_validator_add() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator));\n        assert_eq!(validator.validators.len(), 1);\n    }\n\n    #[test]\n    fn test_composite_validator_add_all() {\n        let validators = vec![\n            Box::new(NameValidator) as Box\u003cdyn Validator\u003cMockValidatable\u003e\u003e,\n            Box::new(ValueValidator) as Box\u003cdyn Validator\u003cMockValidatable\u003e\u003e,\n        ];\n        \n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add_all(validators);\n        assert_eq!(validator.validators.len(), 2);\n    }\n\n    #[test]\n    fn test_composite_validator_validate_success() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator))\n            .add(Box::new(ValueValidator));\n        \n        let item = MockValidatable::new(\"test\", 42, true);\n        assert!(validator.validate(\u0026item).is_ok());\n    }\n\n    #[test]\n    fn test_composite_validator_validate_first_failure() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator))\n            .add(Box::new(ValueValidator));\n        \n        let item = MockValidatable::new(\"\", 42, true);\n        let result = validator.validate(\u0026item);\n        assert!(result.is_err());\n        \n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Name cannot be empty\"));\n        }\n    }\n\n    #[test]\n    fn test_composite_validator_validate_second_failure() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator))\n            .add(Box::new(ValueValidator));\n        \n        let item = MockValidatable::new(\"test\", -1, true);\n        let result = validator.validate(\u0026item);\n        assert!(result.is_err());\n        \n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Value must be non-negative\"));\n        }\n    }\n\n    #[test]\n    fn test_composite_validator_validate_multiple_failures() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator))\n            .add(Box::new(ValueValidator));\n        \n        let item = MockValidatable::new(\"\", -1, true);\n        let result = validator.validate(\u0026item);\n        assert!(result.is_err());\n        \n        // Should fail on first validation error (NameValidator)\n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Name cannot be empty\"));\n        }\n    }\n\n    #[test]\n    fn test_composite_validator_is_valid_success() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator))\n            .add(Box::new(ValueValidator));\n        \n        let item = MockValidatable::new(\"test\", 42, true);\n        assert!(validator.is_valid(\u0026item));\n    }\n\n    #[test]\n    fn test_composite_validator_is_valid_failure() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator))\n            .add(Box::new(ValueValidator));\n        \n        let item = MockValidatable::new(\"\", 42, true);\n        assert!(!validator.is_valid(\u0026item));\n    }\n\n    #[test]\n    fn test_composite_validator_validation_errors_success() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator))\n            .add(Box::new(ValueValidator));\n        \n        let item = MockValidatable::new(\"test\", 42, true);\n        let errors = validator.validation_errors(\u0026item);\n        assert!(errors.is_empty());\n    }\n\n    #[test]\n    fn test_composite_validator_validation_errors_failure() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator))\n            .add(Box::new(ValueValidator));\n        \n        let item = MockValidatable::new(\"\", 42, true);\n        let errors = validator.validation_errors(\u0026item);\n        assert_eq!(errors.len(), 1);\n        assert!(errors[0].contains(\"Name cannot be empty\"));\n    }\n\n    #[test]\n    fn test_composite_validator_empty() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new();\n        let item = MockValidatable::new(\"test\", 42, true);\n        assert!(validator.validate(\u0026item).is_ok());\n        assert!(validator.is_valid(\u0026item));\n        assert!(validator.validation_errors(\u0026item).is_empty());\n    }\n\n    // Tests for convenience implementation\n    #[test]\n    fn test_validatable_as_validator() {\n        let item = MockValidatable::new(\"test\", 42, true);\n        let validator: \u0026dyn Validator\u003cMockValidatable\u003e = \u0026item;\n        \n        assert!(validator.validate(\u0026item).is_ok());\n        assert!(validator.is_valid(\u0026item));\n        assert!(validator.validation_errors(\u0026item).is_empty());\n    }\n\n    #[test]\n    fn test_validatable_as_validator_failure() {\n        let item = MockValidatable::new(\"test\", 42, false);\n        let validator: \u0026dyn Validator\u003cMockValidatable\u003e = \u0026item;\n        \n        let result = validator.validate(\u0026item);\n        assert!(result.is_err());\n        assert!(!validator.is_valid(\u0026item));\n        \n        let errors = validator.validation_errors(\u0026item);\n        assert_eq!(errors.len(), 1);\n        assert!(errors[0].contains(\"Validation failed for test\"));\n    }\n\n    // Tests for complex validation scenarios\n    #[test]\n    fn test_composite_validator_builder_pattern() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator))\n            .add(Box::new(ValueValidator))\n            .add(Box::new(CompositeTestValidator));\n        \n        assert_eq!(validator.validators.len(), 3);\n        \n        let valid_item = MockValidatable::new(\"test\", 42, true);\n        assert!(validator.validate(\u0026valid_item).is_ok());\n        \n        let invalid_name_item = MockValidatable::new(\"invalid\", 42, true);\n        let result = validator.validate(\u0026invalid_name_item);\n        assert!(result.is_err());\n        \n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Special invalid name\"));\n        }\n    }\n\n    #[test]\n    fn test_validator_trait_objects() {\n        let validators: Vec\u003cBox\u003cdyn Validator\u003cMockValidatable\u003e\u003e\u003e = vec![\n            Box::new(NameValidator),\n            Box::new(ValueValidator),\n        ];\n        \n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add_all(validators);\n        \n        let item = MockValidatable::new(\"test\", 42, true);\n        assert!(validator.validate(\u0026item).is_ok());\n    }\n\n    #[test]\n    fn test_validation_error_propagation() {\n        let validator = CompositeValidator::\u003cMockValidatable\u003e::new()\n            .add(Box::new(NameValidator))\n            .add(Box::new(ValueValidator));\n        \n        let item = MockValidatable::new(\"\", -1, true);\n        let result = validator.validate(\u0026item);\n        assert!(result.is_err());\n        \n        // Should fail on first validation error and not continue\n        if let Err(err) = result {\n            assert!(err.to_string().contains(\"Name cannot be empty\"));\n            assert!(!err.to_string().contains(\"Value must be non-negative\"));\n        }\n    }\n}\n","traces":[{"line":9,"address":[2188569,2188464,2188563],"length":1,"stats":{"Line":1}},{"line":10,"address":[2188488],"length":1,"stats":{"Line":1}},{"line":14,"address":[2189048,2188592,2189059],"length":1,"stats":{"Line":2}},{"line":15,"address":[2188617],"length":1,"stats":{"Line":2}},{"line":16,"address":[2188757],"length":1,"stats":{"Line":1}},{"line":17,"address":[2189054,2188784,2188652],"length":1,"stats":{"Line":1}},{"line":28,"address":[2189625,2189331,2189193,2189337,2189187,2189475,2189481,2189504,2189360,2189216,2189072,2189619],"length":1,"stats":{"Line":5}},{"line":29,"address":[2189540,2189396,2189108,2189252],"length":1,"stats":{"Line":7}},{"line":33,"address":[2190112,2191600,2190123,2191611,2190619,2191136,2189648,2190144,2190640,2191104,2191115,2190608],"length":1,"stats":{"Line":6}},{"line":34,"address":[2189681,2191169,2190177,2190673],"length":1,"stats":{"Line":6}},{"line":35,"address":[2190813,2191309,2189821,2190317],"length":1,"stats":{"Line":3}},{"line":36,"address":[2191606,2190708,2190118,2191336,2190344,2191110,2189848,2190212,2189716,2190614,2190840,2191204],"length":1,"stats":{"Line":3}},{"line":47,"address":[2198144],"length":1,"stats":{"Line":1}},{"line":48,"address":[2198157],"length":1,"stats":{"Line":2}},{"line":51,"address":[2198208,2198353],"length":1,"stats":{"Line":2}},{"line":52,"address":[2198269],"length":1,"stats":{"Line":2}},{"line":53,"address":[2198326],"length":1,"stats":{"Line":2}},{"line":56,"address":[2198508,2198384],"length":1,"stats":{"Line":1}},{"line":57,"address":[2198424],"length":1,"stats":{"Line":1}},{"line":58,"address":[2198481],"length":1,"stats":{"Line":1}},{"line":63,"address":[2198528],"length":1,"stats":{"Line":1}},{"line":64,"address":[2198593,2198578],"length":1,"stats":{"Line":2}},{"line":65,"address":[2198741,2198653],"length":1,"stats":{"Line":3}},{"line":67,"address":[2198721],"length":1,"stats":{"Line":1}},{"line":72,"address":[2198800],"length":1,"stats":{"Line":1}},{"line":73,"address":[2198808],"length":1,"stats":{"Line":1}},{"line":79,"address":[2191632],"length":1,"stats":{"Line":1}},{"line":80,"address":[2191653],"length":1,"stats":{"Line":2}}],"covered":28,"coverable":28},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","task_management","any_task.rs"],"content":"use super::{\n    state::{Blocked, Cancelled, Completed, InProgress, Planned},\n    task::Task,\n};\nuse chrono::NaiveDate;\nuse serde::Serialize;\nuse uuid7::Uuid;\n\n/// An enum to represent a Task in any of its possible states.\n/// This is useful for storing tasks in a repository or a collection\n/// where the exact state is not known at compile time.\n#[derive(Debug, Clone, Serialize, PartialEq)]\n#[serde(tag = \"status\")] // This will serialize the enum with a \"status\" field identifying the variant.\npub enum AnyTask {\n    Planned(Task\u003cPlanned\u003e),\n    InProgress(Task\u003cInProgress\u003e),\n    Blocked(Task\u003cBlocked\u003e),\n    Completed(Task\u003cCompleted\u003e),\n    Cancelled(Task\u003cCancelled\u003e),\n}\n\n// Implement helper methods on AnyTask to access common Task fields.\n// This avoids repetitive match statements in other parts of the code.\nimpl AnyTask {\n    pub fn code(\u0026self) -\u003e \u0026str {\n        match self {\n            AnyTask::Planned(task) =\u003e \u0026task.code,\n            AnyTask::InProgress(task) =\u003e \u0026task.code,\n            AnyTask::Blocked(task) =\u003e \u0026task.code,\n            AnyTask::Completed(task) =\u003e \u0026task.code,\n            AnyTask::Cancelled(task) =\u003e \u0026task.code,\n        }\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026str {\n        match self {\n            AnyTask::Planned(task) =\u003e \u0026task.name,\n            AnyTask::InProgress(task) =\u003e \u0026task.name,\n            AnyTask::Blocked(task) =\u003e \u0026task.name,\n            AnyTask::Completed(task) =\u003e \u0026task.name,\n            AnyTask::Cancelled(task) =\u003e \u0026task.name,\n        }\n    }\n\n    pub fn status(\u0026self) -\u003e \u0026str {\n        match self {\n            AnyTask::Planned(_) =\u003e \"Planned\",\n            AnyTask::InProgress(_) =\u003e \"InProgress\",\n            AnyTask::Blocked(_) =\u003e \"Blocked\",\n            AnyTask::Completed(_) =\u003e \"Completed\",\n            AnyTask::Cancelled(_) =\u003e \"Cancelled\",\n        }\n    }\n\n    pub fn project_code(\u0026self) -\u003e \u0026str {\n        match self {\n            AnyTask::Planned(task) =\u003e \u0026task.project_code,\n            AnyTask::InProgress(task) =\u003e \u0026task.project_code,\n            AnyTask::Blocked(task) =\u003e \u0026task.project_code,\n            AnyTask::Completed(task) =\u003e \u0026task.project_code,\n            AnyTask::Cancelled(task) =\u003e \u0026task.project_code,\n        }\n    }\n\n    pub fn assigned_resources(\u0026self) -\u003e \u0026[String] {\n        // Zero-copy: retorna slice em vez de referência a Vec\n        match self {\n            AnyTask::Planned(task) =\u003e task.assigned_resources.as_slice(),\n            AnyTask::InProgress(task) =\u003e task.assigned_resources.as_slice(),\n            AnyTask::Blocked(task) =\u003e task.assigned_resources.as_slice(),\n            AnyTask::Completed(task) =\u003e task.assigned_resources.as_slice(),\n            AnyTask::Cancelled(task) =\u003e task.assigned_resources.as_slice(),\n        }\n    }\n\n    // Adiciona método para iterador zero-copy\n    pub fn assigned_resources_iter(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        match self {\n            AnyTask::Planned(task) =\u003e task.assigned_resources.iter(),\n            AnyTask::InProgress(task) =\u003e task.assigned_resources.iter(),\n            AnyTask::Blocked(task) =\u003e task.assigned_resources.iter(),\n            AnyTask::Completed(task) =\u003e task.assigned_resources.iter(),\n            AnyTask::Cancelled(task) =\u003e task.assigned_resources.iter(),\n        }\n    }\n\n    pub fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        // Zero-copy: retorna \u0026str em vez de \u0026String\n        match self {\n            AnyTask::Planned(t) =\u003e t.description.as_deref(),\n            AnyTask::InProgress(t) =\u003e t.description.as_deref(),\n            AnyTask::Blocked(t) =\u003e t.description.as_deref(),\n            AnyTask::Completed(t) =\u003e t.description.as_deref(),\n            AnyTask::Cancelled(t) =\u003e t.description.as_deref(),\n        }\n    }\n\n    pub fn start_date(\u0026self) -\u003e \u0026NaiveDate {\n        match self {\n            AnyTask::Planned(t) =\u003e \u0026t.start_date,\n            AnyTask::InProgress(t) =\u003e \u0026t.start_date,\n            AnyTask::Blocked(t) =\u003e \u0026t.start_date,\n            AnyTask::Completed(t) =\u003e \u0026t.start_date,\n            AnyTask::Cancelled(t) =\u003e \u0026t.start_date,\n        }\n    }\n\n    pub fn due_date(\u0026self) -\u003e \u0026NaiveDate {\n        match self {\n            AnyTask::Planned(t) =\u003e \u0026t.due_date,\n            AnyTask::InProgress(t) =\u003e \u0026t.due_date,\n            AnyTask::Blocked(t) =\u003e \u0026t.due_date,\n            AnyTask::Completed(t) =\u003e \u0026t.due_date,\n            AnyTask::Cancelled(t) =\u003e \u0026t.due_date,\n        }\n    }\n\n    // --- Zero-copy accessors ---\n\n    // Nota: Task não tem campos estimated_hours e actual_hours\n    // Esses campos foram removidos na refatoração anterior\n    // Os métodos foram removidos para manter consistência\n\n    pub fn dependencies_iter(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        match self {\n            AnyTask::Planned(t) =\u003e t.dependencies.iter(),\n            AnyTask::InProgress(t) =\u003e t.dependencies.iter(),\n            AnyTask::Blocked(t) =\u003e t.dependencies.iter(),\n            AnyTask::Completed(t) =\u003e t.dependencies.iter(),\n            AnyTask::Cancelled(t) =\u003e t.dependencies.iter(),\n        }\n    }\n\n    pub fn dependencies(\u0026self) -\u003e \u0026[String] {\n        match self {\n            AnyTask::Planned(t) =\u003e t.dependencies.as_slice(),\n            AnyTask::InProgress(t) =\u003e t.dependencies.as_slice(),\n            AnyTask::Blocked(t) =\u003e t.dependencies.as_slice(),\n            AnyTask::Completed(t) =\u003e t.dependencies.as_slice(),\n            AnyTask::Cancelled(t) =\u003e t.dependencies.as_slice(),\n        }\n    }\n}\n\n// Provide From implementations to easily convert a specific Task\u003cState\u003e into an AnyTask.\nimpl From\u003cTask\u003cPlanned\u003e\u003e for AnyTask {\n    fn from(task: Task\u003cPlanned\u003e) -\u003e Self {\n        AnyTask::Planned(task)\n    }\n}\n\nimpl From\u003cTask\u003cInProgress\u003e\u003e for AnyTask {\n    fn from(task: Task\u003cInProgress\u003e) -\u003e Self {\n        AnyTask::InProgress(task)\n    }\n}\n\nimpl From\u003cTask\u003cBlocked\u003e\u003e for AnyTask {\n    fn from(task: Task\u003cBlocked\u003e) -\u003e Self {\n        AnyTask::Blocked(task)\n    }\n}\n\nimpl From\u003cTask\u003cCompleted\u003e\u003e for AnyTask {\n    fn from(task: Task\u003cCompleted\u003e) -\u003e Self {\n        AnyTask::Completed(task)\n    }\n}\n\nimpl From\u003cTask\u003cCancelled\u003e\u003e for AnyTask {\n    fn from(task: Task\u003cCancelled\u003e) -\u003e Self {\n        AnyTask::Cancelled(task)\n    }\n}\n","traces":[{"line":25,"address":[3107280],"length":1,"stats":{"Line":3}},{"line":26,"address":[3107294,3107526],"length":1,"stats":{"Line":6}},{"line":27,"address":[3107359],"length":1,"stats":{"Line":3}},{"line":28,"address":[3107397],"length":1,"stats":{"Line":1}},{"line":29,"address":[3107432],"length":1,"stats":{"Line":1}},{"line":30,"address":[3107463],"length":1,"stats":{"Line":1}},{"line":31,"address":[3107498],"length":1,"stats":{"Line":1}},{"line":35,"address":[3107552],"length":1,"stats":{"Line":1}},{"line":36,"address":[3107566,3107798],"length":1,"stats":{"Line":2}},{"line":37,"address":[3107631],"length":1,"stats":{"Line":1}},{"line":38,"address":[3107669],"length":1,"stats":{"Line":0}},{"line":39,"address":[3107704],"length":1,"stats":{"Line":0}},{"line":40,"address":[3107735],"length":1,"stats":{"Line":0}},{"line":41,"address":[3107770],"length":1,"stats":{"Line":0}},{"line":45,"address":[3107824],"length":1,"stats":{"Line":1}},{"line":46,"address":[3107829],"length":1,"stats":{"Line":1}},{"line":47,"address":[3107889],"length":1,"stats":{"Line":0}},{"line":48,"address":[3107912],"length":1,"stats":{"Line":0}},{"line":49,"address":[3107935],"length":1,"stats":{"Line":0}},{"line":50,"address":[3107958],"length":1,"stats":{"Line":0}},{"line":51,"address":[3107981],"length":1,"stats":{"Line":1}},{"line":55,"address":[3108016],"length":1,"stats":{"Line":1}},{"line":56,"address":[3108239,3108030],"length":1,"stats":{"Line":4}},{"line":57,"address":[3108095],"length":1,"stats":{"Line":2}},{"line":58,"address":[3108126],"length":1,"stats":{"Line":0}},{"line":59,"address":[3108157],"length":1,"stats":{"Line":0}},{"line":60,"address":[3108184],"length":1,"stats":{"Line":0}},{"line":61,"address":[3108215],"length":1,"stats":{"Line":0}},{"line":65,"address":[3108256],"length":1,"stats":{"Line":1}},{"line":67,"address":[3108270,3108507],"length":1,"stats":{"Line":2}},{"line":68,"address":[3108335],"length":1,"stats":{"Line":1}},{"line":69,"address":[3108374],"length":1,"stats":{"Line":0}},{"line":70,"address":[3108410],"length":1,"stats":{"Line":0}},{"line":71,"address":[3108442],"length":1,"stats":{"Line":0}},{"line":72,"address":[3108478],"length":1,"stats":{"Line":0}},{"line":77,"address":[3108528],"length":1,"stats":{"Line":0}},{"line":78,"address":[3108542],"length":1,"stats":{"Line":0}},{"line":79,"address":[3108607],"length":1,"stats":{"Line":0}},{"line":80,"address":[3108658],"length":1,"stats":{"Line":0}},{"line":81,"address":[3108709],"length":1,"stats":{"Line":0}},{"line":82,"address":[3108753],"length":1,"stats":{"Line":0}},{"line":83,"address":[3108801],"length":1,"stats":{"Line":0}},{"line":87,"address":[3108864],"length":1,"stats":{"Line":1}},{"line":89,"address":[3108878],"length":1,"stats":{"Line":1}},{"line":90,"address":[3108943],"length":1,"stats":{"Line":1}},{"line":91,"address":[3108982],"length":1,"stats":{"Line":0}},{"line":92,"address":[3109018],"length":1,"stats":{"Line":0}},{"line":93,"address":[3109053],"length":1,"stats":{"Line":0}},{"line":94,"address":[3109089],"length":1,"stats":{"Line":0}},{"line":98,"address":[3109136],"length":1,"stats":{"Line":1}},{"line":99,"address":[3109146,3109335],"length":1,"stats":{"Line":2}},{"line":100,"address":[3109211],"length":1,"stats":{"Line":1}},{"line":101,"address":[3109238],"length":1,"stats":{"Line":0}},{"line":102,"address":[3109265],"length":1,"stats":{"Line":0}},{"line":103,"address":[3109288],"length":1,"stats":{"Line":0}},{"line":104,"address":[3109315],"length":1,"stats":{"Line":0}},{"line":108,"address":[3109344],"length":1,"stats":{"Line":1}},{"line":109,"address":[3109354,3109543],"length":1,"stats":{"Line":2}},{"line":110,"address":[3109419],"length":1,"stats":{"Line":1}},{"line":111,"address":[3109446],"length":1,"stats":{"Line":0}},{"line":112,"address":[3109473],"length":1,"stats":{"Line":0}},{"line":113,"address":[3109496],"length":1,"stats":{"Line":0}},{"line":114,"address":[3109523],"length":1,"stats":{"Line":0}},{"line":124,"address":[3109552],"length":1,"stats":{"Line":0}},{"line":125,"address":[3109566],"length":1,"stats":{"Line":0}},{"line":126,"address":[3109631],"length":1,"stats":{"Line":0}},{"line":127,"address":[3109682],"length":1,"stats":{"Line":0}},{"line":128,"address":[3109733],"length":1,"stats":{"Line":0}},{"line":129,"address":[3109777],"length":1,"stats":{"Line":0}},{"line":130,"address":[3109825],"length":1,"stats":{"Line":0}},{"line":134,"address":[3109888],"length":1,"stats":{"Line":0}},{"line":135,"address":[3110139,3109902],"length":1,"stats":{"Line":0}},{"line":136,"address":[3109967],"length":1,"stats":{"Line":0}},{"line":137,"address":[3110006],"length":1,"stats":{"Line":0}},{"line":138,"address":[3110042],"length":1,"stats":{"Line":0}},{"line":139,"address":[3110074],"length":1,"stats":{"Line":0}},{"line":140,"address":[3110110],"length":1,"stats":{"Line":0}},{"line":147,"address":[3110160],"length":1,"stats":{"Line":1}},{"line":148,"address":[3110177],"length":1,"stats":{"Line":1}},{"line":153,"address":[3110224],"length":1,"stats":{"Line":1}},{"line":154,"address":[3110241],"length":1,"stats":{"Line":1}},{"line":159,"address":[3110288],"length":1,"stats":{"Line":1}},{"line":160,"address":[3110296],"length":1,"stats":{"Line":1}},{"line":165,"address":[3110320],"length":1,"stats":{"Line":1}},{"line":166,"address":[3110337],"length":1,"stats":{"Line":1}},{"line":171,"address":[3110384],"length":1,"stats":{"Line":1}},{"line":172,"address":[3110401],"length":1,"stats":{"Line":1}}],"covered":38,"coverable":87},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","task_management","builder.rs"],"content":"use super::state::Planned;\nuse super::task::{Task, TaskError};\nuse chrono::NaiveDate;\nuse std::marker::PhantomData;\nuse uuid7::{Uuid, uuid7};\n\n// Type states for the builder\n#[allow(dead_code)]\npub struct New;\n#[allow(dead_code)]\npub struct WithProjectCode;\n#[allow(dead_code)]\npub struct WithName;\n#[allow(dead_code)]\npub struct WithDates;\n#[allow(dead_code)]\npub struct Ready;\n\n/// A builder for creating `Task` instances in a controlled way, ensuring all\n/// required fields are provided before a task can be built.\n/// It uses the typestate pattern to enforce the order of method calls at compile time.\n#[allow(dead_code)]\npub struct TaskBuilder\u003cState\u003e {\n    id: Uuid,\n    project_code: Option\u003cString\u003e,\n    code: Option\u003cString\u003e,\n    name: Option\u003cString\u003e,\n    start_date: Option\u003cNaiveDate\u003e,\n    due_date: Option\u003cNaiveDate\u003e,\n    assigned_resources: Vec\u003cString\u003e,\n    _state: PhantomData\u003cState\u003e,\n}\n\n#[allow(dead_code)]\nimpl TaskBuilder\u003cNew\u003e {\n    /// Starts building a new task.\n    pub fn new() -\u003e Self {\n        Self {\n            id: uuid7(),\n            project_code: None,\n            code: None,\n            name: None,\n            start_date: None,\n            due_date: None,\n            assigned_resources: Vec::new(),\n            _state: PhantomData,\n        }\n    }\n\n    /// Sets the project code for the task.\n    pub fn project_code(self, project_code: impl Into\u003cString\u003e) -\u003e TaskBuilder\u003cWithProjectCode\u003e {\n        TaskBuilder {\n            id: self.id,\n            code: self.code,\n            project_code: Some(project_code.into()),\n            name: self.name,\n            start_date: self.start_date,\n            due_date: self.due_date,\n            assigned_resources: self.assigned_resources,\n            _state: PhantomData,\n        }\n    }\n}\n\nimpl Default for TaskBuilder\u003cNew\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[allow(dead_code)]\nimpl TaskBuilder\u003cWithProjectCode\u003e {\n    /// Sets the name for the task.\n    pub fn name(self, name: impl Into\u003cString\u003e) -\u003e TaskBuilder\u003cWithName\u003e {\n        TaskBuilder {\n            id: self.id,\n            code: self.code,\n            project_code: self.project_code,\n            name: Some(name.into()),\n            start_date: self.start_date,\n            due_date: self.due_date,\n            assigned_resources: self.assigned_resources,\n            _state: PhantomData,\n        }\n    }\n}\n\n#[allow(dead_code)]\nimpl TaskBuilder\u003cWithName\u003e {\n    /// Sets the code for the task.\n    pub fn code(mut self, code: impl Into\u003cString\u003e) -\u003e Self {\n        self.code = Some(code.into());\n        self\n    }\n\n    /// Sets the start and due dates for the task, validating that the range is valid.\n    pub fn dates(self, start: NaiveDate, due: NaiveDate) -\u003e Result\u003cTaskBuilder\u003cWithDates\u003e, TaskError\u003e {\n        if start \u003e due {\n            return Err(TaskError::InvalidDateRange);\n        }\n\n        Ok(TaskBuilder {\n            id: self.id,\n            code: self.code,\n            project_code: self.project_code,\n            name: self.name,\n            start_date: Some(start),\n            due_date: Some(due),\n            assigned_resources: self.assigned_resources,\n            _state: PhantomData,\n        })\n    }\n}\n\n#[allow(dead_code)]\nimpl TaskBuilder\u003cWithDates\u003e {\n    /// Assigns a resource to the task. Can be called multiple times.\n    pub fn assign_resource(mut self, resource_id: impl Into\u003cString\u003e) -\u003e Self {\n        self.assigned_resources.push(resource_id.into());\n        self\n    }\n\n    /// Validates that no assigned resources are on vacation during the task's date range.\n    /// This moves the builder to the final `Ready` state.\n    pub fn validate_vacations(\n        self,\n        resource_vacations: \u0026[(String, NaiveDate, NaiveDate)],\n    ) -\u003e Result\u003cTaskBuilder\u003cReady\u003e, TaskError\u003e {\n        let start = self.start_date.unwrap();\n        let due = self.due_date.unwrap();\n\n        for res in \u0026self.assigned_resources {\n            for (vac_res, vac_start, vac_end) in resource_vacations {\n                if res == vac_res \u0026\u0026 start \u003c= *vac_end \u0026\u0026 due \u003e= *vac_start {\n                    return Err(TaskError::ResourceOnVacation(res.clone()));\n                }\n            }\n        }\n\n        Ok(TaskBuilder {\n            id: self.id,\n            code: self.code,\n            project_code: self.project_code,\n            name: self.name,\n            start_date: self.start_date,\n            due_date: self.due_date,\n            assigned_resources: self.assigned_resources,\n            _state: PhantomData,\n        })\n    }\n}\n\n#[allow(dead_code)]\nimpl TaskBuilder\u003cReady\u003e {\n    /// Builds the final `Task\u003cPlanned\u003e` instance.\n    pub fn build(self) -\u003e Result\u003cTask\u003cPlanned\u003e, TaskError\u003e {\n        Ok(Task {\n            id: self.id,\n            project_code: self\n                .project_code\n                .ok_or(TaskError::MissingField(\"project_code\".to_string()))?,\n            code: self.code.ok_or(TaskError::MissingField(\"code\".to_string()))?,\n            name: self.name.ok_or(TaskError::MissingField(\"name\".to_string()))?,\n            description: None,\n            state: Planned, // The task starts in the 'Planned' state.\n            start_date: self.start_date.unwrap(),\n            due_date: self.due_date.unwrap(),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: self.assigned_resources,\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::NaiveDate;\n\n    #[test]\n    fn test_successful_task_creation() {\n        let task = TaskBuilder::new()\n            .project_code(\"PROJ-TEST\")\n            .name(\"Test Task\")\n            .code(\"task-1\".to_string())\n            .dates(\n                NaiveDate::from_ymd_opt(2025, 5, 1).unwrap(),\n                NaiveDate::from_ymd_opt(2025, 5, 10).unwrap(),\n            )\n            .unwrap()\n            .assign_resource(\"RES-001\")\n            .validate_vacations(\u0026[])\n            .unwrap()\n            .build()\n            .unwrap();\n\n        assert_eq!(task.project_code, \"PROJ-TEST\");\n        assert_eq!(task.name, \"Test Task\");\n        assert_eq!(task.assigned_resources, vec![\"RES-001\".to_string()]);\n        assert_eq!(task.start_date, NaiveDate::from_ymd_opt(2025, 5, 1).unwrap());\n        assert_eq!(task.due_date, NaiveDate::from_ymd_opt(2025, 5, 10).unwrap());\n        assert_eq!(task.code, \"task-1\");\n        // The state is `Planned` by type, no need for a runtime assertion.\n    }\n\n    #[test]\n    fn test_invalid_date_range() {\n        let result = TaskBuilder::new()\n            .project_code(\"PROJ-TEST\")\n            .name(\"Task com datas invertidas\")\n            .code(\"task-2\".to_string())\n            .dates(\n                NaiveDate::from_ymd_opt(2025, 5, 10).unwrap(),\n                NaiveDate::from_ymd_opt(2025, 5, 1).unwrap(),\n            );\n\n        assert!(matches!(result, Err(TaskError::InvalidDateRange)));\n    }\n\n    #[test]\n    fn test_resource_on_vacation() {\n        let vacations = vec![(\n            \"RES-002\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 5, 5).unwrap(),\n            NaiveDate::from_ymd_opt(2025, 5, 7).unwrap(),\n        )];\n\n        let result = TaskBuilder::new()\n            .project_code(\"PROJ-TEST\")\n            .name(\"Task com conflito de férias\")\n            .code(\"task-3\".to_string())\n            .dates(\n                NaiveDate::from_ymd_opt(2025, 5, 1).unwrap(),\n                NaiveDate::from_ymd_opt(2025, 5, 10).unwrap(),\n            )\n            .unwrap()\n            .assign_resource(\"RES-002\")\n            .validate_vacations(\u0026vacations);\n\n        assert!(matches!(result, Err(TaskError::ResourceOnVacation(res)) if res == \"RES-002\"));\n    }\n\n    #[test]\n    fn test_multiple_resources_and_no_vacation_conflict() {\n        let vacations = vec![(\n            \"RES-003\".to_string(),\n            NaiveDate::from_ymd_opt(2025, 5, 15).unwrap(),\n            NaiveDate::from_ymd_opt(2025, 5, 20).unwrap(),\n        )];\n\n        let task = TaskBuilder::new()\n            .project_code(\"PROJ-TEST\")\n            .name(\"Task multi recursos\")\n            .code(\"task-4\".to_string())\n            .dates(\n                NaiveDate::from_ymd_opt(2025, 5, 1).unwrap(),\n                NaiveDate::from_ymd_opt(2025, 5, 10).unwrap(),\n            )\n            .unwrap()\n            .assign_resource(\"RES-003\")\n            .assign_resource(\"RES-004\")\n            .validate_vacations(\u0026vacations)\n            .unwrap()\n            .build()\n            .unwrap();\n\n        assert_eq!(\n            task.assigned_resources,\n            vec![\"RES-003\".to_string(), \"RES-004\".to_string()]\n        );\n    }\n}\n","traces":[{"line":37,"address":[1917248,1917573,1917535],"length":1,"stats":{"Line":1}},{"line":39,"address":[1917264],"length":1,"stats":{"Line":1}},{"line":45,"address":[1917319],"length":1,"stats":{"Line":1}},{"line":51,"address":[1835440,1835351,1834944,1835413,1835949,1835887],"length":1,"stats":{"Line":2}},{"line":53,"address":[1834977,1835504],"length":1,"stats":{"Line":2}},{"line":54,"address":[1835513,1834986],"length":1,"stats":{"Line":3}},{"line":55,"address":[1835004,1835531,1835078,1835605],"length":1,"stats":{"Line":8}},{"line":56,"address":[1835108,1835638],"length":1,"stats":{"Line":5}},{"line":57,"address":[1835141,1835674],"length":1,"stats":{"Line":7}},{"line":58,"address":[1835677,1835144],"length":1,"stats":{"Line":6}},{"line":59,"address":[1835680,1835147],"length":1,"stats":{"Line":6}},{"line":66,"address":[1917600],"length":1,"stats":{"Line":0}},{"line":67,"address":[1917608],"length":1,"stats":{"Line":0}},{"line":74,"address":[1836415,1836900,1836958,1836496,1835968,1836473],"length":1,"stats":{"Line":6}},{"line":76,"address":[1836529,1836032],"length":1,"stats":{"Line":6}},{"line":77,"address":[1836538,1836041],"length":1,"stats":{"Line":6}},{"line":78,"address":[1836059,1836556],"length":1,"stats":{"Line":7}},{"line":79,"address":[1836574,1836077,1836154,1836651],"length":1,"stats":{"Line":11}},{"line":80,"address":[1836693,1836202],"length":1,"stats":{"Line":6}},{"line":81,"address":[1836696,1836205],"length":1,"stats":{"Line":6}},{"line":82,"address":[1836208,1836699],"length":1,"stats":{"Line":6}},{"line":91,"address":[1836976,1837207],"length":1,"stats":{"Line":1}},{"line":92,"address":[1837006,1837065],"length":1,"stats":{"Line":3}},{"line":93,"address":[1837187],"length":1,"stats":{"Line":2}},{"line":97,"address":[1917632,1918267],"length":1,"stats":{"Line":2}},{"line":98,"address":[1917726,1917661],"length":1,"stats":{"Line":3}},{"line":99,"address":[1918191],"length":1,"stats":{"Line":1}},{"line":102,"address":[1917934],"length":1,"stats":{"Line":3}},{"line":103,"address":[1917745],"length":1,"stats":{"Line":1}},{"line":104,"address":[1917769],"length":1,"stats":{"Line":2}},{"line":105,"address":[1917805],"length":1,"stats":{"Line":1}},{"line":106,"address":[1917841],"length":1,"stats":{"Line":2}},{"line":107,"address":[1917877],"length":1,"stats":{"Line":1}},{"line":108,"address":[1917888],"length":1,"stats":{"Line":2}},{"line":109,"address":[1917899],"length":1,"stats":{"Line":2}},{"line":118,"address":[1837371,1837556,1837232,1837392],"length":1,"stats":{"Line":3}},{"line":119,"address":[1837262,1837503,1837447,1837318],"length":1,"stats":{"Line":6}},{"line":120,"address":[1837536,1837351],"length":1,"stats":{"Line":3}},{"line":125,"address":[1919541,1918288],"length":1,"stats":{"Line":2}},{"line":129,"address":[1918339,1918416],"length":1,"stats":{"Line":4}},{"line":130,"address":[1918423],"length":1,"stats":{"Line":2}},{"line":132,"address":[1918464],"length":1,"stats":{"Line":2}},{"line":133,"address":[1918605,1919090],"length":1,"stats":{"Line":4}},{"line":134,"address":[1919240],"length":1,"stats":{"Line":2}},{"line":135,"address":[1919366],"length":1,"stats":{"Line":1}},{"line":140,"address":[1918808],"length":1,"stats":{"Line":2}},{"line":141,"address":[1918635],"length":1,"stats":{"Line":2}},{"line":142,"address":[1918659],"length":1,"stats":{"Line":2}},{"line":143,"address":[1918695],"length":1,"stats":{"Line":2}},{"line":144,"address":[1918731],"length":1,"stats":{"Line":2}},{"line":145,"address":[1918767],"length":1,"stats":{"Line":2}},{"line":146,"address":[1918770],"length":1,"stats":{"Line":2}},{"line":147,"address":[1918773],"length":1,"stats":{"Line":1}},{"line":156,"address":[1921925,1921496,1919568],"length":1,"stats":{"Line":1}},{"line":157,"address":[1919590,1921156],"length":1,"stats":{"Line":4}},{"line":158,"address":[1919662],"length":1,"stats":{"Line":1}},{"line":159,"address":[1919998,1921763,1919674,1919822,1919885,1919933],"length":1,"stats":{"Line":7}},{"line":161,"address":[1921938,1919854,1919706,1919966],"length":1,"stats":{"Line":2}},{"line":162,"address":[1920092,1921741,1920362],"length":1,"stats":{"Line":3}},{"line":163,"address":[1920521,1921656,1920791],"length":1,"stats":{"Line":3}},{"line":164,"address":[1920960],"length":1,"stats":{"Line":2}},{"line":166,"address":[1920968],"length":1,"stats":{"Line":1}},{"line":167,"address":[1921042],"length":1,"stats":{"Line":2}},{"line":168,"address":[1921066],"length":1,"stats":{"Line":1}},{"line":169,"address":[1921077],"length":1,"stats":{"Line":2}},{"line":170,"address":[1921113],"length":1,"stats":{"Line":1}}],"covered":64,"coverable":66},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","task_management","errors.rs"],"content":"use crate::domain::shared::errors::{DomainError, DomainErrorKind};\nuse std::error::Error as StdError;\nuse std::fmt;\n\n/// Task-specific error types\n#[derive(Debug)]\npub enum TaskError {\n    NotFound { code: String },\n    AlreadyExists { code: String },\n    InvalidState { current: String, expected: String },\n    ValidationFailed { details: Vec\u003cString\u003e },\n    ModificationNotAllowed { state: String },\n    AssignmentFailed { reason: String },\n    InvalidCode { code: String, reason: String },\n    InvalidName { name: String, reason: String },\n    InvalidDates { reason: String },\n    ResourceNotFound { resource_code: String },\n    ProjectNotFound { project_code: String },\n    CircularDependency { task_codes: Vec\u003cString\u003e },\n}\n\nimpl fmt::Display for TaskError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            TaskError::NotFound { code } =\u003e {\n                write!(f, \"Task with code '{}' not found\", code)\n            }\n            TaskError::AlreadyExists { code } =\u003e {\n                write!(f, \"Task with code '{}' already exists\", code)\n            }\n            TaskError::InvalidState { current, expected } =\u003e {\n                write!(f, \"Task is in invalid state '{}', expected '{}'\", current, expected)\n            }\n            TaskError::ValidationFailed { details } =\u003e {\n                write!(f, \"Task validation failed: {}\", details.join(\", \"))\n            }\n            TaskError::ModificationNotAllowed { state } =\u003e {\n                write!(f, \"Cannot modify task in state '{}'\", state)\n            }\n            TaskError::AssignmentFailed { reason } =\u003e {\n                write!(f, \"Task assignment failed: {}\", reason)\n            }\n            TaskError::InvalidCode { code, reason } =\u003e {\n                write!(f, \"Task code '{}' is invalid: {}\", code, reason)\n            }\n            TaskError::InvalidName { name, reason } =\u003e {\n                write!(f, \"Task name '{}' is invalid: {}\", name, reason)\n            }\n            TaskError::InvalidDates { reason } =\u003e {\n                write!(f, \"Task dates are invalid: {}\", reason)\n            }\n            TaskError::ResourceNotFound { resource_code } =\u003e {\n                write!(\n                    f,\n                    \"Resource with code '{}' not found for task assignment\",\n                    resource_code\n                )\n            }\n            TaskError::ProjectNotFound { project_code } =\u003e {\n                write!(f, \"Project with code '{}' not found for task\", project_code)\n            }\n            TaskError::CircularDependency { task_codes } =\u003e {\n                write!(\n                    f,\n                    \"Circular dependency detected between tasks: {}\",\n                    task_codes.join(\" -\u003e \")\n                )\n            }\n        }\n    }\n}\n\nimpl StdError for TaskError {}\n\nimpl From\u003cTaskError\u003e for DomainError {\n    fn from(err: TaskError) -\u003e Self {\n        match err {\n            TaskError::NotFound { code } =\u003e DomainError::new(DomainErrorKind::TaskNotFound { code }),\n            TaskError::AlreadyExists { code } =\u003e DomainError::new(DomainErrorKind::TaskAlreadyExists { code }),\n            TaskError::InvalidState { current, expected } =\u003e {\n                DomainError::new(DomainErrorKind::TaskInvalidState { current, expected })\n            }\n            TaskError::ValidationFailed { details } =\u003e {\n                DomainError::new(DomainErrorKind::TaskValidationFailed { details })\n            }\n            TaskError::ModificationNotAllowed { state } =\u003e DomainError::new(DomainErrorKind::TaskInvalidState {\n                current: state,\n                expected: \"modifiable state\".to_string(),\n            }),\n            TaskError::AssignmentFailed { reason } =\u003e {\n                DomainError::new(DomainErrorKind::TaskAssignmentFailed { reason })\n            }\n            TaskError::InvalidCode { code, reason } =\u003e DomainError::new(DomainErrorKind::ValidationError {\n                field: \"code\".to_string(),\n                message: format!(\"Code '{}' is invalid: {}\", code, reason),\n            }),\n            TaskError::InvalidName { name, reason } =\u003e DomainError::new(DomainErrorKind::ValidationError {\n                field: \"name\".to_string(),\n                message: format!(\"Name '{}' is invalid: {}\", name, reason),\n            }),\n            TaskError::InvalidDates { reason } =\u003e DomainError::new(DomainErrorKind::ValidationError {\n                field: \"dates\".to_string(),\n                message: reason,\n            }),\n            TaskError::ResourceNotFound { resource_code } =\u003e {\n                DomainError::new(DomainErrorKind::ResourceNotFound { code: resource_code })\n            }\n            TaskError::ProjectNotFound { project_code } =\u003e {\n                DomainError::new(DomainErrorKind::ProjectNotFound { code: project_code })\n            }\n            TaskError::CircularDependency { task_codes } =\u003e DomainError::new(DomainErrorKind::ValidationError {\n                field: \"dependencies\".to_string(),\n                message: format!(\"Circular dependency: {}\", task_codes.join(\" -\u003e \")),\n            }),\n        }\n    }\n}\n\n// Result type for task operations\npub type TaskResult\u003cT\u003e = Result\u003cT, TaskError\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_task_error_not_found_display() {\n        let error = TaskError::NotFound { code: \"TASK-001\".to_string() };\n        let expected = \"Task with code 'TASK-001' not found\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_already_exists_display() {\n        let error = TaskError::AlreadyExists { code: \"TASK-002\".to_string() };\n        let expected = \"Task with code 'TASK-002' already exists\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_invalid_state_display() {\n        let error = TaskError::InvalidState { \n            current: \"Completed\".to_string(), \n            expected: \"In Progress\".to_string() \n        };\n        let expected = \"Task is in invalid state 'Completed', expected 'In Progress'\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_validation_failed_display() {\n        let error = TaskError::ValidationFailed { \n            details: vec![\"Name is required\".to_string(), \"Code is invalid\".to_string()] \n        };\n        let expected = \"Task validation failed: Name is required, Code is invalid\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_modification_not_allowed_display() {\n        let error = TaskError::ModificationNotAllowed { state: \"Completed\".to_string() };\n        let expected = \"Cannot modify task in state 'Completed'\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_assignment_failed_display() {\n        let error = TaskError::AssignmentFailed { \n            reason: \"Resource not available\".to_string() \n        };\n        let expected = \"Task assignment failed: Resource not available\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_invalid_code_display() {\n        let error = TaskError::InvalidCode { \n            code: \"INVALID\".to_string(), \n            reason: \"Contains invalid characters\".to_string() \n        };\n        let expected = \"Task code 'INVALID' is invalid: Contains invalid characters\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_invalid_name_display() {\n        let error = TaskError::InvalidName { \n            name: \"123\".to_string(), \n            reason: \"Contains numbers\".to_string() \n        };\n        let expected = \"Task name '123' is invalid: Contains numbers\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_invalid_dates_display() {\n        let error = TaskError::InvalidDates { \n            reason: \"End date before start date\".to_string() \n        };\n        let expected = \"Task dates are invalid: End date before start date\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_resource_not_found_display() {\n        let error = TaskError::ResourceNotFound { \n            resource_code: \"RES-001\".to_string() \n        };\n        let expected = \"Resource with code 'RES-001' not found for task assignment\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_project_not_found_display() {\n        let error = TaskError::ProjectNotFound { \n            project_code: \"PROJ-001\".to_string() \n        };\n        let expected = \"Project with code 'PROJ-001' not found for task\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_circular_dependency_display() {\n        let error = TaskError::CircularDependency { \n            task_codes: vec![\"TASK-001\".to_string(), \"TASK-002\".to_string(), \"TASK-001\".to_string()] \n        };\n        let expected = \"Circular dependency detected between tasks: TASK-001 -\u003e TASK-002 -\u003e TASK-001\";\n        assert_eq!(error.to_string(), expected);\n    }\n\n    #[test]\n    fn test_task_error_debug_formatting() {\n        let error = TaskError::NotFound { code: \"TASK-001\".to_string() };\n        let debug_str = format!(\"{:?}\", error);\n        assert!(debug_str.contains(\"NotFound\"));\n        assert!(debug_str.contains(\"TASK-001\"));\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_not_found() {\n        let task_error = TaskError::NotFound { code: \"TASK-001\".to_string() };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::TaskNotFound { code } =\u003e {\n                assert_eq!(code, \"TASK-001\");\n            }\n            _ =\u003e panic!(\"Expected TaskNotFound error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_already_exists() {\n        let task_error = TaskError::AlreadyExists { code: \"TASK-002\".to_string() };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::TaskAlreadyExists { code } =\u003e {\n                assert_eq!(code, \"TASK-002\");\n            }\n            _ =\u003e panic!(\"Expected TaskAlreadyExists error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_invalid_state() {\n        let task_error = TaskError::InvalidState { \n            current: \"Completed\".to_string(), \n            expected: \"In Progress\".to_string() \n        };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::TaskInvalidState { current, expected } =\u003e {\n                assert_eq!(current, \"Completed\");\n                assert_eq!(expected, \"In Progress\");\n            }\n            _ =\u003e panic!(\"Expected TaskInvalidState error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_validation_failed() {\n        let task_error = TaskError::ValidationFailed { \n            details: vec![\"Name is required\".to_string(), \"Code is invalid\".to_string()] \n        };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::TaskValidationFailed { details } =\u003e {\n                assert_eq!(details.len(), 2);\n                assert!(details.contains(\u0026\"Name is required\".to_string()));\n                assert!(details.contains(\u0026\"Code is invalid\".to_string()));\n            }\n            _ =\u003e panic!(\"Expected TaskValidationFailed error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_modification_not_allowed() {\n        let task_error = TaskError::ModificationNotAllowed { state: \"Completed\".to_string() };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::TaskInvalidState { current, expected } =\u003e {\n                assert_eq!(current, \"Completed\");\n                assert_eq!(expected, \"modifiable state\");\n            }\n            _ =\u003e panic!(\"Expected TaskInvalidState error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_assignment_failed() {\n        let task_error = TaskError::AssignmentFailed { \n            reason: \"Resource not available\".to_string() \n        };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::TaskAssignmentFailed { reason } =\u003e {\n                assert_eq!(reason, \"Resource not available\");\n            }\n            _ =\u003e panic!(\"Expected TaskAssignmentFailed error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_invalid_code() {\n        let task_error = TaskError::InvalidCode { \n            code: \"INVALID\".to_string(), \n            reason: \"Contains invalid characters\".to_string() \n        };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ValidationError { field, message } =\u003e {\n                assert_eq!(field, \"code\");\n                assert_eq!(message, \"Code 'INVALID' is invalid: Contains invalid characters\");\n            }\n            _ =\u003e panic!(\"Expected ValidationError error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_invalid_name() {\n        let task_error = TaskError::InvalidName { \n            name: \"123\".to_string(), \n            reason: \"Contains numbers\".to_string() \n        };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ValidationError { field, message } =\u003e {\n                assert_eq!(field, \"name\");\n                assert_eq!(message, \"Name '123' is invalid: Contains numbers\");\n            }\n            _ =\u003e panic!(\"Expected ValidationError error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_invalid_dates() {\n        let task_error = TaskError::InvalidDates { \n            reason: \"End date before start date\".to_string() \n        };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ValidationError { field, message } =\u003e {\n                assert_eq!(field, \"dates\");\n                assert_eq!(message, \"End date before start date\");\n            }\n            _ =\u003e panic!(\"Expected ValidationError error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_resource_not_found() {\n        let task_error = TaskError::ResourceNotFound { \n            resource_code: \"RES-001\".to_string() \n        };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ResourceNotFound { code } =\u003e {\n                assert_eq!(code, \"RES-001\");\n            }\n            _ =\u003e panic!(\"Expected ResourceNotFound error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_project_not_found() {\n        let task_error = TaskError::ProjectNotFound { \n            project_code: \"PROJ-001\".to_string() \n        };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ProjectNotFound { code } =\u003e {\n                assert_eq!(code, \"PROJ-001\");\n            }\n            _ =\u003e panic!(\"Expected ProjectNotFound error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_from_task_error_to_domain_error_circular_dependency() {\n        let task_error = TaskError::CircularDependency { \n            task_codes: vec![\"TASK-001\".to_string(), \"TASK-002\".to_string(), \"TASK-001\".to_string()] \n        };\n        let domain_error: DomainError = task_error.into();\n        \n        match domain_error.kind() {\n            DomainErrorKind::ValidationError { field, message } =\u003e {\n                assert_eq!(field, \"dependencies\");\n                assert_eq!(message, \"Circular dependency: TASK-001 -\u003e TASK-002 -\u003e TASK-001\");\n            }\n            _ =\u003e panic!(\"Expected ValidationError error kind\"),\n        }\n    }\n\n    #[test]\n    fn test_task_result_success() {\n        let result: TaskResult\u003cString\u003e = Ok(\"Success\".to_string());\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"Success\");\n    }\n\n    #[test]\n    fn test_task_result_failure() {\n        let result: TaskResult\u003cString\u003e = Err(TaskError::NotFound { code: \"TASK-001\".to_string() });\n        assert!(result.is_err());\n        \n        match result {\n            Err(TaskError::NotFound { code }) =\u003e {\n                assert_eq!(code, \"TASK-001\");\n            }\n            _ =\u003e panic!(\"Expected NotFound error\"),\n        }\n    }\n\n    #[test]\n    fn test_all_error_variants_covered() {\n        // Test that all TaskError variants can be created and converted\n        let errors = vec![\n            TaskError::NotFound { code: \"TEST\".to_string() },\n            TaskError::AlreadyExists { code: \"TEST\".to_string() },\n            TaskError::InvalidState { \n                current: \"TEST\".to_string(), \n                expected: \"TEST\".to_string() \n            },\n            TaskError::ValidationFailed { \n                details: vec![\"TEST\".to_string()] \n            },\n            TaskError::ModificationNotAllowed { state: \"TEST\".to_string() },\n            TaskError::AssignmentFailed { reason: \"TEST\".to_string() },\n            TaskError::InvalidCode { \n                code: \"TEST\".to_string(), \n                reason: \"TEST\".to_string() \n            },\n            TaskError::InvalidName { \n                name: \"TEST\".to_string(), \n                reason: \"TEST\".to_string() \n            },\n            TaskError::InvalidDates { reason: \"TEST\".to_string() },\n            TaskError::ResourceNotFound { resource_code: \"TEST\".to_string() },\n            TaskError::ProjectNotFound { project_code: \"TEST\".to_string() },\n            TaskError::CircularDependency { \n                task_codes: vec![\"TEST\".to_string()] \n            },\n        ];\n\n        for error in errors {\n            let domain_error: DomainError = error.into();\n            assert!(domain_error.to_string().len() \u003e 0);\n        }\n    }\n}\n","traces":[{"line":23,"address":[90523,88544,90529],"length":1,"stats":{"Line":1}},{"line":24,"address":[88577],"length":1,"stats":{"Line":2}},{"line":25,"address":[88613],"length":1,"stats":{"Line":1}},{"line":26,"address":[88622],"length":1,"stats":{"Line":1}},{"line":28,"address":[88724],"length":1,"stats":{"Line":1}},{"line":29,"address":[88736],"length":1,"stats":{"Line":1}},{"line":31,"address":[88853],"length":1,"stats":{"Line":1}},{"line":32,"address":[88880],"length":1,"stats":{"Line":1}},{"line":34,"address":[89083],"length":1,"stats":{"Line":1}},{"line":35,"address":[89095,90376],"length":1,"stats":{"Line":1}},{"line":37,"address":[89174],"length":1,"stats":{"Line":1}},{"line":38,"address":[89186],"length":1,"stats":{"Line":1}},{"line":40,"address":[89303],"length":1,"stats":{"Line":1}},{"line":41,"address":[89315],"length":1,"stats":{"Line":1}},{"line":43,"address":[89432],"length":1,"stats":{"Line":1}},{"line":44,"address":[89459],"length":1,"stats":{"Line":1}},{"line":46,"address":[89662],"length":1,"stats":{"Line":1}},{"line":47,"address":[89689],"length":1,"stats":{"Line":1}},{"line":49,"address":[89892],"length":1,"stats":{"Line":1}},{"line":50,"address":[89904],"length":1,"stats":{"Line":1}},{"line":52,"address":[90021],"length":1,"stats":{"Line":1}},{"line":53,"address":[90033],"length":1,"stats":{"Line":1}},{"line":59,"address":[90150],"length":1,"stats":{"Line":1}},{"line":60,"address":[90162],"length":1,"stats":{"Line":1}},{"line":62,"address":[90276],"length":1,"stats":{"Line":1}},{"line":63,"address":[90542,90340],"length":1,"stats":{"Line":1}},{"line":66,"address":[90288],"length":1,"stats":{"Line":1}},{"line":76,"address":[3074160,3072592],"length":1,"stats":{"Line":1}},{"line":77,"address":[3072614],"length":1,"stats":{"Line":4}},{"line":78,"address":[3072663],"length":1,"stats":{"Line":1}},{"line":79,"address":[3072754],"length":1,"stats":{"Line":1}},{"line":80,"address":[3072878],"length":1,"stats":{"Line":1}},{"line":81,"address":[3072950],"length":1,"stats":{"Line":1}},{"line":83,"address":[3073086],"length":1,"stats":{"Line":1}},{"line":84,"address":[3073122],"length":1,"stats":{"Line":2}},{"line":86,"address":[3073205,3074034],"length":1,"stats":{"Line":3}},{"line":87,"address":[3073229],"length":1,"stats":{"Line":2}},{"line":88,"address":[3073261],"length":1,"stats":{"Line":2}},{"line":90,"address":[3073305],"length":1,"stats":{"Line":1}},{"line":91,"address":[3073341],"length":1,"stats":{"Line":1}},{"line":93,"address":[3074471,3073424],"length":1,"stats":{"Line":2}},{"line":94,"address":[3073472],"length":1,"stats":{"Line":1}},{"line":95,"address":[3074231,3074323],"length":1,"stats":{"Line":2}},{"line":97,"address":[3073511,3074936],"length":1,"stats":{"Line":2}},{"line":98,"address":[3073559],"length":1,"stats":{"Line":1}},{"line":99,"address":[3074696,3074788],"length":1,"stats":{"Line":2}},{"line":101,"address":[3073598,3075195],"length":1,"stats":{"Line":2}},{"line":102,"address":[3073630],"length":1,"stats":{"Line":1}},{"line":103,"address":[3075155],"length":1,"stats":{"Line":1}},{"line":105,"address":[3073674],"length":1,"stats":{"Line":1}},{"line":106,"address":[3073710],"length":1,"stats":{"Line":1}},{"line":108,"address":[3073798],"length":1,"stats":{"Line":1}},{"line":109,"address":[3073834],"length":1,"stats":{"Line":1}},{"line":111,"address":[3073914,3075672],"length":1,"stats":{"Line":2}},{"line":112,"address":[3073938],"length":1,"stats":{"Line":1}},{"line":113,"address":[3075445,3075365],"length":1,"stats":{"Line":2}}],"covered":56,"coverable":56},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","task_management","mod.rs"],"content":"#![allow(unused_imports)]\n\n// Module declarations\npub mod any_task;\npub mod builder;\npub mod errors;\npub mod repository;\npub mod resource_assignment;\npub mod state;\npub mod task;\n\n// Re-export public items from sub-modules\npub use any_task::AnyTask;\npub use builder::TaskBuilder;\npub use task::{DateRange, Task, TaskError};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","task_management","repository.rs"],"content":"use crate::domain::shared::errors::DomainError;\nuse crate::domain::task_management::AnyTask;\n\npub trait TaskRepository {\n    fn save(\u0026self, task: AnyTask) -\u003e Result\u003cAnyTask, DomainError\u003e;\n    fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyTask\u003e, DomainError\u003e;\n    fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyTask\u003e, DomainError\u003e;\n    fn find_by_project(\u0026self, project_code: \u0026str) -\u003e Result\u003cVec\u003cAnyTask\u003e, DomainError\u003e;\n    fn get_next_code(\u0026self, project_code: \u0026str) -\u003e Result\u003cString, DomainError\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","task_management","resource_assignment.rs"],"content":"use chrono::NaiveDate;\n\n#[derive(Debug, Clone, PartialEq)]\npub struct ResourceAssignment {\n    pub resource_id: String,\n    pub allocation_percentage: u8,\n    pub start_date: NaiveDate,\n    pub end_date: NaiveDate,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","task_management","state.rs"],"content":"use serde::Serialize;\n\n/// A marker trait for all task states.\npub trait TaskState: Sized + std::fmt::Debug {}\n\n/// State for a task that has been planned but not yet started.\n#[derive(Debug, Clone, Serialize, PartialEq)]\npub struct Planned;\nimpl TaskState for Planned {}\n\n/// State for a task that is currently in progress.\n#[derive(Debug, Clone, Serialize, PartialEq)]\npub struct InProgress {\n    pub progress: u8,\n}\nimpl TaskState for InProgress {}\n\n/// State for a task that is blocked.\n#[derive(Debug, Clone, Serialize, PartialEq)]\npub struct Blocked {\n    pub reason: String,\n}\nimpl TaskState for Blocked {}\n\n/// State for a task that has been completed.\n#[derive(Debug, Clone, Serialize, PartialEq)]\npub struct Completed;\nimpl TaskState for Completed {}\n\n/// State for a task that has been cancelled.\n#[derive(Debug, Clone, Serialize, PartialEq)]\npub struct Cancelled;\nimpl TaskState for Cancelled {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","domain","task_management","task.rs"],"content":"use super::state::{Blocked, Cancelled, Completed, InProgress, Planned, TaskState};\nuse chrono::{NaiveDate, Utc};\nuse serde::Serialize;\nuse uuid7::Uuid;\n\n#[derive(Debug, Clone, Serialize, PartialEq)]\npub struct Task\u003cS: TaskState\u003e {\n    pub id: Uuid,\n    pub project_code: String,\n    pub code: String,\n    pub name: String,\n    pub description: Option\u003cString\u003e,\n    #[serde(flatten)]\n    pub state: S,\n    pub start_date: NaiveDate,\n    pub due_date: NaiveDate,\n    pub actual_end_date: Option\u003cNaiveDate\u003e,\n    pub dependencies: Vec\u003cString\u003e,\n    pub assigned_resources: Vec\u003cString\u003e,\n}\n\n// Transitions for a Planned task\nimpl Task\u003cPlanned\u003e {\n    /// Starts a planned task, moving it to the InProgress state.\n    #[allow(dead_code)]\n    pub fn start(self) -\u003e Task\u003cInProgress\u003e {\n        Task {\n            id: self.id,\n            project_code: self.project_code,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            state: InProgress { progress: 0 },\n            start_date: self.start_date,\n            due_date: self.due_date,\n            actual_end_date: None,\n            dependencies: self.dependencies,\n            assigned_resources: self.assigned_resources,\n        }\n    }\n\n    /// Cancels a planned task.\n    #[allow(dead_code)]\n    pub fn cancel(self) -\u003e Task\u003cCancelled\u003e {\n        Task {\n            id: self.id,\n            project_code: self.project_code,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            state: Cancelled,\n            start_date: self.start_date,\n            due_date: self.due_date,\n            actual_end_date: None,\n            dependencies: self.dependencies,\n            assigned_resources: self.assigned_resources,\n        }\n    }\n}\n\n// Actions and transitions for an InProgress task\nimpl Task\u003cInProgress\u003e {\n    /// Updates the progress of the task.\n    #[allow(dead_code)]\n    pub fn update_progress(mut self, progress: u8) -\u003e Self {\n        self.state.progress = progress;\n        self\n    }\n\n    /// Blocks the task for a given reason.\n    #[allow(dead_code)]\n    pub fn block(self, reason: String) -\u003e Task\u003cBlocked\u003e {\n        Task {\n            id: self.id,\n            project_code: self.project_code,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            state: Blocked { reason },\n            start_date: self.start_date,\n            due_date: self.due_date,\n            actual_end_date: None,\n            dependencies: self.dependencies,\n            assigned_resources: self.assigned_resources,\n        }\n    }\n\n    /// Completes the task.\n    #[allow(dead_code)]\n    pub fn complete(self) -\u003e Task\u003cCompleted\u003e {\n        Task {\n            id: self.id,\n            project_code: self.project_code,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            state: Completed,\n            start_date: self.start_date,\n            due_date: self.due_date,\n            actual_end_date: Some(Utc::now().date_naive()),\n            dependencies: self.dependencies,\n            assigned_resources: self.assigned_resources,\n        }\n    }\n\n    /// Cancels the task.\n    #[allow(dead_code)]\n    pub fn cancel(self) -\u003e Task\u003cCancelled\u003e {\n        Task {\n            id: self.id,\n            project_code: self.project_code,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            state: Cancelled,\n            start_date: self.start_date,\n            due_date: self.due_date,\n            actual_end_date: None,\n            dependencies: self.dependencies,\n            assigned_resources: self.assigned_resources,\n        }\n    }\n}\n\n// Transitions for a Blocked task\nimpl Task\u003cBlocked\u003e {\n    /// Unblocks the task, returning it to the InProgress state.\n    #[allow(dead_code)]\n    pub fn unblock(self) -\u003e Task\u003cInProgress\u003e {\n        Task {\n            id: self.id,\n            project_code: self.project_code,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            state: InProgress { progress: 0 }, // Assuming progress resets\n            start_date: self.start_date,\n            due_date: self.due_date,\n            actual_end_date: None,\n            dependencies: self.dependencies,\n            assigned_resources: self.assigned_resources,\n        }\n    }\n\n    /// Cancels the blocked task.\n    #[allow(dead_code)]\n    pub fn cancel(self) -\u003e Task\u003cCancelled\u003e {\n        Task {\n            id: self.id,\n            project_code: self.project_code,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            state: Cancelled,\n            start_date: self.start_date,\n            due_date: self.due_date,\n            actual_end_date: None,\n            dependencies: self.dependencies,\n            assigned_resources: self.assigned_resources,\n        }\n    }\n}\n\n#[allow(dead_code)]\npub struct DateRange {\n    pub start: NaiveDate,\n    pub end: NaiveDate,\n}\n\n#[allow(dead_code)]\nimpl DateRange {\n    pub fn overlaps(\u0026self, other: \u0026Self) -\u003e bool {\n        self.start \u003c= other.end \u0026\u0026 self.end \u003e= other.start\n    }\n}\n\n#[allow(dead_code)]\n#[derive(Debug)]\npub enum TaskError {\n    InvalidDateRange,\n    ResourceOnVacation(String),\n    MissingField(String), // Otimizado: removido \u0026'static str desnecessário\n}\n\nimpl std::fmt::Display for TaskError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            TaskError::InvalidDateRange =\u003e write!(f, \"Data inicial é posterior à data final.\"),\n            TaskError::ResourceOnVacation(res) =\u003e {\n                write!(f, \"Recurso {res} está de férias neste período.\")\n            }\n            TaskError::MissingField(field) =\u003e {\n                write!(f, \"Campo obrigatório não informado: {field}\")\n            }\n        }\n    }\n}\n\nimpl std::error::Error for TaskError {}\n\n// Common methods for all Task states\nimpl\u003cS: TaskState\u003e Task\u003cS\u003e {\n    // --- Zero-copy accessors ---\n\n    pub fn code(\u0026self) -\u003e \u0026str {\n        \u0026self.code\n    }\n\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    pub fn project_code(\u0026self) -\u003e \u0026str {\n        \u0026self.project_code\n    }\n\n    pub fn description(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.description.as_deref()\n    }\n\n    pub fn start_date(\u0026self) -\u003e \u0026NaiveDate {\n        \u0026self.start_date\n    }\n\n    pub fn due_date(\u0026self) -\u003e \u0026NaiveDate {\n        \u0026self.due_date\n    }\n\n    pub fn actual_end_date(\u0026self) -\u003e Option\u003c\u0026NaiveDate\u003e {\n        self.actual_end_date.as_ref()\n    }\n\n    pub fn dependencies(\u0026self) -\u003e \u0026[String] {\n        self.dependencies.as_slice()\n    }\n\n    pub fn assigned_resources(\u0026self) -\u003e \u0026[String] {\n        self.assigned_resources.as_slice()\n    }\n\n    // Nota: Task não tem campos estimated_hours e actual_hours\n    // Esses campos foram removidos na refatoração anterior\n    // Os métodos foram removidos para manter consistência\n\n    // --- Iterators ---\n\n    pub fn dependencies_iter(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.dependencies.iter()\n    }\n\n    pub fn assigned_resources_iter(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.assigned_resources.iter()\n    }\n\n    // Validation methods\n    pub fn is_code_valid(\u0026self) -\u003e bool {\n        !self.code.trim().is_empty()\n    }\n\n    pub fn is_name_valid(\u0026self) -\u003e bool {\n        !self.name.trim().is_empty()\n    }\n\n    pub fn is_date_range_valid(\u0026self) -\u003e bool {\n        self.start_date \u003c= self.due_date\n    }\n\n    pub fn validate(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n        let mut errors = Vec::new();\n\n        if !self.is_code_valid() {\n            errors.push(\"Task code cannot be empty\".to_string());\n        }\n\n        if !self.is_name_valid() {\n            errors.push(\"Task name cannot be empty\".to_string());\n        }\n\n        if !self.is_date_range_valid() {\n            errors.push(\"Task due date must be after start date\".to_string());\n        }\n\n        Ok(errors)\n    }\n}\n\n// Transition trait for state changes\npub trait Transition {\n    type NextState: TaskState;\n    fn transition(self) -\u003e Task\u003cSelf::NextState\u003e;\n}\n\nimpl Transition for Task\u003cPlanned\u003e {\n    type NextState = InProgress;\n\n    fn transition(self) -\u003e Task\u003cInProgress\u003e {\n        Task {\n            id: self.id,\n            project_code: self.project_code,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            state: InProgress { progress: 0 },\n            start_date: self.start_date,\n            due_date: self.due_date,\n            actual_end_date: self.actual_end_date,\n            dependencies: self.dependencies,\n            assigned_resources: self.assigned_resources,\n        }\n    }\n}\n\nimpl Transition for Task\u003cInProgress\u003e {\n    type NextState = Completed;\n\n    fn transition(self) -\u003e Task\u003cCompleted\u003e {\n        Task {\n            id: self.id,\n            project_code: self.project_code,\n            code: self.code,\n            name: self.name,\n            description: self.description,\n            state: Completed,\n            start_date: self.start_date,\n            due_date: self.due_date,\n            actual_end_date: Some(chrono::Utc::now().date_naive()),\n            dependencies: self.dependencies,\n            assigned_resources: self.assigned_resources,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::NaiveDate;\n    use uuid7::uuid7;\n\n    fn d(year: i32, month: u32, day: u32) -\u003e NaiveDate {\n        NaiveDate::from_ymd_opt(year, month, day).unwrap()\n    }\n\n    fn create_planned_task() -\u003e Task\u003cPlanned\u003e {\n        Task {\n            id: uuid7(),\n            project_code: \"proj-x\".to_string(),\n            code: \"T1\".to_string(),\n            name: \"My test task\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: d(2024, 7, 1),\n            due_date: d(2024, 7, 31),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![],\n        }\n    }\n\n    #[test]\n    fn test_date_range_overlaps() {\n        let base_range = DateRange {\n            start: d(2024, 1, 10),\n            end: d(2024, 1, 20),\n        };\n\n        let inside_range = DateRange {\n            start: d(2024, 1, 12),\n            end: d(2024, 1, 18),\n        };\n        assert!(base_range.overlaps(\u0026inside_range));\n\n        let after_range = DateRange {\n            start: d(2024, 1, 21),\n            end: d(2024, 1, 25),\n        };\n        assert!(!base_range.overlaps(\u0026after_range));\n    }\n\n    #[test]\n    fn test_task_error_display_formatting() {\n        let invalid_date_err = TaskError::InvalidDateRange;\n        assert_eq!(format!(\"{invalid_date_err}\"), \"Data inicial é posterior à data final.\");\n\n        let vacation_err = TaskError::ResourceOnVacation(\"RES-123\".to_string());\n        assert_eq!(\n            format!(\"{vacation_err}\"),\n            \"Recurso RES-123 está de férias neste período.\"\n        );\n    }\n\n    #[test]\n    fn test_planned_to_in_progress() {\n        let task = create_planned_task();\n        let task_id = task.id;\n        let in_progress_task = task.start();\n        assert_eq!(in_progress_task.state.progress, 0);\n        // Verify other fields are carried over\n        assert_eq!(in_progress_task.id, task_id);\n    }\n\n    #[test]\n    fn test_in_progress_to_completed() {\n        let task = create_planned_task().start();\n        let completed_task = task.complete();\n        assert!(completed_task.actual_end_date.is_some());\n    }\n\n    #[test]\n    fn test_in_progress_update_progress() {\n        let task = create_planned_task().start();\n        assert_eq!(task.state.progress, 0);\n        let updated_task = task.update_progress(50);\n        assert_eq!(updated_task.state.progress, 50);\n    }\n\n    #[test]\n    fn test_in_progress_to_blocked() {\n        let task = create_planned_task().start();\n        let reason = \"Waiting for review\".to_string();\n        let blocked_task = task.block(reason.clone());\n        assert_eq!(blocked_task.state.reason, reason);\n    }\n\n    #[test]\n    fn test_blocked_to_unblocked() {\n        let task = create_planned_task().start().block(\"Needs clarification\".to_string());\n        let in_progress_task = task.unblock();\n        assert_eq!(in_progress_task.state.progress, 0);\n    }\n\n    #[test]\n    fn test_cancel_from_planned() {\n        let task = create_planned_task();\n        let task_id = task.id;\n        let cancelled_task = task.cancel();\n        // This is a compile-time check, but we can assert on the type if we had a way to get a string from it.\n        // For now, just creating it is enough to test the transition exists.\n        assert_eq!(cancelled_task.id, task_id);\n    }\n\n    #[test]\n    fn test_task_creation_with_valid_data() {\n        let task = Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"TASK-001\".to_string(),\n            name: \"Implement Login Feature\".to_string(),\n            description: Some(\"Create user authentication system\".to_string()),\n            state: Planned,\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        assert_eq!(task.code(), \"TASK-001\");\n        assert_eq!(task.name(), \"Implement Login Feature\");\n        assert_eq!(task.description(), Some(\"Create user authentication system\"));\n        assert_eq!(task.start_date(), \u0026chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap());\n        assert_eq!(task.due_date(), \u0026chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap());\n        assert!(task.is_code_valid());\n        assert!(task.is_name_valid());\n        assert!(task.is_date_range_valid());\n    }\n\n    #[test]\n    fn test_task_code_validation() {\n        // Valid code\n        let valid_task = Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"TASK-001\".to_string(),\n            name: \"Test Task\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        assert!(valid_task.is_code_valid());\n\n        // Invalid code (empty)\n        let invalid_task = Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"\".to_string(),\n            name: \"Test Task\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        assert!(!invalid_task.is_code_valid());\n    }\n\n    #[test]\n    fn test_task_name_validation() {\n        // Valid name\n        let valid_task = Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"TASK-001\".to_string(),\n            name: \"Implement Feature\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        assert!(valid_task.is_name_valid());\n\n        // Invalid name (empty)\n        let invalid_task = Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"TASK-001\".to_string(),\n            name: \"\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        assert!(!invalid_task.is_name_valid());\n    }\n\n    #[test]\n    fn test_task_date_validation() {\n        // Valid date range\n        let valid_task = Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"TASK-001\".to_string(),\n            name: \"Test Task\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        assert!(valid_task.is_date_range_valid());\n\n        // Invalid date range (end before start)\n        let invalid_task = Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"TASK-001\".to_string(),\n            name: \"Test Task\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        assert!(!invalid_task.is_date_range_valid());\n    }\n\n    #[test]\n    fn test_task_comprehensive_validation() {\n        let valid_task = Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"TASK-001\".to_string(),\n            name: \"Implement Feature\".to_string(),\n            description: Some(\"A comprehensive test task\".to_string()),\n            state: Planned,\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        let validation_result = valid_task.validate();\n        assert!(validation_result.is_ok());\n        assert_eq!(validation_result.unwrap().len(), 0); // No validation errors\n\n        let invalid_task = Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"\".to_string(),\n            name: \"\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        let validation_result = invalid_task.validate();\n        assert!(validation_result.is_ok());\n        let errors = validation_result.unwrap();\n        assert!(!errors.is_empty()); // Should have validation errors\n        assert!(errors.iter().any(|e| e.contains(\"code\")));\n        assert!(errors.iter().any(|e| e.contains(\"name\")));\n        assert!(errors.iter().any(|e| e.contains(\"date\")));\n    }\n\n    #[test]\n    fn test_task_state_transitions() {\n        let planned_task = Task::\u003cPlanned\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"TASK-001\".to_string(),\n            name: \"Test Task\".to_string(),\n            description: None,\n            state: Planned,\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        // Transition from Planned to InProgress\n        let in_progress_task: Task\u003cInProgress\u003e = planned_task.transition();\n        assert!(matches!(in_progress_task.state, _InProgress));\n\n        // Transition from InProgress to Completed\n        let in_progress_task = Task::\u003cInProgress\u003e {\n            id: uuid7(),\n            project_code: \"PROJ-001\".to_string(),\n            code: \"TASK-001\".to_string(),\n            name: \"Test Task\".to_string(),\n            description: None,\n            state: InProgress { progress: 50 },\n            start_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n            due_date: chrono::NaiveDate::from_ymd_opt(2024, 1, 15).unwrap(),\n            actual_end_date: None,\n            dependencies: Vec::new(),\n            assigned_resources: Vec::new(),\n        };\n\n        let completed_task: Task\u003cCompleted\u003e = in_progress_task.transition();\n        assert!(matches!(completed_task.state, Completed));\n    }\n}\n","traces":[{"line":26,"address":[1409568],"length":1,"stats":{"Line":1}},{"line":28,"address":[1409575],"length":1,"stats":{"Line":2}},{"line":29,"address":[1409599],"length":1,"stats":{"Line":3}},{"line":30,"address":[1409625],"length":1,"stats":{"Line":3}},{"line":31,"address":[1409652],"length":1,"stats":{"Line":4}},{"line":32,"address":[1409679],"length":1,"stats":{"Line":5}},{"line":34,"address":[1409712],"length":1,"stats":{"Line":5}},{"line":35,"address":[1409718],"length":1,"stats":{"Line":5}},{"line":37,"address":[1409732],"length":1,"stats":{"Line":5}},{"line":38,"address":[1409758],"length":1,"stats":{"Line":5}},{"line":44,"address":[1410016],"length":1,"stats":{"Line":1}},{"line":46,"address":[1410023],"length":1,"stats":{"Line":1}},{"line":47,"address":[1410047],"length":1,"stats":{"Line":1}},{"line":48,"address":[1410073],"length":1,"stats":{"Line":1}},{"line":49,"address":[1410100],"length":1,"stats":{"Line":1}},{"line":50,"address":[1410127],"length":1,"stats":{"Line":1}},{"line":52,"address":[1410160],"length":1,"stats":{"Line":1}},{"line":53,"address":[1410166],"length":1,"stats":{"Line":1}},{"line":55,"address":[1410180],"length":1,"stats":{"Line":1}},{"line":56,"address":[1410206],"length":1,"stats":{"Line":1}},{"line":65,"address":[1410464],"length":1,"stats":{"Line":1}},{"line":66,"address":[1410482],"length":1,"stats":{"Line":1}},{"line":67,"address":[1410488],"length":1,"stats":{"Line":1}},{"line":72,"address":[1410512],"length":1,"stats":{"Line":2}},{"line":74,"address":[1410519],"length":1,"stats":{"Line":2}},{"line":75,"address":[1410543],"length":1,"stats":{"Line":2}},{"line":76,"address":[1410569],"length":1,"stats":{"Line":2}},{"line":77,"address":[1410596],"length":1,"stats":{"Line":2}},{"line":78,"address":[1410623],"length":1,"stats":{"Line":2}},{"line":79,"address":[1410656],"length":1,"stats":{"Line":2}},{"line":80,"address":[1410681],"length":1,"stats":{"Line":2}},{"line":81,"address":[1410687],"length":1,"stats":{"Line":2}},{"line":83,"address":[1410701],"length":1,"stats":{"Line":3}},{"line":84,"address":[1410728],"length":1,"stats":{"Line":1}},{"line":90,"address":[1411598,1411008,1411695],"length":1,"stats":{"Line":1}},{"line":92,"address":[1411030],"length":1,"stats":{"Line":1}},{"line":93,"address":[1411042],"length":1,"stats":{"Line":1}},{"line":94,"address":[1411059],"length":1,"stats":{"Line":1}},{"line":95,"address":[1411077],"length":1,"stats":{"Line":1}},{"line":96,"address":[1411101],"length":1,"stats":{"Line":1}},{"line":98,"address":[1411128],"length":1,"stats":{"Line":1}},{"line":99,"address":[1411138],"length":1,"stats":{"Line":1}},{"line":100,"address":[1411219,1411148],"length":1,"stats":{"Line":3}},{"line":101,"address":[1411266],"length":1,"stats":{"Line":2}},{"line":102,"address":[1411302],"length":1,"stats":{"Line":2}},{"line":108,"address":[1411712],"length":1,"stats":{"Line":1}},{"line":110,"address":[1411719],"length":1,"stats":{"Line":1}},{"line":111,"address":[1411743],"length":1,"stats":{"Line":1}},{"line":112,"address":[1411769],"length":1,"stats":{"Line":1}},{"line":113,"address":[1411796],"length":1,"stats":{"Line":1}},{"line":114,"address":[1411823],"length":1,"stats":{"Line":1}},{"line":116,"address":[1411856],"length":1,"stats":{"Line":1}},{"line":117,"address":[1411862],"length":1,"stats":{"Line":1}},{"line":119,"address":[1411876],"length":1,"stats":{"Line":1}},{"line":120,"address":[1411902],"length":1,"stats":{"Line":1}},{"line":129,"address":[1412160],"length":1,"stats":{"Line":1}},{"line":131,"address":[1412186],"length":1,"stats":{"Line":1}},{"line":132,"address":[1412210],"length":1,"stats":{"Line":1}},{"line":133,"address":[1412236],"length":1,"stats":{"Line":1}},{"line":134,"address":[1412263],"length":1,"stats":{"Line":1}},{"line":135,"address":[1412290],"length":1,"stats":{"Line":1}},{"line":137,"address":[1412326],"length":1,"stats":{"Line":1}},{"line":138,"address":[1412332],"length":1,"stats":{"Line":1}},{"line":140,"address":[1412349],"length":1,"stats":{"Line":1}},{"line":141,"address":[1412385],"length":1,"stats":{"Line":1}},{"line":147,"address":[1412704],"length":1,"stats":{"Line":0}},{"line":149,"address":[1412730],"length":1,"stats":{"Line":0}},{"line":150,"address":[1412754],"length":1,"stats":{"Line":0}},{"line":151,"address":[1412780],"length":1,"stats":{"Line":0}},{"line":152,"address":[1412807],"length":1,"stats":{"Line":0}},{"line":153,"address":[1412834],"length":1,"stats":{"Line":0}},{"line":155,"address":[1412870],"length":1,"stats":{"Line":0}},{"line":156,"address":[1412876],"length":1,"stats":{"Line":0}},{"line":158,"address":[1412893],"length":1,"stats":{"Line":0}},{"line":159,"address":[1412929],"length":1,"stats":{"Line":0}},{"line":172,"address":[1413232],"length":1,"stats":{"Line":1}},{"line":173,"address":[1413255],"length":1,"stats":{"Line":1}},{"line":186,"address":[1413312],"length":1,"stats":{"Line":1}},{"line":187,"address":[1413345],"length":1,"stats":{"Line":1}},{"line":188,"address":[1413380],"length":1,"stats":{"Line":1}},{"line":189,"address":[1413429],"length":1,"stats":{"Line":1}},{"line":190,"address":[1413438],"length":1,"stats":{"Line":1}},{"line":192,"address":[1413543],"length":1,"stats":{"Line":0}},{"line":193,"address":[1413555],"length":1,"stats":{"Line":0}},{"line":205,"address":[1062800],"length":1,"stats":{"Line":1}},{"line":206,"address":[1062805],"length":1,"stats":{"Line":1}},{"line":209,"address":[1062816],"length":1,"stats":{"Line":1}},{"line":210,"address":[1062821],"length":1,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[1062832],"length":1,"stats":{"Line":1}},{"line":218,"address":[1062837],"length":1,"stats":{"Line":1}},{"line":221,"address":[1062864],"length":1,"stats":{"Line":1}},{"line":222,"address":[1062872],"length":1,"stats":{"Line":1}},{"line":225,"address":[1062880],"length":1,"stats":{"Line":1}},{"line":226,"address":[1062888],"length":1,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[1062896],"length":1,"stats":{"Line":1}},{"line":257,"address":[1062901],"length":1,"stats":{"Line":1}},{"line":260,"address":[1062944],"length":1,"stats":{"Line":1}},{"line":261,"address":[1062949],"length":1,"stats":{"Line":1}},{"line":264,"address":[1062992],"length":1,"stats":{"Line":1}},{"line":265,"address":[1063000],"length":1,"stats":{"Line":1}},{"line":268,"address":[1063480,1063040,1063486],"length":1,"stats":{"Line":1}},{"line":269,"address":[1063070],"length":1,"stats":{"Line":1}},{"line":271,"address":[1063145,1063089],"length":1,"stats":{"Line":2}},{"line":272,"address":[1063151,1063195],"length":1,"stats":{"Line":2}},{"line":275,"address":[1063184,1063229],"length":1,"stats":{"Line":2}},{"line":276,"address":[1063235,1063279],"length":1,"stats":{"Line":2}},{"line":279,"address":[1063268,1063313],"length":1,"stats":{"Line":2}},{"line":280,"address":[1063447,1063319],"length":1,"stats":{"Line":2}},{"line":283,"address":[1063357],"length":1,"stats":{"Line":1}},{"line":296,"address":[1413680],"length":1,"stats":{"Line":1}},{"line":298,"address":[1413690],"length":1,"stats":{"Line":1}},{"line":299,"address":[1413714],"length":1,"stats":{"Line":1}},{"line":300,"address":[1413740],"length":1,"stats":{"Line":1}},{"line":301,"address":[1413767],"length":1,"stats":{"Line":1}},{"line":302,"address":[1413794],"length":1,"stats":{"Line":1}},{"line":304,"address":[1413827],"length":1,"stats":{"Line":1}},{"line":305,"address":[1413834],"length":1,"stats":{"Line":1}},{"line":306,"address":[1413841],"length":1,"stats":{"Line":1}},{"line":307,"address":[1413848],"length":1,"stats":{"Line":1}},{"line":308,"address":[1413874],"length":1,"stats":{"Line":1}},{"line":316,"address":[1414128,1414718,1414815],"length":1,"stats":{"Line":1}},{"line":318,"address":[1414150],"length":1,"stats":{"Line":1}},{"line":319,"address":[1414162],"length":1,"stats":{"Line":1}},{"line":320,"address":[1414179],"length":1,"stats":{"Line":1}},{"line":321,"address":[1414197],"length":1,"stats":{"Line":1}},{"line":322,"address":[1414221],"length":1,"stats":{"Line":1}},{"line":324,"address":[1414248],"length":1,"stats":{"Line":1}},{"line":325,"address":[1414258],"length":1,"stats":{"Line":1}},{"line":326,"address":[1414339,1414268],"length":1,"stats":{"Line":2}},{"line":327,"address":[1414386],"length":1,"stats":{"Line":1}},{"line":328,"address":[1414422],"length":1,"stats":{"Line":1}}],"covered":119,"coverable":143},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","errors.rs"],"content":"use crate::domain::shared::errors::{DomainError, DomainErrorKind};\nuse std::error::Error as StdError;\nuse std::fmt;\n\n/// Infrastructure-specific error types\n#[derive(Debug)]\npub enum InfrastructureError {\n    FileNotFound {\n        path: String,\n    },\n    FileReadError {\n        path: String,\n        details: String,\n    },\n    FileWriteError {\n        path: String,\n        details: String,\n    },\n    FileParseError {\n        path: String,\n        format: String,\n        details: String,\n    },\n    DirectoryNotFound {\n        path: String,\n    },\n    DirectoryCreateError {\n        path: String,\n        details: String,\n    },\n    PathInvalid {\n        path: String,\n        reason: String,\n    },\n    SerializationError {\n        format: String,\n        details: String,\n    },\n    DeserializationError {\n        format: String,\n        details: String,\n    },\n    NetworkError {\n        operation: String,\n        details: String,\n    },\n    DatabaseError {\n        operation: String,\n        details: String,\n    },\n    CacheError {\n        operation: String,\n        details: String,\n    },\n}\n\nimpl fmt::Display for InfrastructureError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            InfrastructureError::FileNotFound { path } =\u003e {\n                write!(f, \"File not found at path '{}'\", path)\n            }\n            InfrastructureError::FileReadError { path, details } =\u003e {\n                write!(f, \"Error reading file at path '{}': {}\", path, details)\n            }\n            InfrastructureError::FileWriteError { path, details } =\u003e {\n                write!(f, \"Error writing file at path '{}': {}\", path, details)\n            }\n            InfrastructureError::FileParseError { path, format, details } =\u003e {\n                write!(f, \"Error parsing {} file at path '{}': {}\", format, path, details)\n            }\n            InfrastructureError::DirectoryNotFound { path } =\u003e {\n                write!(f, \"Directory not found at path '{}'\", path)\n            }\n            InfrastructureError::DirectoryCreateError { path, details } =\u003e {\n                write!(f, \"Error creating directory at path '{}': {}\", path, details)\n            }\n            InfrastructureError::PathInvalid { path, reason } =\u003e {\n                write!(f, \"Invalid path '{}': {}\", path, reason)\n            }\n            InfrastructureError::SerializationError { format, details } =\u003e {\n                write!(f, \"Serialization error for format '{}': {}\", format, details)\n            }\n            InfrastructureError::DeserializationError { format, details } =\u003e {\n                write!(f, \"Deserialization error for format '{}': {}\", format, details)\n            }\n            InfrastructureError::NetworkError { operation, details } =\u003e {\n                write!(f, \"Network error during {}: {}\", operation, details)\n            }\n            InfrastructureError::DatabaseError { operation, details } =\u003e {\n                write!(f, \"Database error during {}: {}\", operation, details)\n            }\n            InfrastructureError::CacheError { operation, details } =\u003e {\n                write!(f, \"Cache error during {}: {}\", operation, details)\n            }\n        }\n    }\n}\n\nimpl StdError for InfrastructureError {}\n\nimpl From\u003cInfrastructureError\u003e for DomainError {\n    fn from(err: InfrastructureError) -\u003e Self {\n        match err {\n            InfrastructureError::FileNotFound { path } =\u003e DomainError::new(DomainErrorKind::Io {\n                operation: \"file read\".to_string(),\n                path: Some(path),\n            }),\n            InfrastructureError::FileReadError { path, details } =\u003e DomainError::new(DomainErrorKind::Io {\n                operation: \"file read\".to_string(),\n                path: Some(path),\n            })\n            .with_context(details),\n            InfrastructureError::FileWriteError { path, details } =\u003e DomainError::new(DomainErrorKind::Io {\n                operation: \"file write\".to_string(),\n                path: Some(path),\n            })\n            .with_context(details),\n            InfrastructureError::FileParseError { path, format, details } =\u003e {\n                DomainError::new(DomainErrorKind::Serialization {\n                    format,\n                    details: format!(\"Parse error at path '{}': {}\", path, details),\n                })\n            }\n            InfrastructureError::DirectoryNotFound { path } =\u003e DomainError::new(DomainErrorKind::Io {\n                operation: \"directory access\".to_string(),\n                path: Some(path),\n            }),\n            InfrastructureError::DirectoryCreateError { path, details } =\u003e DomainError::new(DomainErrorKind::Io {\n                operation: \"directory creation\".to_string(),\n                path: Some(path),\n            })\n            .with_context(details),\n            InfrastructureError::PathInvalid { path, reason } =\u003e DomainError::new(DomainErrorKind::ValidationError {\n                field: \"path\".to_string(),\n                message: format!(\"Path '{}' is invalid: {}\", path, reason),\n            }),\n            InfrastructureError::SerializationError { format, details } =\u003e {\n                DomainError::new(DomainErrorKind::Serialization { format, details })\n            }\n            InfrastructureError::DeserializationError { format, details } =\u003e {\n                DomainError::new(DomainErrorKind::Serialization { format, details })\n            }\n            InfrastructureError::NetworkError { operation, details } =\u003e {\n                DomainError::new(DomainErrorKind::RepositoryError { operation, details })\n            }\n            InfrastructureError::DatabaseError { operation, details } =\u003e {\n                DomainError::new(DomainErrorKind::RepositoryError { operation, details })\n            }\n            InfrastructureError::CacheError { operation, details } =\u003e {\n                DomainError::new(DomainErrorKind::RepositoryError { operation, details })\n            }\n        }\n    }\n}\n\n// Result type for infrastructure operations\npub type InfrastructureResult\u003cT\u003e = Result\u003cT, InfrastructureError\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_file_not_found_error_display() {\n        let error = InfrastructureError::FileNotFound {\n            path: \"/path/to/file.txt\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"File not found at path '/path/to/file.txt'\"));\n    }\n\n    #[test]\n    fn test_file_read_error_display() {\n        let error = InfrastructureError::FileReadError {\n            path: \"/path/to/file.txt\".to_string(),\n            details: \"Permission denied\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Error reading file at path '/path/to/file.txt'\"));\n        assert!(display.contains(\"Permission denied\"));\n    }\n\n    #[test]\n    fn test_file_write_error_display() {\n        let error = InfrastructureError::FileWriteError {\n            path: \"/path/to/file.txt\".to_string(),\n            details: \"Disk full\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Error writing file at path '/path/to/file.txt'\"));\n        assert!(display.contains(\"Disk full\"));\n    }\n\n    #[test]\n    fn test_file_parse_error_display() {\n        let error = InfrastructureError::FileParseError {\n            path: \"/path/to/file.yaml\".to_string(),\n            format: \"YAML\".to_string(),\n            details: \"Invalid syntax\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Error parsing YAML file at path '/path/to/file.yaml'\"));\n        assert!(display.contains(\"Invalid syntax\"));\n    }\n\n    #[test]\n    fn test_directory_not_found_error_display() {\n        let error = InfrastructureError::DirectoryNotFound {\n            path: \"/path/to/dir\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Directory not found at path '/path/to/dir'\"));\n    }\n\n    #[test]\n    fn test_directory_create_error_display() {\n        let error = InfrastructureError::DirectoryCreateError {\n            path: \"/path/to/dir\".to_string(),\n            details: \"Permission denied\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Error creating directory at path '/path/to/dir'\"));\n        assert!(display.contains(\"Permission denied\"));\n    }\n\n    #[test]\n    fn test_path_invalid_error_display() {\n        let error = InfrastructureError::PathInvalid {\n            path: \"/invalid/path\".to_string(),\n            reason: \"Contains invalid characters\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Invalid path '/invalid/path'\"));\n        assert!(display.contains(\"Contains invalid characters\"));\n    }\n\n    #[test]\n    fn test_serialization_error_display() {\n        let error = InfrastructureError::SerializationError {\n            format: \"JSON\".to_string(),\n            details: \"Invalid data structure\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Serialization error for format 'JSON'\"));\n        assert!(display.contains(\"Invalid data structure\"));\n    }\n\n    #[test]\n    fn test_deserialization_error_display() {\n        let error = InfrastructureError::DeserializationError {\n            format: \"XML\".to_string(),\n            details: \"Malformed XML\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Deserialization error for format 'XML'\"));\n        assert!(display.contains(\"Malformed XML\"));\n    }\n\n    #[test]\n    fn test_network_error_display() {\n        let error = InfrastructureError::NetworkError {\n            operation: \"HTTP request\".to_string(),\n            details: \"Connection timeout\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Network error during HTTP request\"));\n        assert!(display.contains(\"Connection timeout\"));\n    }\n\n    #[test]\n    fn test_database_error_display() {\n        let error = InfrastructureError::DatabaseError {\n            operation: \"SELECT query\".to_string(),\n            details: \"Connection lost\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Database error during SELECT query\"));\n        assert!(display.contains(\"Connection lost\"));\n    }\n\n    #[test]\n    fn test_cache_error_display() {\n        let error = InfrastructureError::CacheError {\n            operation: \"GET operation\".to_string(),\n            details: \"Cache miss\".to_string(),\n        };\n        let display = format!(\"{}\", error);\n        assert!(display.contains(\"Cache error during GET operation\"));\n        assert!(display.contains(\"Cache miss\"));\n    }\n\n    #[test]\n    fn test_error_debug_formatting() {\n        let error = InfrastructureError::FileNotFound {\n            path: \"/test/path\".to_string(),\n        };\n        let debug = format!(\"{:?}\", error);\n        assert!(debug.contains(\"FileNotFound\"));\n        assert!(debug.contains(\"/test/path\"));\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_file_not_found() {\n        let infra_error = InfrastructureError::FileNotFound {\n            path: \"/test/path\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::Io { operation, path } = domain_error.kind() {\n            assert_eq!(operation, \"file read\");\n            assert_eq!(path, \u0026Some(\"/test/path\".to_string()));\n        } else {\n            panic!(\"Expected Io error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_file_read_error() {\n        let infra_error = InfrastructureError::FileReadError {\n            path: \"/test/path\".to_string(),\n            details: \"Permission denied\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::Io { operation, path } = domain_error.kind() {\n            assert_eq!(operation, \"file read\");\n            assert_eq!(path, \u0026Some(\"/test/path\".to_string()));\n        } else {\n            panic!(\"Expected Io error kind\");\n        }\n\n        assert_eq!(domain_error.context(), Some(\u0026\"Permission denied\".to_string()));\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_file_write_error() {\n        let infra_error = InfrastructureError::FileWriteError {\n            path: \"/test/path\".to_string(),\n            details: \"Disk full\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::Io { operation, path } = domain_error.kind() {\n            assert_eq!(operation, \"file write\");\n            assert_eq!(path, \u0026Some(\"/test/path\".to_string()));\n        } else {\n            panic!(\"Expected Io error kind\");\n        }\n\n        assert_eq!(domain_error.context(), Some(\u0026\"Disk full\".to_string()));\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_file_parse_error() {\n        let infra_error = InfrastructureError::FileParseError {\n            path: \"/test/path.yaml\".to_string(),\n            format: \"YAML\".to_string(),\n            details: \"Invalid syntax\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::Serialization { format, details } = domain_error.kind() {\n            assert_eq!(format, \"YAML\");\n            assert!(details.contains(\"Parse error at path '/test/path.yaml'\"));\n            assert!(details.contains(\"Invalid syntax\"));\n        } else {\n            panic!(\"Expected Serialization error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_directory_not_found() {\n        let infra_error = InfrastructureError::DirectoryNotFound {\n            path: \"/test/dir\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::Io { operation, path } = domain_error.kind() {\n            assert_eq!(operation, \"directory access\");\n            assert_eq!(path, \u0026Some(\"/test/dir\".to_string()));\n        } else {\n            panic!(\"Expected Io error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_directory_create_error() {\n        let infra_error = InfrastructureError::DirectoryCreateError {\n            path: \"/test/dir\".to_string(),\n            details: \"Permission denied\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::Io { operation, path } = domain_error.kind() {\n            assert_eq!(operation, \"directory creation\");\n            assert_eq!(path, \u0026Some(\"/test/dir\".to_string()));\n        } else {\n            panic!(\"Expected Io error kind\");\n        }\n\n        assert_eq!(domain_error.context(), Some(\u0026\"Permission denied\".to_string()));\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_path_invalid() {\n        let infra_error = InfrastructureError::PathInvalid {\n            path: \"/invalid/path\".to_string(),\n            reason: \"Contains invalid characters\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::ValidationError { field, message } = domain_error.kind() {\n            assert_eq!(field, \"path\");\n            assert!(message.contains(\"Path '/invalid/path' is invalid\"));\n            assert!(message.contains(\"Contains invalid characters\"));\n        } else {\n            panic!(\"Expected ValidationError error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_serialization_error() {\n        let infra_error = InfrastructureError::SerializationError {\n            format: \"JSON\".to_string(),\n            details: \"Invalid data structure\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::Serialization { format, details } = domain_error.kind() {\n            assert_eq!(format, \"JSON\");\n            assert_eq!(details, \"Invalid data structure\");\n        } else {\n            panic!(\"Expected Serialization error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_deserialization_error() {\n        let infra_error = InfrastructureError::DeserializationError {\n            format: \"XML\".to_string(),\n            details: \"Malformed XML\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::Serialization { format, details } = domain_error.kind() {\n            assert_eq!(format, \"XML\");\n            assert_eq!(details, \"Malformed XML\");\n        } else {\n            panic!(\"Expected Serialization error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_network_error() {\n        let infra_error = InfrastructureError::NetworkError {\n            operation: \"HTTP request\".to_string(),\n            details: \"Connection timeout\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::RepositoryError { operation, details } = domain_error.kind() {\n            assert_eq!(operation, \"HTTP request\");\n            assert_eq!(details, \"Connection timeout\");\n        } else {\n            panic!(\"Expected RepositoryError error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_database_error() {\n        let infra_error = InfrastructureError::DatabaseError {\n            operation: \"SELECT query\".to_string(),\n            details: \"Connection lost\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::RepositoryError { operation, details } = domain_error.kind() {\n            assert_eq!(operation, \"SELECT query\");\n            assert_eq!(details, \"Connection lost\");\n        } else {\n            panic!(\"Expected RepositoryError error kind\");\n        }\n    }\n\n    #[test]\n    fn test_from_infrastructure_error_to_domain_error_cache_error() {\n        let infra_error = InfrastructureError::CacheError {\n            operation: \"GET operation\".to_string(),\n            details: \"Cache miss\".to_string(),\n        };\n        let domain_error: DomainError = infra_error.into();\n\n        if let DomainErrorKind::RepositoryError { operation, details } = domain_error.kind() {\n            assert_eq!(operation, \"GET operation\");\n            assert_eq!(details, \"Cache miss\");\n        } else {\n            panic!(\"Expected RepositoryError error kind\");\n        }\n    }\n\n    #[test]\n    fn test_infrastructure_result_success() {\n        let result: InfrastructureResult\u003cString\u003e = Ok(\"success\".to_string());\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"success\");\n    }\n\n    #[test]\n    fn test_infrastructure_result_failure() {\n        let result: InfrastructureResult\u003cString\u003e = Err(InfrastructureError::FileNotFound {\n            path: \"/test/path\".to_string(),\n        });\n        assert!(result.is_err());\n\n        if let Err(InfrastructureError::FileNotFound { path }) = result {\n            assert_eq!(path, \"/test/path\");\n        } else {\n            panic!(\"Expected FileNotFound error\");\n        }\n    }\n}\n","traces":[{"line":58,"address":[913504],"length":1,"stats":{"Line":7}},{"line":59,"address":[913537],"length":1,"stats":{"Line":3}},{"line":60,"address":[913602],"length":1,"stats":{"Line":1}},{"line":61,"address":[913611],"length":1,"stats":{"Line":1}},{"line":63,"address":[913701],"length":1,"stats":{"Line":1}},{"line":64,"address":[913728],"length":1,"stats":{"Line":1}},{"line":66,"address":[913931],"length":1,"stats":{"Line":1}},{"line":67,"address":[913958],"length":1,"stats":{"Line":1}},{"line":69,"address":[914161],"length":1,"stats":{"Line":1}},{"line":70,"address":[914196],"length":1,"stats":{"Line":1}},{"line":72,"address":[914469],"length":1,"stats":{"Line":1}},{"line":73,"address":[914481],"length":1,"stats":{"Line":1}},{"line":75,"address":[914598],"length":1,"stats":{"Line":1}},{"line":76,"address":[914625],"length":1,"stats":{"Line":1}},{"line":78,"address":[914828],"length":1,"stats":{"Line":1}},{"line":79,"address":[914855],"length":1,"stats":{"Line":1}},{"line":81,"address":[915058],"length":1,"stats":{"Line":1}},{"line":82,"address":[915085],"length":1,"stats":{"Line":1}},{"line":84,"address":[915288],"length":1,"stats":{"Line":1}},{"line":85,"address":[915315],"length":1,"stats":{"Line":1}},{"line":87,"address":[915518],"length":1,"stats":{"Line":1}},{"line":88,"address":[915545],"length":1,"stats":{"Line":1}},{"line":90,"address":[915748],"length":1,"stats":{"Line":1}},{"line":91,"address":[915775],"length":1,"stats":{"Line":1}},{"line":93,"address":[915978],"length":1,"stats":{"Line":1}},{"line":94,"address":[916005],"length":1,"stats":{"Line":1}},{"line":103,"address":[3077896,3075792,3077867],"length":1,"stats":{"Line":1}},{"line":104,"address":[3075813],"length":1,"stats":{"Line":1}},{"line":105,"address":[3075941,3077776],"length":1,"stats":{"Line":2}},{"line":106,"address":[3075967],"length":1,"stats":{"Line":1}},{"line":107,"address":[3077710],"length":1,"stats":{"Line":1}},{"line":109,"address":[3076002,3078015],"length":1,"stats":{"Line":2}},{"line":110,"address":[3076066],"length":1,"stats":{"Line":1}},{"line":111,"address":[3077943],"length":1,"stats":{"Line":1}},{"line":113,"address":[3078119,3077902],"length":1,"stats":{"Line":1}},{"line":114,"address":[3076104,3078372],"length":1,"stats":{"Line":2}},{"line":115,"address":[3076168],"length":1,"stats":{"Line":1}},{"line":116,"address":[3078300],"length":1,"stats":{"Line":1}},{"line":118,"address":[3078259,3078476],"length":1,"stats":{"Line":1}},{"line":119,"address":[3076206],"length":1,"stats":{"Line":1}},{"line":120,"address":[3078808],"length":1,"stats":{"Line":1}},{"line":121,"address":[3076277],"length":1,"stats":{"Line":1}},{"line":122,"address":[3078660,3076317],"length":1,"stats":{"Line":2}},{"line":125,"address":[3076375,3079140],"length":1,"stats":{"Line":2}},{"line":126,"address":[3076407],"length":1,"stats":{"Line":1}},{"line":127,"address":[3079068],"length":1,"stats":{"Line":1}},{"line":129,"address":[3076445,3079379],"length":1,"stats":{"Line":2}},{"line":130,"address":[3076509],"length":1,"stats":{"Line":1}},{"line":131,"address":[3079307],"length":1,"stats":{"Line":1}},{"line":133,"address":[3079483,3079266],"length":1,"stats":{"Line":1}},{"line":134,"address":[3079915,3076547],"length":1,"stats":{"Line":2}},{"line":135,"address":[3076595],"length":1,"stats":{"Line":1}},{"line":136,"address":[3079675,3079767],"length":1,"stats":{"Line":2}},{"line":138,"address":[3076638],"length":1,"stats":{"Line":1}},{"line":139,"address":[3076710],"length":1,"stats":{"Line":1}},{"line":141,"address":[3076845],"length":1,"stats":{"Line":1}},{"line":142,"address":[3076917],"length":1,"stats":{"Line":1}},{"line":144,"address":[3077052],"length":1,"stats":{"Line":1}},{"line":145,"address":[3077124],"length":1,"stats":{"Line":1}},{"line":147,"address":[3077259],"length":1,"stats":{"Line":1}},{"line":148,"address":[3077331],"length":1,"stats":{"Line":1}},{"line":150,"address":[3077466],"length":1,"stats":{"Line":1}},{"line":151,"address":[3077538],"length":1,"stats":{"Line":1}}],"covered":63,"coverable":63},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","mod.rs"],"content":"pub mod errors;\npub mod persistence;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","persistence","config_repository.rs"],"content":"use crate::domain::{\n    company_settings::{Config, repository::ConfigRepository},\n    shared::{\n        convertable::Convertible,\n        errors::{DomainError, DomainErrorKind},\n    },\n};\nuse crate::infrastructure::persistence::manifests::config_manifest::ConfigManifest;\nuse serde_yaml::to_string;\nuse std::{fs, path::PathBuf};\n\npub struct FileConfigRepository {\n    base_path: PathBuf,\n}\n\nimpl FileConfigRepository {\n    pub fn new() -\u003e Self {\n        Self {\n            base_path: PathBuf::from(\".\"),\n        }\n    }\n\n    pub fn with_base_path(path: PathBuf) -\u003e Self {\n        Self { base_path: path }\n    }\n}\n\nimpl Default for FileConfigRepository {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl ConfigRepository for FileConfigRepository {\n    fn save(\u0026self, config: ConfigManifest, path: PathBuf) -\u003e Result\u003c(), DomainError\u003e {\n        let config_yaml =\n            to_string(\u0026config).map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n        let file = path.join(\"config.yaml\");\n        fs::write(file, config_yaml)\n            .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n        Ok(())\n    }\n\n    fn create_repository_dir(\u0026self, path: PathBuf) -\u003e Result\u003c(), DomainError\u003e {\n        if !path.exists() {\n            fs::create_dir(path).map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n            println!(\"Criado o repositório de configurações.\");\n        }\n        Ok(())\n    }\n\n    fn load(\u0026self) -\u003e Result\u003c(Config, PathBuf), DomainError\u003e {\n        let mut current_path = self\n            .base_path\n            .canonicalize()\n            .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n\n        loop {\n            let config_path = current_path.join(\"config.yaml\");\n\n            if config_path.exists() {\n                let file_content = fs::read_to_string(\u0026config_path)\n                    .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n                let manifest: ConfigManifest = serde_yaml::from_str(\u0026file_content)\n                    .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n\n                return Ok((manifest.to(), current_path));\n            }\n\n            if !current_path.pop() {\n                break;\n            }\n        }\n\n        Err(DomainError::new(DomainErrorKind::Generic {\n            message: \"Não foi possível encontrar o arquivo 'config.yaml' nos diretórios pais.\".to_string(),\n        }))\n    }\n}\n","traces":[{"line":17,"address":[3120560],"length":1,"stats":{"Line":0}},{"line":19,"address":[3120573],"length":1,"stats":{"Line":0}},{"line":23,"address":[3120640],"length":1,"stats":{"Line":1}},{"line":29,"address":[3120672],"length":1,"stats":{"Line":0}},{"line":30,"address":[3120680],"length":1,"stats":{"Line":0}},{"line":35,"address":[3121555,3120704,3121575],"length":1,"stats":{"Line":0}},{"line":36,"address":[2808176,2808144],"length":1,"stats":{"Line":0}},{"line":38,"address":[3121061,3121129],"length":1,"stats":{"Line":0}},{"line":39,"address":[3121161,3121259,3121395,3121510],"length":1,"stats":{"Line":0}},{"line":40,"address":[2808326,2808304],"length":1,"stats":{"Line":0}},{"line":41,"address":[3121427],"length":1,"stats":{"Line":0}},{"line":44,"address":[3122084,3121600,3122113],"length":1,"stats":{"Line":0}},{"line":45,"address":[3121638,3121722],"length":1,"stats":{"Line":0}},{"line":46,"address":[2808480,2808502],"length":1,"stats":{"Line":0}},{"line":47,"address":[3122006],"length":1,"stats":{"Line":0}},{"line":49,"address":[3121804],"length":1,"stats":{"Line":0}},{"line":52,"address":[3122128,3123844,3123776],"length":1,"stats":{"Line":1}},{"line":53,"address":[3122296,3122216,3122166],"length":1,"stats":{"Line":2}},{"line":56,"address":[2808656,2808678],"length":1,"stats":{"Line":1}},{"line":59,"address":[3122433,3122501],"length":1,"stats":{"Line":2}},{"line":61,"address":[3122541,3122609],"length":1,"stats":{"Line":2}},{"line":62,"address":[3122947,3123083,3122669,3123803],"length":1,"stats":{"Line":2}},{"line":63,"address":[2808854,2808832],"length":1,"stats":{"Line":1}},{"line":64,"address":[3123450,3123180,3123259,3123305,3123782],"length":1,"stats":{"Line":3}},{"line":65,"address":[2809040,2809008],"length":1,"stats":{"Line":1}},{"line":67,"address":[3123610,3123563],"length":1,"stats":{"Line":2}},{"line":70,"address":[3122630,3122683],"length":1,"stats":{"Line":0}},{"line":75,"address":[3122761],"length":1,"stats":{"Line":0}},{"line":76,"address":[3122730],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":29},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","persistence","manifests","config_manifest.rs"],"content":"use crate::domain::company_settings::Config;\nuse crate::domain::shared::convertable::Convertible;\nuse crate::infrastructure::persistence::manifests::project_manifest::VacationRulesManifest;\nuse chrono::Utc;\nuse serde::{Deserialize, Serialize};\n\nconst API_VERSION: \u0026str = \"tasktaskrevolution.io/v1alpha1\";\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ConfigManifest {\n    pub api_version: String,\n    pub kind: String,\n    pub metadata: ConfigMetadata,\n    pub spec: ConfigSpec,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Default)]\n#[serde(rename_all = \"camelCase\")]\npub struct ConfigMetadata {\n    pub created_at: chrono::DateTime\u003cUtc\u003e,\n}\n\n#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Default)]\n#[serde(rename_all = \"camelCase\")]\npub struct ConfigSpec {\n    pub manager_name: String,\n    pub manager_email: String,\n    #[serde(default = \"default_timezone\")]\n    pub default_timezone: String,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub currency: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub work_hours_per_day: Option\u003cu8\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub work_days_per_week: Option\u003cVec\u003cString\u003e\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub date_format: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub default_task_duration: Option\u003cu8\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub locale: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub vacation_rules: Option\u003cVacationRulesManifest\u003e,\n}\n\nfn default_timezone() -\u003e String {\n    \"UTC\".to_string()\n}\n\nimpl ConfigManifest {\n    pub fn new() -\u003e Self {\n        ConfigManifest {\n            api_version: API_VERSION.to_string(),\n            kind: \"Config\".to_string(),\n            metadata: ConfigMetadata { created_at: Utc::now() },\n            spec: ConfigSpec {\n                manager_name: \"Default Manager\".to_string(),\n                manager_email: \"email@example.com\".to_string(),\n                default_timezone: \"UTC\".to_string(),\n                currency: None,\n                work_hours_per_day: None,\n                work_days_per_week: None,\n                date_format: None,\n                default_task_duration: None,\n                locale: None,\n                vacation_rules: None,\n            },\n        }\n    }\n}\n\nimpl Default for ConfigManifest {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Convertible\u003cConfig\u003e for ConfigManifest {\n    fn from(source: Config) -\u003e Self {\n        ConfigManifest {\n            api_version: API_VERSION.to_string(),\n            kind: \"Config\".to_string(),\n            metadata: ConfigMetadata { created_at: Utc::now() },\n            spec: ConfigSpec {\n                manager_name: source.manager_name,\n                manager_email: source.manager_email,\n                default_timezone: \"UTC\".to_string(),\n                currency: None,\n                work_hours_per_day: None,\n                work_days_per_week: None,\n                date_format: None,\n                default_task_duration: None,\n                locale: None,\n                vacation_rules: None,\n            },\n        }\n    }\n\n    fn to(\u0026self) -\u003e Config {\n        Config {\n            id: None,\n            manager_name: self.spec.manager_name.clone(),\n            manager_email: self.spec.manager_email.clone(),\n            default_timezone: self.spec.default_timezone.clone(),\n            company_name: None,\n            work_hours_start: None,\n            work_hours_end: None,\n            work_days: vec![],\n            created_at: Some(self.metadata.created_at),\n            updated_at: Some(self.metadata.created_at),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_deserialize_invalid_yaml() {\n        let yaml_str = \"invalid: - yaml: content\";\n        let manifest: Result\u003cConfigManifest, _\u003e = serde_yaml::from_str(yaml_str);\n        assert!(manifest.is_err());\n    }\n\n    #[test]\n    fn test_deserialize_valid_config() {\n        let yaml_str = r#\"\n            apiVersion: tasktaskrevolution.io/v1alpha1\n            kind: Config\n            metadata:\n                createdAt: \"2024-01-01T00:00:00Z\"\n            spec:\n                managerName: \"John Doe\"\n                managerEmail: \"john@doe.com\"\n                defaultTimezone: \"UTC\"\n        \"#;\n        let manifest: ConfigManifest = serde_yaml::from_str(yaml_str).unwrap();\n        assert_eq!(manifest.spec.manager_name, \"John Doe\");\n    }\n}\n","traces":[{"line":47,"address":[1693568],"length":1,"stats":{"Line":0}},{"line":48,"address":[1693576],"length":1,"stats":{"Line":0}},{"line":52,"address":[1694603,1694597,1693600],"length":1,"stats":{"Line":0}},{"line":54,"address":[1693616],"length":1,"stats":{"Line":0}},{"line":55,"address":[1693652],"length":1,"stats":{"Line":0}},{"line":56,"address":[1693714,1693768],"length":1,"stats":{"Line":0}},{"line":57,"address":[1694070],"length":1,"stats":{"Line":0}},{"line":74,"address":[1694624],"length":1,"stats":{"Line":0}},{"line":75,"address":[1694632],"length":1,"stats":{"Line":0}},{"line":80,"address":[1695875,1694656],"length":1,"stats":{"Line":2}},{"line":82,"address":[1694677],"length":1,"stats":{"Line":1}},{"line":83,"address":[1694781],"length":1,"stats":{"Line":2}},{"line":84,"address":[1694847,1694905],"length":1,"stats":{"Line":3}},{"line":85,"address":[1695142],"length":1,"stats":{"Line":1}},{"line":100,"address":[1696896,1696080,1696959],"length":1,"stats":{"Line":1}},{"line":103,"address":[1696125],"length":1,"stats":{"Line":1}},{"line":104,"address":[1696198],"length":1,"stats":{"Line":1}},{"line":105,"address":[1696268],"length":1,"stats":{"Line":1}},{"line":109,"address":[1696375],"length":1,"stats":{"Line":1}},{"line":110,"address":[1696441],"length":1,"stats":{"Line":1}},{"line":111,"address":[1696499],"length":1,"stats":{"Line":1}}],"covered":12,"coverable":21},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","persistence","manifests","mod.rs"],"content":"pub mod config_manifest;\npub mod project_manifest;\npub mod resource_manifest;\npub mod task_manifest;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","persistence","manifests","project_manifest.rs"],"content":"use crate::domain::project_management::{\n    AnyProject,\n    layoff_period::LayoffPeriod,\n    project::Project,\n    state::{Cancelled, Completed, InProgress, Planned},\n    vacation_rules::VacationRules,\n};\nuse serde::{Deserialize, Serialize};\nuse std::convert::TryFrom;\nuse std::str::FromStr;\nuse uuid7::{Uuid, uuid7};\n\nconst API_VERSION: \u0026str = \"tasktaskrevolution.io/v1alpha1\";\n\n#[derive(Serialize, Deserialize, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProjectManifest {\n    pub api_version: String,\n    pub kind: String,\n    pub metadata: ProjectMetadata,\n    pub spec: ProjectSpec,\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProjectMetadata {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub id: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub code: Option\u003cString\u003e,\n    pub name: String,\n    #[serde(default)]\n    pub description: String,\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProjectSpec {\n    pub timezone: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub start_date: Option\u003cString\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub end_date: Option\u003cString\u003e,\n    pub status: ProjectStatusManifest,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub vacation_rules: Option\u003cVacationRulesManifest\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct VacationRulesManifest {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_concurrent_vacations: Option\u003cu32\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub allow_layoff_vacations: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub require_layoff_vacation_period: Option\u003cbool\u003e,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub layoff_periods: Option\u003cVec\u003cLayoffPeriodManifest\u003e\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct LayoffPeriodManifest {\n    pub start_date: String,\n    pub end_date: String,\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq)]\npub enum ProjectStatusManifest {\n    Planned,\n    InProgress,\n    Completed,\n    Cancelled,\n}\n\nimpl From\u003cAnyProject\u003e for ProjectManifest {\n    fn from(source: AnyProject) -\u003e Self {\n        let (id, code, name, description, start_date, end_date, vacation_rules, timezone, status_manifest) =\n            match source {\n                AnyProject::Planned(p) =\u003e (\n                    p.id,\n                    p.code,\n                    p.name,\n                    p.description,\n                    p.start_date,\n                    p.end_date,\n                    p.vacation_rules,\n                    p.timezone,\n                    ProjectStatusManifest::Planned,\n                ),\n                AnyProject::InProgress(p) =\u003e (\n                    p.id,\n                    p.code,\n                    p.name,\n                    p.description,\n                    p.start_date,\n                    p.end_date,\n                    p.vacation_rules,\n                    p.timezone,\n                    ProjectStatusManifest::InProgress,\n                ),\n                AnyProject::Completed(p) =\u003e (\n                    p.id,\n                    p.code,\n                    p.name,\n                    p.description,\n                    p.start_date,\n                    p.end_date,\n                    p.vacation_rules,\n                    p.timezone,\n                    ProjectStatusManifest::Completed,\n                ),\n                AnyProject::Cancelled(p) =\u003e (\n                    p.id,\n                    p.code,\n                    p.name,\n                    p.description,\n                    p.start_date,\n                    p.end_date,\n                    p.vacation_rules,\n                    p.timezone,\n                    ProjectStatusManifest::Cancelled,\n                ),\n            };\n\n        ProjectManifest {\n            api_version: API_VERSION.to_string(),\n            kind: \"Project\".to_string(),\n            metadata: ProjectMetadata {\n                id: Some(id.to_string()),\n                code: Some(code),\n                name,\n                description: description.unwrap_or_default(),\n            },\n            spec: ProjectSpec {\n                timezone,\n                start_date,\n                end_date,\n                status: status_manifest,\n                vacation_rules: vacation_rules.map(VacationRulesManifest::from),\n            },\n        }\n    }\n}\n\nimpl TryFrom\u003cProjectManifest\u003e for AnyProject {\n    type Error = String;\n\n    fn try_from(manifest: ProjectManifest) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let id = manifest\n            .metadata\n            .id\n            .map(|id_str| Uuid::from_str(\u0026id_str))\n            .transpose()\n            .map_err(|e| e.to_string())?\n            .unwrap_or_else(uuid7);\n\n        let code = manifest.metadata.code.ok_or(\"Project code is missing in manifest\")?;\n        let name = manifest.metadata.name;\n        let description = if manifest.metadata.description.is_empty() {\n            None\n        } else {\n            Some(manifest.metadata.description)\n        };\n        let start_date = manifest.spec.start_date;\n        let end_date = manifest.spec.end_date;\n        let vacation_rules = manifest.spec.vacation_rules.map(|vr| vr.to());\n        let timezone = manifest.spec.timezone;\n\n        match manifest.spec.status {\n            ProjectStatusManifest::Planned =\u003e Ok(AnyProject::Planned(Project {\n                id,\n                code,\n                name,\n                description,\n                start_date,\n                end_date,\n                vacation_rules,\n                timezone,\n                tasks: std::collections::HashMap::new(),\n                state: Planned,\n            })),\n            ProjectStatusManifest::InProgress =\u003e Ok(AnyProject::InProgress(Project {\n                id,\n                code,\n                name,\n                description,\n                start_date,\n                end_date,\n                vacation_rules,\n                timezone,\n                tasks: std::collections::HashMap::new(),\n                state: InProgress,\n            })),\n            ProjectStatusManifest::Completed =\u003e Ok(AnyProject::Completed(Project {\n                id,\n                code,\n                name,\n                description,\n                start_date,\n                end_date,\n                vacation_rules,\n                timezone,\n                tasks: std::collections::HashMap::new(),\n                state: Completed,\n            })),\n            ProjectStatusManifest::Cancelled =\u003e Ok(AnyProject::Cancelled(Project {\n                id,\n                code,\n                name,\n                description,\n                start_date,\n                end_date,\n                vacation_rules,\n                timezone,\n                tasks: std::collections::HashMap::new(),\n                state: Cancelled,\n            })),\n        }\n    }\n}\n\nimpl From\u003cVacationRules\u003e for VacationRulesManifest {\n    fn from(source: VacationRules) -\u003e Self {\n        VacationRulesManifest {\n            max_concurrent_vacations: source.max_concurrent_vacations,\n            allow_layoff_vacations: source.allow_layoff_vacations,\n            require_layoff_vacation_period: source.require_layoff_vacation_period,\n            layoff_periods: source\n                .layoff_periods\n                .map(|periods| periods.into_iter().map(LayoffPeriodManifest::from).collect()),\n        }\n    }\n}\n\nimpl VacationRulesManifest {\n    pub fn to(\u0026self) -\u003e VacationRules {\n        VacationRules {\n            max_concurrent_vacations: self.max_concurrent_vacations,\n            allow_layoff_vacations: self.allow_layoff_vacations,\n            require_layoff_vacation_period: self.require_layoff_vacation_period,\n            layoff_periods: self\n                .layoff_periods\n                .as_ref()\n                .map(|periods| periods.iter().map(|period| period.to()).collect()),\n        }\n    }\n}\n\nimpl From\u003cLayoffPeriod\u003e for LayoffPeriodManifest {\n    fn from(source: LayoffPeriod) -\u003e Self {\n        LayoffPeriodManifest {\n            start_date: source.start_date,\n            end_date: source.end_date,\n        }\n    }\n}\n\nimpl LayoffPeriodManifest {\n    pub fn to(\u0026self) -\u003e LayoffPeriod {\n        LayoffPeriod {\n            start_date: self.start_date.clone(),\n            end_date: self.end_date.clone(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::project_management::builder::ProjectBuilder;\n\n    #[test]\n    fn test_bidirectional_conversion() {\n        // Create a Planned project\n        let original_project = ProjectBuilder::new(\"Test Project\".to_string())\n            .code(\"proj-1\".to_string())\n            .build();\n        let original_any = AnyProject::from(original_project.clone());\n\n        // Convert to Manifest\n        let manifest = ProjectManifest::from(original_any);\n        assert_eq!(manifest.metadata.name, \"Test Project\");\n        assert_eq!(manifest.spec.status, ProjectStatusManifest::Planned);\n\n        // Convert back to AnyProject\n        let converted_any = AnyProject::try_from(manifest).unwrap();\n        assert!(matches!(converted_any, AnyProject::Planned(_)));\n\n        if let AnyProject::Planned(converted) = converted_any {\n            assert_eq!(original_project.name, converted.name);\n            assert_eq!(original_project.id, converted.id);\n        }\n    }\n}\n","traces":[{"line":78,"address":[277664,282404,282686],"length":1,"stats":{"Line":1}},{"line":79,"address":[280888],"length":1,"stats":{"Line":1}},{"line":81,"address":[277778,278161],"length":1,"stats":{"Line":2}},{"line":82,"address":[277800],"length":1,"stats":{"Line":1}},{"line":83,"address":[277832],"length":1,"stats":{"Line":1}},{"line":84,"address":[277880],"length":1,"stats":{"Line":1}},{"line":85,"address":[277928],"length":1,"stats":{"Line":1}},{"line":86,"address":[277976],"length":1,"stats":{"Line":1}},{"line":87,"address":[278024],"length":1,"stats":{"Line":1}},{"line":88,"address":[278072],"length":1,"stats":{"Line":1}},{"line":89,"address":[278105],"length":1,"stats":{"Line":1}},{"line":90,"address":[278153],"length":1,"stats":{"Line":1}},{"line":92,"address":[278558,278941],"length":1,"stats":{"Line":2}},{"line":93,"address":[278580],"length":1,"stats":{"Line":1}},{"line":94,"address":[278612],"length":1,"stats":{"Line":1}},{"line":95,"address":[278660],"length":1,"stats":{"Line":1}},{"line":96,"address":[278708],"length":1,"stats":{"Line":1}},{"line":97,"address":[278756],"length":1,"stats":{"Line":1}},{"line":98,"address":[278804],"length":1,"stats":{"Line":1}},{"line":99,"address":[278852],"length":1,"stats":{"Line":1}},{"line":100,"address":[278885],"length":1,"stats":{"Line":1}},{"line":101,"address":[278933],"length":1,"stats":{"Line":1}},{"line":103,"address":[279338,279721],"length":1,"stats":{"Line":0}},{"line":104,"address":[279360],"length":1,"stats":{"Line":0}},{"line":105,"address":[279392],"length":1,"stats":{"Line":0}},{"line":106,"address":[279440],"length":1,"stats":{"Line":0}},{"line":107,"address":[279488],"length":1,"stats":{"Line":0}},{"line":108,"address":[279536],"length":1,"stats":{"Line":0}},{"line":109,"address":[279584],"length":1,"stats":{"Line":0}},{"line":110,"address":[279632],"length":1,"stats":{"Line":0}},{"line":111,"address":[279665],"length":1,"stats":{"Line":0}},{"line":112,"address":[279713],"length":1,"stats":{"Line":0}},{"line":114,"address":[280118,280501],"length":1,"stats":{"Line":0}},{"line":115,"address":[280140],"length":1,"stats":{"Line":0}},{"line":116,"address":[280172],"length":1,"stats":{"Line":0}},{"line":117,"address":[280220],"length":1,"stats":{"Line":0}},{"line":118,"address":[280268],"length":1,"stats":{"Line":0}},{"line":119,"address":[280316],"length":1,"stats":{"Line":0}},{"line":120,"address":[280364],"length":1,"stats":{"Line":0}},{"line":121,"address":[280412],"length":1,"stats":{"Line":0}},{"line":122,"address":[280445],"length":1,"stats":{"Line":0}},{"line":123,"address":[280493],"length":1,"stats":{"Line":0}},{"line":128,"address":[281203],"length":1,"stats":{"Line":1}},{"line":129,"address":[281275],"length":1,"stats":{"Line":1}},{"line":130,"address":[281651],"length":1,"stats":{"Line":1}},{"line":136,"address":[282026],"length":1,"stats":{"Line":1}},{"line":150,"address":[812141,814108,809136],"length":1,"stats":{"Line":1}},{"line":151,"address":[814421,809158,809500,809445],"length":1,"stats":{"Line":2}},{"line":154,"address":[809350],"length":1,"stats":{"Line":3}},{"line":156,"address":[809474,809428],"length":1,"stats":{"Line":1}},{"line":157,"address":[809579],"length":1,"stats":{"Line":1}},{"line":159,"address":[809611],"length":1,"stats":{"Line":1}},{"line":160,"address":[809872],"length":1,"stats":{"Line":1}},{"line":161,"address":[810083,809912,809972],"length":1,"stats":{"Line":3}},{"line":162,"address":[810085],"length":1,"stats":{"Line":1}},{"line":164,"address":[809983],"length":1,"stats":{"Line":1}},{"line":166,"address":[810116],"length":1,"stats":{"Line":2}},{"line":167,"address":[810162],"length":1,"stats":{"Line":2}},{"line":168,"address":[810208],"length":1,"stats":{"Line":1}},{"line":169,"address":[810330],"length":1,"stats":{"Line":2}},{"line":171,"address":[810368],"length":1,"stats":{"Line":2}},{"line":172,"address":[811637],"length":1,"stats":{"Line":1}},{"line":174,"address":[810401],"length":1,"stats":{"Line":1}},{"line":175,"address":[810441],"length":1,"stats":{"Line":1}},{"line":176,"address":[810481],"length":1,"stats":{"Line":1}},{"line":177,"address":[810521],"length":1,"stats":{"Line":1}},{"line":178,"address":[810561],"length":1,"stats":{"Line":1}},{"line":179,"address":[810601],"length":1,"stats":{"Line":1}},{"line":180,"address":[810649],"length":1,"stats":{"Line":1}},{"line":181,"address":[810689],"length":1,"stats":{"Line":1}},{"line":184,"address":[812304],"length":1,"stats":{"Line":1}},{"line":186,"address":[810699],"length":1,"stats":{"Line":1}},{"line":187,"address":[810739],"length":1,"stats":{"Line":1}},{"line":188,"address":[810779],"length":1,"stats":{"Line":1}},{"line":189,"address":[810819],"length":1,"stats":{"Line":1}},{"line":190,"address":[810859],"length":1,"stats":{"Line":1}},{"line":191,"address":[810899],"length":1,"stats":{"Line":1}},{"line":192,"address":[810947],"length":1,"stats":{"Line":1}},{"line":193,"address":[810987],"length":1,"stats":{"Line":1}},{"line":196,"address":[812911],"length":1,"stats":{"Line":0}},{"line":198,"address":[810997],"length":1,"stats":{"Line":0}},{"line":199,"address":[811037],"length":1,"stats":{"Line":0}},{"line":200,"address":[811077],"length":1,"stats":{"Line":0}},{"line":201,"address":[811117],"length":1,"stats":{"Line":0}},{"line":202,"address":[811157],"length":1,"stats":{"Line":0}},{"line":203,"address":[811197],"length":1,"stats":{"Line":0}},{"line":204,"address":[811245],"length":1,"stats":{"Line":0}},{"line":205,"address":[811285],"length":1,"stats":{"Line":0}},{"line":208,"address":[813518],"length":1,"stats":{"Line":0}},{"line":210,"address":[811295],"length":1,"stats":{"Line":0}},{"line":211,"address":[811335],"length":1,"stats":{"Line":0}},{"line":212,"address":[811375],"length":1,"stats":{"Line":0}},{"line":213,"address":[811415],"length":1,"stats":{"Line":0}},{"line":214,"address":[811455],"length":1,"stats":{"Line":0}},{"line":215,"address":[811495],"length":1,"stats":{"Line":0}},{"line":216,"address":[811543],"length":1,"stats":{"Line":0}},{"line":217,"address":[811583],"length":1,"stats":{"Line":0}},{"line":225,"address":[282720],"length":1,"stats":{"Line":0}},{"line":227,"address":[282734],"length":1,"stats":{"Line":0}},{"line":228,"address":[282748],"length":1,"stats":{"Line":0}},{"line":229,"address":[282755],"length":1,"stats":{"Line":0}},{"line":230,"address":[282762],"length":1,"stats":{"Line":0}},{"line":238,"address":[282880],"length":1,"stats":{"Line":0}},{"line":240,"address":[282910],"length":1,"stats":{"Line":0}},{"line":241,"address":[282924],"length":1,"stats":{"Line":0}},{"line":242,"address":[282931],"length":1,"stats":{"Line":0}},{"line":252,"address":[283040],"length":1,"stats":{"Line":0}},{"line":254,"address":[283043],"length":1,"stats":{"Line":0}},{"line":255,"address":[283069],"length":1,"stats":{"Line":0}},{"line":261,"address":[283330,283336,283152],"length":1,"stats":{"Line":0}},{"line":263,"address":[283175],"length":1,"stats":{"Line":0}},{"line":264,"address":[283211],"length":1,"stats":{"Line":0}}],"covered":59,"coverable":112},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","persistence","manifests","resource_manifest.rs"],"content":"use chrono::{DateTime, Local};\nuse serde::{Deserialize, Serialize};\nuse std::str::FromStr;\nuse uuid7::Uuid;\n\nuse crate::domain::resource_management::{\n    AnyResource,\n    resource::{Period, PeriodType, ProjectAssignment, Resource, TimeOffEntry},\n    state::{Assigned, Available},\n};\n\nconst API_VERSION: \u0026str = \"tasktaskrevolution.io/v1alpha1\";\n\n#[derive(Serialize, Deserialize, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ResourceManifest {\n    pub api_version: String,\n    pub kind: String,\n    pub metadata: ResourceMetadata,\n    pub spec: ResourceSpec,\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, Default)]\n#[serde(rename_all = \"camelCase\")]\npub struct ResourceSpec {\n    pub vacations: Option\u003cVec\u003cPeriodManifest\u003e\u003e,\n    pub project_assignments: Option\u003cVec\u003cProjectAssignmentManifest\u003e\u003e,\n    pub time_off_balance: u32,\n    #[serde(default)]\n    pub time_off_history: Option\u003cVec\u003cTimeOffEntry\u003e\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct ResourceMetadata {\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub id: Option\u003cString\u003e,\n    pub name: String,\n    #[serde(default)]\n    pub email: String,\n    pub code: String,\n    pub resource_type: String,\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]\n#[serde(rename_all = \"camelCase\")]\npub struct ProjectAssignmentManifest {\n    pub project_id: String,\n    pub start_date: DateTime\u003cLocal\u003e,\n    pub end_date: DateTime\u003cLocal\u003e,\n    pub allocation_percentage: u8,\n}\n\nimpl From\u003cProjectAssignment\u003e for ProjectAssignmentManifest {\n    fn from(source: ProjectAssignment) -\u003e Self {\n        Self {\n            project_id: source.project_id,\n            start_date: source.start_date,\n            end_date: source.end_date,\n            allocation_percentage: source.allocation_percentage,\n        }\n    }\n}\nimpl ProjectAssignmentManifest {\n    pub fn to(\u0026self) -\u003e ProjectAssignment {\n        ProjectAssignment {\n            project_id: self.project_id.clone(),\n            start_date: self.start_date,\n            end_date: self.end_date,\n            allocation_percentage: self.allocation_percentage,\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct PeriodManifest {\n    pub start_date: DateTime\u003cLocal\u003e,\n    pub end_date: DateTime\u003cLocal\u003e,\n    pub approved: bool,\n    pub period_type: PeriodTypeManifest,\n    pub is_time_off_compensation: bool,\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub compensated_hours: Option\u003cu32\u003e,\n    pub is_layoff: bool,\n}\n\nimpl From\u003cPeriod\u003e for PeriodManifest {\n    fn from(source: Period) -\u003e Self {\n        Self {\n            start_date: source.start_date,\n            end_date: source.end_date,\n            approved: source.approved,\n            period_type: PeriodTypeManifest::from(source.period_type),\n            is_time_off_compensation: source.is_time_off_compensation,\n            compensated_hours: source.compensated_hours,\n            is_layoff: source.is_layoff,\n        }\n    }\n}\nimpl PeriodManifest {\n    pub fn to(\u0026self) -\u003e Period {\n        Period {\n            start_date: self.start_date,\n            end_date: self.end_date,\n            approved: self.approved,\n            period_type: self.period_type.to(),\n            is_time_off_compensation: self.is_time_off_compensation,\n            compensated_hours: self.compensated_hours,\n            is_layoff: self.is_layoff,\n        }\n    }\n}\n\n#[derive(Serialize, Deserialize, Debug, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub enum PeriodTypeManifest {\n    BirthdayBreak,\n    DayOff,\n    Vacation,\n    SickLeave,\n    PersonalLeave,\n    TimeOffCompensation,\n    TimeOff,\n}\n\nimpl From\u003cPeriodType\u003e for PeriodTypeManifest {\n    fn from(source: PeriodType) -\u003e Self {\n        match source {\n            PeriodType::BirthdayBreak =\u003e PeriodTypeManifest::BirthdayBreak,\n            PeriodType::DayOff =\u003e PeriodTypeManifest::DayOff,\n            PeriodType::Vacation =\u003e PeriodTypeManifest::Vacation,\n            PeriodType::SickLeave =\u003e PeriodTypeManifest::SickLeave,\n            PeriodType::PersonalLeave =\u003e PeriodTypeManifest::PersonalLeave,\n            PeriodType::TimeOffCompensation =\u003e PeriodTypeManifest::TimeOffCompensation,\n            PeriodType::TimeOff =\u003e PeriodTypeManifest::TimeOff,\n        }\n    }\n}\nimpl PeriodTypeManifest {\n    pub fn to(\u0026self) -\u003e PeriodType {\n        match self {\n            PeriodTypeManifest::BirthdayBreak =\u003e PeriodType::BirthdayBreak,\n            PeriodTypeManifest::DayOff =\u003e PeriodType::DayOff,\n            PeriodTypeManifest::Vacation =\u003e PeriodType::Vacation,\n            PeriodTypeManifest::SickLeave =\u003e PeriodType::SickLeave,\n            PeriodTypeManifest::PersonalLeave =\u003e PeriodType::PersonalLeave,\n            PeriodTypeManifest::TimeOffCompensation =\u003e PeriodType::TimeOffCompensation,\n            PeriodTypeManifest::TimeOff =\u003e PeriodType::TimeOff,\n        }\n    }\n}\n\nimpl From\u003cAnyResource\u003e for ResourceManifest {\n    fn from(source: AnyResource) -\u003e Self {\n        let (id, code, name, email, resource_type, spec) = match source {\n            AnyResource::Available(r) =\u003e (\n                r.id,\n                r.code,\n                r.name,\n                r.email,\n                r.resource_type,\n                ResourceSpec {\n                    vacations: r.vacations.map(|v| v.into_iter().map(PeriodManifest::from).collect()),\n                    project_assignments: None,\n                    time_off_balance: r.time_off_balance,\n                    time_off_history: r.time_off_history,\n                },\n            ),\n            AnyResource::Assigned(r) =\u003e (\n                r.id,\n                r.code,\n                r.name,\n                r.email,\n                r.resource_type,\n                ResourceSpec {\n                    vacations: r.vacations.map(|v| v.into_iter().map(PeriodManifest::from).collect()),\n                    project_assignments: Some(\n                        r.state\n                            .project_assignments\n                            .into_iter()\n                            .map(ProjectAssignmentManifest::from)\n                            .collect(),\n                    ),\n                    time_off_balance: r.time_off_balance,\n                    time_off_history: r.time_off_history,\n                },\n            ),\n            AnyResource::Inactive(r) =\u003e (\n                r.id,\n                r.code,\n                r.name,\n                r.email,\n                r.resource_type,\n                ResourceSpec {\n                    vacations: r.vacations.map(|v| v.into_iter().map(PeriodManifest::from).collect()),\n                    project_assignments: None,\n                    time_off_balance: r.time_off_balance,\n                    time_off_history: r.time_off_history,\n                },\n            ),\n        };\n\n        Self {\n            api_version: API_VERSION.to_string(),\n            kind: \"Resource\".to_string(),\n            metadata: ResourceMetadata {\n                id: Some(id.to_string()),\n                name,\n                email: email.unwrap_or_default(),\n                code,\n                resource_type,\n            },\n            spec,\n        }\n    }\n}\n\nimpl TryFrom\u003cResourceManifest\u003e for AnyResource {\n    type Error = String;\n\n    fn try_from(manifest: ResourceManifest) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let id = manifest\n            .metadata\n            .id\n            .and_then(|id_str| Uuid::from_str(\u0026id_str).ok())\n            .unwrap_or_else(uuid7::uuid7);\n\n        let code = manifest.metadata.code.clone();\n        let name = manifest.metadata.name.clone();\n        let email = if manifest.metadata.email.is_empty() {\n            None\n        } else {\n            Some(manifest.metadata.email.clone())\n        };\n        let resource_type = manifest.metadata.resource_type.clone();\n        let vacations = manifest\n            .spec\n            .vacations\n            .as_ref()\n            .map(|v| v.iter().map(|p| p.to()).collect());\n        let time_off_balance = manifest.spec.time_off_balance;\n        let time_off_history = manifest.spec.time_off_history.clone();\n\n        if let Some(assignments_manifest) = manifest.spec.project_assignments\n            \u0026\u0026 !assignments_manifest.is_empty()\n        {\n            let project_assignments = assignments_manifest.into_iter().map(|a| a.to()).collect();\n            return Ok(AnyResource::Assigned(Resource {\n                id,\n                code,\n                name,\n                email: None,                          // Email não está disponível no spec\n                resource_type: \"Unknown\".to_string(), // Tipo padrão\n                vacations,\n                time_off_balance: 0, // Valor padrão\n                time_off_history,\n                state: Assigned { project_assignments },\n            }));\n        }\n\n        // Default to Available\n        Ok(AnyResource::Available(Resource {\n            id,\n            code,\n            name,\n            email,\n            resource_type,\n            vacations,\n            time_off_balance,\n            time_off_history,\n            state: Available,\n        }))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::resource_management::state::Available;\n    use uuid7::uuid7;\n\n    #[test]\n    fn test_bidirectional_conversion() {\n        // Create an Available resource\n        let original_resource = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"John Doe\".to_string(),\n            Some(\"john@doe.com\".to_string()),\n            \"Developer\".to_string(),\n            None,\n            40,\n        );\n\n        // Convert to Manifest\n        let manifest = ResourceManifest::from(AnyResource::Available(original_resource.clone()));\n        assert_eq!(manifest.metadata.name, \"John Doe\");\n        assert_eq!(manifest.metadata.code, \"dev-1\");\n        assert_eq!(manifest.spec.time_off_balance, 40);\n        assert!(manifest.spec.project_assignments.is_none());\n\n        // Convert back to AnyResource\n        let converted_any = AnyResource::try_from(manifest).unwrap();\n\n        // Assert it's an Available resource with correct data\n        if let AnyResource::Available(converted) = converted_any {\n            assert_eq!(original_resource.id, converted.id);\n            assert_eq!(original_resource.code, converted.code);\n            assert_eq!(original_resource.name, converted.name);\n            assert_eq!(original_resource.email, converted.email);\n            assert_eq!(original_resource.time_off_balance, converted.time_off_balance);\n        } else {\n            panic!(\"Expected resource to be in Available state\");\n        }\n    }\n\n    #[test]\n    fn test_assigned_conversion() {\n        let resource = Resource::\u003cAvailable\u003e::new(\n            \"qa-1\".to_string(),\n            \"Jane Doe\".to_string(),\n            None,\n            \"QA\".to_string(),\n            None,\n            0,\n        );\n        let assignment = ProjectAssignment {\n            project_id: \"PROJ-1\".to_string(),\n            start_date: Local::now(),\n            end_date: Local::now(),\n            allocation_percentage: 100,\n        };\n        let assigned_resource = resource.assign_to_project(assignment);\n\n        let manifest = ResourceManifest::from(AnyResource::Assigned(assigned_resource));\n        assert!(manifest.spec.project_assignments.is_some());\n        assert_eq!(manifest.spec.project_assignments.as_ref().unwrap().len(), 1);\n\n        let converted_any = AnyResource::try_from(manifest).unwrap();\n        assert!(matches!(converted_any, AnyResource::Assigned(_)));\n    }\n\n    #[test]\n    fn test_inactive_conversion() {\n        // This test ensures that a manifest can be converted back and forth,\n        // even if the resource is conceptually \"inactive\". The state is determined\n        // by assignments, so a resource without assignments becomes \"Available\".\n        let id = uuid7();\n        let manifest = ResourceManifest {\n            api_version: API_VERSION.to_string(),\n            kind: \"Resource\".to_string(),\n            metadata: ResourceMetadata {\n                id: Some(id.to_string()),\n                name: \"Inactive User\".to_string(),\n                email: \"\".to_string(),\n                code: \"former-1\".to_string(),\n                resource_type: \"Former\".to_string(),\n            },\n            spec: ResourceSpec {\n                time_off_balance: 0,\n                ..Default::default()\n            },\n        };\n\n        let converted_any = AnyResource::try_from(manifest).unwrap();\n        // Currently defaults to Available, which is correct based on implementation.\n        assert!(matches!(converted_any, AnyResource::Available(_)));\n        if let AnyResource::Available(r) = converted_any {\n            assert_eq!(r.id, id);\n            assert_eq!(r.code, \"former-1\");\n        }\n    }\n\n    #[test]\n    fn test_conversion_with_vacations() {\n        let mut resource = Resource::\u003cAvailable\u003e::new(\n            \"manager-1\".to_string(),\n            \"On Holiday\".to_string(),\n            None,\n            \"Manager\".to_string(),\n            None,\n            80,\n        );\n\n        let vacation = Period {\n            start_date: Local::now(),\n            end_date: Local::now(),\n            approved: true,\n            period_type: PeriodType::Vacation,\n            is_time_off_compensation: false,\n            compensated_hours: None,\n            is_layoff: false,\n        };\n        resource.vacations = Some(vec![vacation]);\n\n        let manifest = ResourceManifest::from(AnyResource::Available(resource.clone()));\n        assert!(manifest.spec.vacations.is_some());\n        assert_eq!(manifest.spec.vacations.as_ref().unwrap().len(), 1);\n\n        let converted_any = AnyResource::try_from(manifest).unwrap();\n        if let AnyResource::Available(converted) = converted_any {\n            assert_eq!(converted.vacations.unwrap().len(), 1);\n        } else {\n            panic!(\"Expected Available state\");\n        }\n    }\n\n    #[test]\n    fn test_conversion_no_email() {\n        let original_resource = Resource::\u003cAvailable\u003e::new(\n            \"contractor-1\".to_string(),\n            \"No Email\".to_string(),\n            None, // No email\n            \"Contractor\".to_string(),\n            None,\n            0,\n        );\n\n        let manifest = ResourceManifest::from(AnyResource::Available(original_resource.clone()));\n        assert_eq!(manifest.metadata.email, \"\"); // Converts to empty string\n\n        let converted_any = AnyResource::try_from(manifest).unwrap();\n        if let AnyResource::Available(converted) = converted_any {\n            assert_eq!(converted.email, None); // Converts back to None\n        } else {\n            panic!(\"Expected Available state\");\n        }\n    }\n}\n","traces":[{"line":55,"address":[2591360],"length":1,"stats":{"Line":1}},{"line":57,"address":[2591363],"length":1,"stats":{"Line":1}},{"line":58,"address":[2591389],"length":1,"stats":{"Line":1}},{"line":59,"address":[2591407],"length":1,"stats":{"Line":1}},{"line":60,"address":[2591425],"length":1,"stats":{"Line":1}},{"line":65,"address":[2591504],"length":1,"stats":{"Line":1}},{"line":67,"address":[2591527],"length":1,"stats":{"Line":1}},{"line":68,"address":[2591559],"length":1,"stats":{"Line":1}},{"line":69,"address":[2591577],"length":1,"stats":{"Line":1}},{"line":70,"address":[2591595],"length":1,"stats":{"Line":1}},{"line":89,"address":[2591680],"length":1,"stats":{"Line":1}},{"line":91,"address":[2591699],"length":1,"stats":{"Line":1}},{"line":92,"address":[2591717],"length":1,"stats":{"Line":1}},{"line":93,"address":[2591735],"length":1,"stats":{"Line":1}},{"line":94,"address":[2591742],"length":1,"stats":{"Line":1}},{"line":95,"address":[2591774],"length":1,"stats":{"Line":1}},{"line":96,"address":[2591778],"length":1,"stats":{"Line":1}},{"line":97,"address":[2591783],"length":1,"stats":{"Line":1}},{"line":102,"address":[2591872],"length":1,"stats":{"Line":1}},{"line":104,"address":[2591902],"length":1,"stats":{"Line":1}},{"line":105,"address":[2591920],"length":1,"stats":{"Line":1}},{"line":106,"address":[2591938],"length":1,"stats":{"Line":1}},{"line":107,"address":[2591945],"length":1,"stats":{"Line":1}},{"line":108,"address":[2591976],"length":1,"stats":{"Line":1}},{"line":109,"address":[2591980],"length":1,"stats":{"Line":1}},{"line":110,"address":[2591985],"length":1,"stats":{"Line":1}},{"line":128,"address":[2592064],"length":1,"stats":{"Line":1}},{"line":129,"address":[2592071],"length":1,"stats":{"Line":1}},{"line":130,"address":[2592116],"length":1,"stats":{"Line":0}},{"line":131,"address":[2592123],"length":1,"stats":{"Line":0}},{"line":132,"address":[2592102],"length":1,"stats":{"Line":1}},{"line":133,"address":[2592130],"length":1,"stats":{"Line":0}},{"line":134,"address":[2592137],"length":1,"stats":{"Line":0}},{"line":135,"address":[2592144],"length":1,"stats":{"Line":0}},{"line":136,"address":[2592109],"length":1,"stats":{"Line":0}},{"line":141,"address":[2592160],"length":1,"stats":{"Line":1}},{"line":142,"address":[2592165],"length":1,"stats":{"Line":1}},{"line":143,"address":[2592196],"length":1,"stats":{"Line":0}},{"line":144,"address":[2592203],"length":1,"stats":{"Line":0}},{"line":145,"address":[2592210],"length":1,"stats":{"Line":1}},{"line":146,"address":[2592217],"length":1,"stats":{"Line":0}},{"line":147,"address":[2592224],"length":1,"stats":{"Line":0}},{"line":148,"address":[2592231],"length":1,"stats":{"Line":0}},{"line":149,"address":[2592238],"length":1,"stats":{"Line":0}},{"line":155,"address":[2593925,2592256,2593847],"length":1,"stats":{"Line":3}},{"line":156,"address":[2592277,2593591],"length":1,"stats":{"Line":6}},{"line":157,"address":[2593337,2592373],"length":1,"stats":{"Line":5}},{"line":158,"address":[2592399],"length":1,"stats":{"Line":3}},{"line":159,"address":[2592415],"length":1,"stats":{"Line":3}},{"line":160,"address":[2592447],"length":1,"stats":{"Line":3}},{"line":161,"address":[2592479],"length":1,"stats":{"Line":3}},{"line":162,"address":[2592511],"length":1,"stats":{"Line":3}},{"line":163,"address":[2593186],"length":1,"stats":{"Line":2}},{"line":164,"address":[2336493,2336480],"length":1,"stats":{"Line":5}},{"line":165,"address":[2593113],"length":1,"stats":{"Line":2}},{"line":166,"address":[2593131],"length":1,"stats":{"Line":2}},{"line":167,"address":[2593138],"length":1,"stats":{"Line":2}},{"line":170,"address":[2592605,2594382],"length":1,"stats":{"Line":2}},{"line":171,"address":[2592635],"length":1,"stats":{"Line":1}},{"line":172,"address":[2592651],"length":1,"stats":{"Line":1}},{"line":173,"address":[2592683],"length":1,"stats":{"Line":1}},{"line":174,"address":[2592715],"length":1,"stats":{"Line":1}},{"line":175,"address":[2592747],"length":1,"stats":{"Line":1}},{"line":176,"address":[2594231],"length":1,"stats":{"Line":1}},{"line":177,"address":[2336544,2336557],"length":1,"stats":{"Line":1}},{"line":178,"address":[2594128],"length":1,"stats":{"Line":1}},{"line":179,"address":[2593982],"length":1,"stats":{"Line":1}},{"line":181,"address":[2594038],"length":1,"stats":{"Line":1}},{"line":182,"address":[2594098],"length":1,"stats":{"Line":1}},{"line":183,"address":[2594121],"length":1,"stats":{"Line":1}},{"line":185,"address":[2594176],"length":1,"stats":{"Line":1}},{"line":186,"address":[2594183],"length":1,"stats":{"Line":1}},{"line":189,"address":[2595021,2592841],"length":1,"stats":{"Line":0}},{"line":190,"address":[2592867],"length":1,"stats":{"Line":0}},{"line":191,"address":[2592883],"length":1,"stats":{"Line":0}},{"line":192,"address":[2592915],"length":1,"stats":{"Line":0}},{"line":193,"address":[2592947],"length":1,"stats":{"Line":0}},{"line":194,"address":[2592979],"length":1,"stats":{"Line":0}},{"line":195,"address":[2594870],"length":1,"stats":{"Line":0}},{"line":196,"address":[2336608,2336621],"length":1,"stats":{"Line":0}},{"line":197,"address":[2594797],"length":1,"stats":{"Line":0}},{"line":198,"address":[2594815],"length":1,"stats":{"Line":0}},{"line":199,"address":[2594822],"length":1,"stats":{"Line":0}},{"line":205,"address":[2593813],"length":1,"stats":{"Line":2}},{"line":206,"address":[2595320],"length":1,"stats":{"Line":2}},{"line":207,"address":[2595714],"length":1,"stats":{"Line":2}},{"line":222,"address":[1802816,1805510],"length":1,"stats":{"Line":1}},{"line":223,"address":[1802838],"length":1,"stats":{"Line":1}},{"line":226,"address":[2336672,2336699],"length":1,"stats":{"Line":3}},{"line":227,"address":[1802969],"length":1,"stats":{"Line":1}},{"line":229,"address":[1802998],"length":1,"stats":{"Line":1}},{"line":230,"address":[1803041,1803117],"length":1,"stats":{"Line":2}},{"line":231,"address":[1803182,1803125,1803241],"length":1,"stats":{"Line":3}},{"line":232,"address":[1803223],"length":1,"stats":{"Line":1}},{"line":234,"address":[1803193,1803243],"length":1,"stats":{"Line":2}},{"line":236,"address":[1803296],"length":1,"stats":{"Line":1}},{"line":237,"address":[1803375],"length":1,"stats":{"Line":2}},{"line":241,"address":[2336912,2336832,2336862,2336947],"length":1,"stats":{"Line":6}},{"line":242,"address":[1803460],"length":1,"stats":{"Line":3}},{"line":243,"address":[1803477],"length":1,"stats":{"Line":3}},{"line":245,"address":[1803541],"length":1,"stats":{"Line":3}},{"line":246,"address":[1803636,1804232],"length":1,"stats":{"Line":2}},{"line":248,"address":[1804335,1804238],"length":1,"stats":{"Line":4}},{"line":249,"address":[1804666],"length":1,"stats":{"Line":1}},{"line":251,"address":[1804365],"length":1,"stats":{"Line":1}},{"line":252,"address":[1804405],"length":1,"stats":{"Line":1}},{"line":253,"address":[1804455],"length":1,"stats":{"Line":1}},{"line":254,"address":[1804463],"length":1,"stats":{"Line":1}},{"line":255,"address":[1804538],"length":1,"stats":{"Line":1}},{"line":257,"address":[1804570],"length":1,"stats":{"Line":1}},{"line":258,"address":[1804602],"length":1,"stats":{"Line":1}},{"line":263,"address":[1803862],"length":1,"stats":{"Line":3}},{"line":265,"address":[1803654],"length":1,"stats":{"Line":3}},{"line":266,"address":[1803694],"length":1,"stats":{"Line":3}},{"line":267,"address":[1803734],"length":1,"stats":{"Line":3}},{"line":268,"address":[1803766],"length":1,"stats":{"Line":3}},{"line":269,"address":[1803798],"length":1,"stats":{"Line":3}},{"line":271,"address":[1803830],"length":1,"stats":{"Line":3}}],"covered":95,"coverable":118},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","persistence","manifests","task_manifest.rs"],"content":"use crate::domain::task_management::{AnyTask, Task, state::*};\nuse chrono::NaiveDate;\nuse serde::{Deserialize, Serialize};\nuse std::str::FromStr;\nuse uuid7::{Uuid, uuid7};\n\n// This is a private helper struct to unify the data from different Task\u003cState\u003e types.\n#[allow(dead_code)]\nstruct TaskCore {\n    id: Uuid,\n    project_code: String,\n    code: String,\n    name: String,\n    description: Option\u003cString\u003e,\n    start_date: NaiveDate,\n    due_date: NaiveDate,\n    actual_end_date: Option\u003cNaiveDate\u003e,\n    dependencies: Vec\u003cString\u003e,\n    assigned_resources: Vec\u003cString\u003e,\n}\n\nconst API_VERSION: \u0026str = \"v1\";\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub struct TaskManifest {\n    pub api_version: String,\n    pub kind: String,\n    pub metadata: Metadata,\n    pub spec: Spec,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Metadata {\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub id: Option\u003cString\u003e,\n    pub code: String,\n    pub name: String,\n    pub description: Option\u003cString\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Spec {\n    pub project_code: String,\n    pub assignee: String,\n    pub status: Status,\n    pub priority: Priority,\n    pub estimated_start_date: Option\u003cNaiveDate\u003e,\n    pub estimated_end_date: Option\u003cNaiveDate\u003e,\n    pub actual_start_date: Option\u003cNaiveDate\u003e,\n    pub actual_end_date: Option\u003cNaiveDate\u003e,\n    pub dependencies: Vec\u003cString\u003e,\n    pub tags: Vec\u003cString\u003e,\n    pub effort: Effort,\n    pub acceptance_criteria: Vec\u003cString\u003e,\n    pub comments: Vec\u003cComment\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum Status {\n    Planned,\n    ToDo,\n    InProgress,\n    Done,\n    Blocked,\n    Cancelled,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub enum Priority {\n    Low,\n    Medium,\n    High,\n    Critical,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct Effort {\n    estimated_hours: f32,\n    actual_hours: Option\u003cf32\u003e,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]\npub struct Comment {\n    author: String,\n    message: String,\n    timestamp: NaiveDate,\n}\n\nimpl From\u003cAnyTask\u003e for TaskManifest {\n    fn from(any_task: AnyTask) -\u003e Self {\n        let (task_core, manifest_status, comments) = match any_task {\n            AnyTask::Planned(task) =\u003e (\n                TaskCore {\n                    id: task.id,\n                    project_code: task.project_code,\n                    code: task.code,\n                    name: task.name,\n                    description: task.description,\n                    start_date: task.start_date,\n                    due_date: task.due_date,\n                    actual_end_date: task.actual_end_date,\n                    dependencies: task.dependencies,\n                    assigned_resources: task.assigned_resources,\n                },\n                Status::Planned,\n                vec![],\n            ),\n            AnyTask::InProgress(task) =\u003e {\n                let mut comments = Vec::new();\n                if task.state.progress \u003e 0 {\n                    comments.push(Comment {\n                        author: \"system\".to_string(),\n                        message: format!(\"Progresso atual: {}%\", task.state.progress),\n                        timestamp: chrono::Utc::now().naive_utc().date(),\n                    });\n                }\n                (\n                    TaskCore {\n                        id: task.id,\n                        project_code: task.project_code,\n                        code: task.code,\n                        name: task.name,\n                        description: task.description,\n                        start_date: task.start_date,\n                        due_date: task.due_date,\n                        actual_end_date: task.actual_end_date,\n                        dependencies: task.dependencies,\n                        assigned_resources: task.assigned_resources,\n                    },\n                    Status::InProgress,\n                    comments,\n                )\n            }\n            AnyTask::Completed(task) =\u003e (\n                TaskCore {\n                    id: task.id,\n                    project_code: task.project_code,\n                    code: task.code,\n                    name: task.name,\n                    description: task.description,\n                    start_date: task.start_date,\n                    due_date: task.due_date,\n                    actual_end_date: task.actual_end_date,\n                    dependencies: task.dependencies,\n                    assigned_resources: task.assigned_resources,\n                },\n                Status::Done,\n                vec![],\n            ),\n            AnyTask::Blocked(task) =\u003e {\n                let comments = vec![Comment {\n                    author: \"system\".to_string(),\n                    message: format!(\"Tarefa bloqueada: {}\", task.state.reason),\n                    timestamp: chrono::Utc::now().naive_utc().date(),\n                }];\n                (\n                    TaskCore {\n                        id: task.id,\n                        project_code: task.project_code,\n                        code: task.code,\n                        name: task.name,\n                        description: task.description,\n                        start_date: task.start_date,\n                        due_date: task.due_date,\n                        actual_end_date: task.actual_end_date,\n                        dependencies: task.dependencies,\n                        assigned_resources: task.assigned_resources,\n                    },\n                    Status::Blocked,\n                    comments,\n                )\n            }\n            AnyTask::Cancelled(task) =\u003e (\n                TaskCore {\n                    id: task.id,\n                    project_code: task.project_code,\n                    code: task.code,\n                    name: task.name,\n                    description: task.description,\n                    start_date: task.start_date,\n                    due_date: task.due_date,\n                    actual_end_date: task.actual_end_date,\n                    dependencies: task.dependencies,\n                    assigned_resources: task.assigned_resources,\n                },\n                Status::Cancelled,\n                vec![],\n            ),\n        };\n\n        TaskManifest {\n            api_version: API_VERSION.to_string(),\n            kind: \"Task\".to_string(),\n            metadata: Metadata {\n                id: Some(task_core.id.to_string()),\n                code: task_core.code,\n                name: task_core.name,\n                description: task_core.description,\n            },\n            spec: Spec {\n                project_code: task_core.project_code,\n                assignee: task_core\n                    .assigned_resources\n                    .first()\n                    .cloned()\n                    .unwrap_or_else(|| \"unassigned\".to_string()),\n                status: manifest_status.clone(),\n                priority: Priority::Medium,\n                estimated_start_date: Some(task_core.start_date),\n                estimated_end_date: Some(task_core.due_date),\n                actual_start_date: Some(task_core.start_date),\n                actual_end_date: task_core.actual_end_date,\n                dependencies: task_core.dependencies,\n                tags: task_core.assigned_resources.clone(),\n                effort: Effort {\n                    estimated_hours: 8.0,\n                    actual_hours: if matches!(manifest_status, Status::Done) {\n                        Some(8.0)\n                    } else {\n                        None\n                    },\n                },\n                acceptance_criteria: Vec::new(),\n                comments,\n            },\n        }\n    }\n}\n\nimpl TryFrom\u003cTaskManifest\u003e for AnyTask {\n    type Error = String;\n\n    fn try_from(manifest: TaskManifest) -\u003e Result\u003cSelf, Self::Error\u003e {\n        let mut assigned_resources = manifest.spec.tags.clone();\n        if manifest.spec.assignee != \"unassigned\" \u0026\u0026 !assigned_resources.contains(\u0026manifest.spec.assignee) {\n            assigned_resources.insert(0, manifest.spec.assignee.clone());\n        }\n\n        let id = manifest\n            .metadata\n            .id\n            .map(|id_str| Uuid::from_str(\u0026id_str))\n            .transpose()\n            .map_err(|e| e.to_string())?\n            .unwrap_or_else(uuid7);\n\n        let start_date = manifest\n            .spec\n            .estimated_start_date\n            .or(manifest.spec.actual_start_date)\n            .unwrap_or_else(|| chrono::Utc::now().naive_utc().date());\n\n        let due_date = manifest\n            .spec\n            .estimated_end_date\n            .unwrap_or_else(|| chrono::Utc::now().naive_utc().date());\n\n        let task = match manifest.spec.status {\n            Status::Planned | Status::ToDo =\u003e AnyTask::Planned(Task {\n                id,\n                project_code: manifest.spec.project_code,\n                code: manifest.metadata.code,\n                name: manifest.metadata.name,\n                description: manifest.metadata.description,\n                state: Planned,\n                start_date,\n                due_date,\n                actual_end_date: manifest.spec.actual_end_date,\n                dependencies: manifest.spec.dependencies,\n                assigned_resources,\n            }),\n            Status::InProgress =\u003e {\n                let progress = manifest\n                    .spec\n                    .comments\n                    .iter()\n                    .find(|c| c.message.starts_with(\"Progresso atual:\"))\n                    .and_then(|c| {\n                        c.message\n                            .strip_prefix(\"Progresso atual: \")\n                            .and_then(|s| s.strip_suffix('%'))\n                            .and_then(|s| s.parse::\u003cu8\u003e().ok())\n                    })\n                    .unwrap_or(0);\n                AnyTask::InProgress(Task {\n                    id,\n                    project_code: manifest.spec.project_code,\n                    code: manifest.metadata.code,\n                    name: manifest.metadata.name,\n                    description: manifest.metadata.description,\n                    state: InProgress { progress },\n                    start_date,\n                    due_date,\n                    actual_end_date: manifest.spec.actual_end_date,\n                    dependencies: manifest.spec.dependencies,\n                    assigned_resources,\n                })\n            }\n            Status::Done =\u003e AnyTask::Completed(Task {\n                id,\n                project_code: manifest.spec.project_code,\n                code: manifest.metadata.code,\n                name: manifest.metadata.name,\n                description: manifest.metadata.description,\n                state: Completed,\n                start_date,\n                due_date,\n                actual_end_date: manifest.spec.actual_end_date,\n                dependencies: manifest.spec.dependencies,\n                assigned_resources,\n            }),\n            Status::Blocked =\u003e {\n                let reason = manifest\n                    .spec\n                    .comments\n                    .iter()\n                    .find(|c| c.message.starts_with(\"Tarefa bloqueada:\"))\n                    .and_then(|c| c.message.strip_prefix(\"Tarefa bloqueada: \"))\n                    .map(|s| s.to_string())\n                    .unwrap_or_else(|| \"Motivo não especificado\".to_string());\n                AnyTask::Blocked(Task {\n                    id,\n                    project_code: manifest.spec.project_code,\n                    code: manifest.metadata.code,\n                    name: manifest.metadata.name,\n                    description: manifest.metadata.description,\n                    state: Blocked { reason },\n                    start_date,\n                    due_date,\n                    actual_end_date: manifest.spec.actual_end_date,\n                    dependencies: manifest.spec.dependencies,\n                    assigned_resources,\n                })\n            }\n            Status::Cancelled =\u003e AnyTask::Cancelled(Task {\n                id,\n                project_code: manifest.spec.project_code,\n                code: manifest.metadata.code,\n                name: manifest.metadata.name,\n                description: manifest.metadata.description,\n                state: Cancelled,\n                start_date,\n                due_date,\n                actual_end_date: manifest.spec.actual_end_date,\n                dependencies: manifest.spec.dependencies,\n                assigned_resources,\n            }),\n        };\n\n        Ok(task)\n    }\n}\n\n#[cfg(test)]\nmod convertable_tests {\n    use super::*;\n    use crate::domain::task_management::state::Planned;\n\n    // Helper to create a date for tests\n    fn test_date(year: i32, month: u32, day: u32) -\u003e NaiveDate {\n        NaiveDate::from_ymd_opt(year, month, day).unwrap()\n    }\n\n    // Helper to create a basic task for tests\n    fn create_basic_task() -\u003e Task\u003cPlanned\u003e {\n        Task {\n            id: uuid7(),\n            project_code: \"PROJ-1\".to_string(),\n            code: \"TSK-001\".to_string(),\n            name: \"Test Task\".to_string(),\n            description: Some(\"A description\".to_string()),\n            state: Planned,\n            start_date: test_date(2024, 1, 1),\n            due_date: test_date(2024, 1, 10),\n            actual_end_date: None,\n            dependencies: vec![],\n            assigned_resources: vec![\"res-1\".to_string()],\n        }\n    }\n\n    // Helper to create a basic manifest for tests\n    fn create_basic_manifest(status: Status) -\u003e TaskManifest {\n        TaskManifest {\n            api_version: API_VERSION.to_string(),\n            kind: \"Task\".to_string(),\n            metadata: Metadata {\n                id: Some(Uuid::from(1).to_string()),\n                code: \"TASK-1\".to_string(),\n                name: \"Basic Task\".to_string(),\n                description: Some(\"A simple task for testing\".to_string()),\n            },\n            spec: Spec {\n                project_code: \"PROJ-1\".to_string(),\n                assignee: \"res-1\".to_string(),\n                status,\n                priority: Priority::Medium,\n                estimated_start_date: Some(test_date(2024, 1, 1)),\n                estimated_end_date: Some(test_date(2024, 1, 10)),\n                actual_start_date: Some(test_date(2024, 1, 1)),\n                actual_end_date: None,\n                dependencies: vec![],\n                tags: vec![\"res-1\".to_string()],\n                effort: Effort {\n                    estimated_hours: 8.0,\n                    actual_hours: None,\n                },\n                acceptance_criteria: vec![],\n                comments: vec![],\n            },\n        }\n    }\n\n    // --- Conversion Tests: Task -\u003e Manifest ---\n\n    #[test]\n    fn test_task_to_manifest_planned_status() {\n        let task = create_basic_task();\n        let manifest = TaskManifest::from(AnyTask::Planned(task));\n\n        assert_eq!(manifest.spec.status, Status::Planned);\n        assert!(manifest.spec.comments.is_empty());\n    }\n\n    #[test]\n    fn test_task_to_manifest_in_progress_status() {\n        let task = create_basic_task().start().update_progress(50);\n        let manifest = TaskManifest::from(AnyTask::InProgress(task));\n\n        assert_eq!(manifest.spec.status, Status::InProgress);\n        assert_eq!(manifest.spec.comments[0].message, \"Progresso atual: 50%\");\n    }\n\n    #[test]\n    fn test_task_to_manifest_completed_status() {\n        let task = create_basic_task().start().complete();\n        let manifest = TaskManifest::from(AnyTask::Completed(task));\n\n        assert_eq!(manifest.spec.status, Status::Done);\n        assert_eq!(manifest.spec.effort.actual_hours, Some(8.0));\n        assert!(manifest.spec.comments.is_empty());\n    }\n\n    #[test]\n    fn test_task_to_manifest_blocked_status() {\n        let reason = \"Dependency issue\".to_string();\n        let task = create_basic_task().start().block(reason.clone());\n        let manifest = TaskManifest::from(AnyTask::Blocked(task));\n\n        assert_eq!(manifest.spec.status, Status::Blocked);\n        assert_eq!(manifest.spec.comments.len(), 1);\n        assert_eq!(manifest.spec.comments[0].message, format!(\"Tarefa bloqueada: {reason}\"));\n    }\n\n    #[test]\n    fn test_task_to_manifest_cancelled_status() {\n        let task = create_basic_task().start().cancel();\n        let manifest = TaskManifest::from(AnyTask::Cancelled(task));\n\n        assert_eq!(manifest.spec.status, Status::Cancelled);\n        assert!(manifest.spec.comments.is_empty());\n    }\n\n    #[test]\n    fn test_task_to_manifest_no_assigned_resources() {\n        let mut task = create_basic_task();\n        task.assigned_resources = vec![];\n        let manifest = TaskManifest::from(AnyTask::Planned(task));\n\n        assert_eq!(manifest.spec.assignee, \"unassigned\");\n        assert!(manifest.spec.tags.is_empty());\n    }\n\n    #[test]\n    fn test_task_to_manifest_no_description() {\n        let mut task = create_basic_task();\n        task.description = None;\n        let manifest = TaskManifest::from(AnyTask::Planned(task));\n        assert_eq!(manifest.metadata.description, None);\n    }\n\n    // --- Conversion Tests: Manifest -\u003e Task ---\n\n    #[test]\n    fn test_manifest_to_task_planned_status() {\n        let manifest = create_basic_manifest(Status::Planned);\n        let any_task = AnyTask::try_from(manifest).unwrap();\n\n        assert!(matches!(any_task, AnyTask::Planned(_)));\n    }\n\n    #[test]\n    fn test_manifest_to_task_in_progress_status() {\n        let mut manifest = create_basic_manifest(Status::InProgress);\n        manifest.spec.comments.push(Comment {\n            author: \"system\".to_string(),\n            message: \"Progresso atual: 75%\".to_string(),\n            timestamp: test_date(2024, 1, 5),\n        });\n        let any_task = AnyTask::try_from(manifest).unwrap();\n\n        if let AnyTask::InProgress(task) = any_task {\n            assert_eq!(task.state.progress, 75);\n        } else {\n            panic!(\"Incorrect status, expected InProgress\");\n        }\n    }\n\n    #[test]\n    fn test_manifest_to_task_completed_status() {\n        let manifest = create_basic_manifest(Status::Done);\n        let any_task = AnyTask::try_from(manifest).unwrap();\n        assert!(matches!(any_task, AnyTask::Completed(_)));\n    }\n\n    #[test]\n    fn test_manifest_to_task_blocked_status() {\n        let mut manifest = create_basic_manifest(Status::Blocked);\n        let reason = \"Waiting for review\".to_string();\n        manifest.spec.comments.push(Comment {\n            author: \"system\".to_string(),\n            message: format!(\"Tarefa bloqueada: {reason}\"),\n            timestamp: test_date(2024, 1, 5),\n        });\n        let any_task = AnyTask::try_from(manifest).unwrap();\n\n        if let AnyTask::Blocked(task) = any_task {\n            assert_eq!(task.state.reason, reason);\n        } else {\n            panic!(\"Incorrect status, expected Blocked\");\n        }\n    }\n\n    #[test]\n    fn test_manifest_to_task_cancelled_status() {\n        let manifest = create_basic_manifest(Status::Cancelled);\n        let any_task = AnyTask::try_from(manifest).unwrap();\n        assert!(matches!(any_task, AnyTask::Cancelled(_)));\n    }\n\n    // --- Bidirectional Conversion Tests ---\n\n    #[test]\n    fn test_bidirectional_conversion_planned_task() {\n        let original_task = create_basic_task();\n        let manifest = TaskManifest::from(AnyTask::Planned(original_task.clone()));\n        let converted_any_task = AnyTask::try_from(manifest).unwrap();\n\n        if let AnyTask::Planned(converted_task) = converted_any_task {\n            assert_eq!(original_task.code, converted_task.code);\n            assert_eq!(original_task.name, converted_task.name);\n        } else {\n            panic!(\"Incorrect status after conversion\");\n        }\n    }\n\n    #[test]\n    fn test_bidirectional_conversion_in_progress_task() {\n        let original_task = create_basic_task().start().update_progress(50);\n\n        let manifest = TaskManifest::from(AnyTask::InProgress(original_task.clone()));\n        let converted_any_task = AnyTask::try_from(manifest).unwrap();\n\n        if let AnyTask::InProgress(converted_task) = converted_any_task {\n            assert_eq!(original_task.code, converted_task.code);\n            assert_eq!(original_task.state.progress, converted_task.state.progress);\n        } else {\n            panic!(\"Incorrect status after conversion\");\n        }\n    }\n\n    #[test]\n    fn test_bidirectional_conversion_completed_task() {\n        let original_task = create_basic_task().start().complete();\n        let manifest = TaskManifest::from(AnyTask::Completed(original_task.clone()));\n        let converted_any = AnyTask::try_from(manifest).unwrap();\n\n        assert!(matches!(converted_any, AnyTask::Completed(_)));\n        if let AnyTask::Completed(converted) = converted_any {\n            assert_eq!(original_task.code, converted.code);\n            assert!(converted.actual_end_date.is_some());\n        }\n    }\n\n    #[test]\n    fn test_bidirectional_conversion_blocked_task() {\n        let reason = \"Waiting for dependency\".to_string();\n        let original_task = create_basic_task().start().block(reason.clone());\n        let manifest = TaskManifest::from(AnyTask::Blocked(original_task.clone()));\n        let converted_any = AnyTask::try_from(manifest).unwrap();\n\n        assert!(matches!(converted_any, AnyTask::Blocked(_)));\n        if let AnyTask::Blocked(converted) = converted_any {\n            assert_eq!(original_task.code, converted.code);\n            assert_eq!(converted.state.reason, reason);\n        }\n    }\n\n    #[test]\n    fn test_bidirectional_conversion_cancelled_task() {\n        let original_task = create_basic_task().start().cancel();\n        let manifest = TaskManifest::from(AnyTask::Cancelled(original_task.clone()));\n        let converted_any = AnyTask::try_from(manifest).unwrap();\n\n        assert!(matches!(converted_any, AnyTask::Cancelled(_)));\n        if let AnyTask::Cancelled(converted) = converted_any {\n            assert_eq!(original_task.code, converted.code);\n        }\n    }\n}\n","traces":[{"line":93,"address":[1682618,1680560],"length":1,"stats":{"Line":1}},{"line":94,"address":[1680597,1682471],"length":1,"stats":{"Line":3}},{"line":95,"address":[1680702,1682383],"length":1,"stats":{"Line":2}},{"line":96,"address":[1680957],"length":1,"stats":{"Line":1}},{"line":97,"address":[1680728],"length":1,"stats":{"Line":1}},{"line":98,"address":[1680744],"length":1,"stats":{"Line":1}},{"line":99,"address":[1680776],"length":1,"stats":{"Line":1}},{"line":100,"address":[1680808],"length":1,"stats":{"Line":1}},{"line":101,"address":[1680840],"length":1,"stats":{"Line":1}},{"line":102,"address":[1680872],"length":1,"stats":{"Line":1}},{"line":103,"address":[1680879],"length":1,"stats":{"Line":1}},{"line":104,"address":[1680886],"length":1,"stats":{"Line":1}},{"line":105,"address":[1680893],"length":1,"stats":{"Line":1}},{"line":106,"address":[1680925],"length":1,"stats":{"Line":1}},{"line":108,"address":[1681186],"length":1,"stats":{"Line":1}},{"line":109,"address":[1681202],"length":1,"stats":{"Line":1}},{"line":111,"address":[1681217],"length":1,"stats":{"Line":1}},{"line":112,"address":[1681251],"length":1,"stats":{"Line":1}},{"line":113,"address":[1682674],"length":1,"stats":{"Line":1}},{"line":114,"address":[1683871],"length":1,"stats":{"Line":1}},{"line":115,"address":[1683519],"length":1,"stats":{"Line":1}},{"line":116,"address":[1683590,1683658],"length":1,"stats":{"Line":2}},{"line":117,"address":[1683758,1683821],"length":1,"stats":{"Line":2}},{"line":121,"address":[1683029],"length":1,"stats":{"Line":1}},{"line":122,"address":[1682688],"length":1,"stats":{"Line":1}},{"line":123,"address":[1682720],"length":1,"stats":{"Line":1}},{"line":124,"address":[1682768],"length":1,"stats":{"Line":1}},{"line":125,"address":[1682816],"length":1,"stats":{"Line":1}},{"line":126,"address":[1682864],"length":1,"stats":{"Line":1}},{"line":127,"address":[1682912],"length":1,"stats":{"Line":1}},{"line":128,"address":[1682919],"length":1,"stats":{"Line":1}},{"line":129,"address":[1682926],"length":1,"stats":{"Line":1}},{"line":130,"address":[1682933],"length":1,"stats":{"Line":1}},{"line":131,"address":[1682981],"length":1,"stats":{"Line":1}},{"line":133,"address":[1683370],"length":1,"stats":{"Line":1}},{"line":134,"address":[1683378],"length":1,"stats":{"Line":1}},{"line":137,"address":[1685491,1681318],"length":1,"stats":{"Line":2}},{"line":138,"address":[1681573],"length":1,"stats":{"Line":1}},{"line":139,"address":[1681344],"length":1,"stats":{"Line":1}},{"line":140,"address":[1681360],"length":1,"stats":{"Line":1}},{"line":141,"address":[1681392],"length":1,"stats":{"Line":1}},{"line":142,"address":[1681424],"length":1,"stats":{"Line":1}},{"line":143,"address":[1681456],"length":1,"stats":{"Line":1}},{"line":144,"address":[1681488],"length":1,"stats":{"Line":1}},{"line":145,"address":[1681495],"length":1,"stats":{"Line":1}},{"line":146,"address":[1681502],"length":1,"stats":{"Line":1}},{"line":147,"address":[1681509],"length":1,"stats":{"Line":1}},{"line":148,"address":[1681541],"length":1,"stats":{"Line":1}},{"line":150,"address":[1681802],"length":1,"stats":{"Line":1}},{"line":151,"address":[1681818],"length":1,"stats":{"Line":1}},{"line":153,"address":[1681286],"length":1,"stats":{"Line":1}},{"line":154,"address":[1684382,1684022,1685446,1681298,1684069],"length":1,"stats":{"Line":3}},{"line":155,"address":[1684030],"length":1,"stats":{"Line":1}},{"line":156,"address":[1684169,1684101],"length":1,"stats":{"Line":2}},{"line":157,"address":[1684332,1684269],"length":1,"stats":{"Line":2}},{"line":160,"address":[1684987],"length":1,"stats":{"Line":1}},{"line":161,"address":[1684646],"length":1,"stats":{"Line":1}},{"line":162,"address":[1684678],"length":1,"stats":{"Line":1}},{"line":163,"address":[1684726],"length":1,"stats":{"Line":1}},{"line":164,"address":[1684774],"length":1,"stats":{"Line":1}},{"line":165,"address":[1684822],"length":1,"stats":{"Line":1}},{"line":166,"address":[1684870],"length":1,"stats":{"Line":1}},{"line":167,"address":[1684877],"length":1,"stats":{"Line":1}},{"line":168,"address":[1684884],"length":1,"stats":{"Line":1}},{"line":169,"address":[1684891],"length":1,"stats":{"Line":1}},{"line":170,"address":[1684939],"length":1,"stats":{"Line":1}},{"line":172,"address":[1685328],"length":1,"stats":{"Line":1}},{"line":176,"address":[1681833,1685624],"length":1,"stats":{"Line":2}},{"line":177,"address":[1682088],"length":1,"stats":{"Line":1}},{"line":178,"address":[1681859],"length":1,"stats":{"Line":1}},{"line":179,"address":[1681875],"length":1,"stats":{"Line":1}},{"line":180,"address":[1681907],"length":1,"stats":{"Line":1}},{"line":181,"address":[1681939],"length":1,"stats":{"Line":1}},{"line":182,"address":[1681971],"length":1,"stats":{"Line":1}},{"line":183,"address":[1682003],"length":1,"stats":{"Line":1}},{"line":184,"address":[1682010],"length":1,"stats":{"Line":1}},{"line":185,"address":[1682017],"length":1,"stats":{"Line":1}},{"line":186,"address":[1682024],"length":1,"stats":{"Line":1}},{"line":187,"address":[1682056],"length":1,"stats":{"Line":1}},{"line":189,"address":[1682317],"length":1,"stats":{"Line":1}},{"line":190,"address":[1682333],"length":1,"stats":{"Line":1}},{"line":195,"address":[1682584],"length":1,"stats":{"Line":2}},{"line":196,"address":[1685757],"length":1,"stats":{"Line":2}},{"line":197,"address":[1686042],"length":1,"stats":{"Line":2}},{"line":203,"address":[1686811],"length":1,"stats":{"Line":2}},{"line":236,"address":[3110448,3115597],"length":1,"stats":{"Line":1}},{"line":237,"address":[3110479],"length":1,"stats":{"Line":1}},{"line":238,"address":[3110728,3110656,3110580],"length":1,"stats":{"Line":3}},{"line":239,"address":[3110833],"length":1,"stats":{"Line":1}},{"line":242,"address":[3111034,3110670,3110967],"length":1,"stats":{"Line":2}},{"line":245,"address":[2505488,2505515],"length":1,"stats":{"Line":3}},{"line":247,"address":[3110944,3111002],"length":1,"stats":{"Line":1}},{"line":248,"address":[3111119],"length":1,"stats":{"Line":1}},{"line":250,"address":[3111226,3111157],"length":1,"stats":{"Line":3}},{"line":253,"address":[3111163],"length":1,"stats":{"Line":1}},{"line":254,"address":[3111190],"length":1,"stats":{"Line":1}},{"line":256,"address":[3111275,3111233],"length":1,"stats":{"Line":2}},{"line":259,"address":[3111239],"length":1,"stats":{"Line":2}},{"line":261,"address":[3111282],"length":1,"stats":{"Line":2}},{"line":262,"address":[3111603],"length":1,"stats":{"Line":2}},{"line":264,"address":[3111345],"length":1,"stats":{"Line":1}},{"line":265,"address":[3111390],"length":1,"stats":{"Line":2}},{"line":266,"address":[3111426],"length":1,"stats":{"Line":2}},{"line":267,"address":[3111462],"length":1,"stats":{"Line":1}},{"line":271,"address":[3111504],"length":1,"stats":{"Line":1}},{"line":272,"address":[3111510],"length":1,"stats":{"Line":2}},{"line":273,"address":[3111555],"length":1,"stats":{"Line":2}},{"line":276,"address":[3112005,3113539,3113656],"length":1,"stats":{"Line":3}},{"line":280,"address":[3113563],"length":1,"stats":{"Line":3}},{"line":281,"address":[2505840],"length":1,"stats":{"Line":2}},{"line":282,"address":[2505849],"length":1,"stats":{"Line":1}},{"line":283,"address":[2505864],"length":1,"stats":{"Line":2}},{"line":284,"address":[2505939,2505891,2505920],"length":1,"stats":{"Line":3}},{"line":285,"address":[2505966,2505902,2505952],"length":1,"stats":{"Line":3}},{"line":288,"address":[3113922],"length":1,"stats":{"Line":1}},{"line":290,"address":[3113664],"length":1,"stats":{"Line":1}},{"line":291,"address":[3113709],"length":1,"stats":{"Line":1}},{"line":292,"address":[3113745],"length":1,"stats":{"Line":1}},{"line":293,"address":[3113781],"length":1,"stats":{"Line":1}},{"line":297,"address":[3113823],"length":1,"stats":{"Line":1}},{"line":298,"address":[3113829],"length":1,"stats":{"Line":1}},{"line":299,"address":[3113874],"length":1,"stats":{"Line":1}},{"line":302,"address":[3112312],"length":1,"stats":{"Line":2}},{"line":304,"address":[3112054],"length":1,"stats":{"Line":1}},{"line":305,"address":[3112099],"length":1,"stats":{"Line":1}},{"line":306,"address":[3112135],"length":1,"stats":{"Line":1}},{"line":307,"address":[3112171],"length":1,"stats":{"Line":1}},{"line":311,"address":[3112213],"length":1,"stats":{"Line":1}},{"line":312,"address":[3112219],"length":1,"stats":{"Line":2}},{"line":313,"address":[3112264],"length":1,"stats":{"Line":2}},{"line":316,"address":[3114361,3112714],"length":1,"stats":{"Line":2}},{"line":320,"address":[2506000,2506014],"length":1,"stats":{"Line":3}},{"line":321,"address":[2506073,2506064],"length":1,"stats":{"Line":6}},{"line":322,"address":[2506150,2506128],"length":1,"stats":{"Line":4}},{"line":323,"address":[2506176,2506188],"length":1,"stats":{"Line":2}},{"line":324,"address":[3114800],"length":1,"stats":{"Line":2}},{"line":326,"address":[3114494],"length":1,"stats":{"Line":1}},{"line":327,"address":[3114539],"length":1,"stats":{"Line":2}},{"line":328,"address":[3114575],"length":1,"stats":{"Line":2}},{"line":329,"address":[3114611],"length":1,"stats":{"Line":2}},{"line":330,"address":[3114653],"length":1,"stats":{"Line":1}},{"line":333,"address":[3114701],"length":1,"stats":{"Line":2}},{"line":334,"address":[3114707],"length":1,"stats":{"Line":2}},{"line":335,"address":[3114752],"length":1,"stats":{"Line":2}},{"line":338,"address":[3113021],"length":1,"stats":{"Line":1}},{"line":340,"address":[3112763],"length":1,"stats":{"Line":1}},{"line":341,"address":[3112808],"length":1,"stats":{"Line":1}},{"line":342,"address":[3112844],"length":1,"stats":{"Line":1}},{"line":343,"address":[3112880],"length":1,"stats":{"Line":1}},{"line":347,"address":[3112922],"length":1,"stats":{"Line":1}},{"line":348,"address":[3112928],"length":1,"stats":{"Line":1}},{"line":349,"address":[3112973],"length":1,"stats":{"Line":1}},{"line":353,"address":[3113453],"length":1,"stats":{"Line":1}}],"covered":153,"coverable":153},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","persistence","mod.rs"],"content":"pub mod config_repository;\npub mod manifests;\npub mod project_repository;\npub mod resource_repository;\npub mod task_repository;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","persistence","project_repository.rs"],"content":"use crate::{\n    domain::{\n        project_management::{AnyProject, repository::ProjectRepository},\n        shared::errors::{DomainError, DomainErrorKind},\n        task_management::any_task::AnyTask,\n    },\n    infrastructure::persistence::manifests::{project_manifest::ProjectManifest, task_manifest::TaskManifest},\n};\nuse globwalk::glob;\nuse serde_yaml;\nuse std::error::Error;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// `FileProjectRepository` é uma implementação da trait `ProjectRepository`\n/// que persiste os dados do projeto no sistema de arquivos.\n///\n/// A estrutura de diretórios esperada é:\n/// /\u003cbase_path\u003e/\u003cproject_name\u003e/project.yaml\npub struct FileProjectRepository {\n    base_path: PathBuf,\n}\n\nimpl FileProjectRepository {\n    /// Cria uma nova instância do repositório que opera a partir do diretório de trabalho atual.\n    pub fn new() -\u003e Self {\n        Self {\n            base_path: PathBuf::from(\".\"),\n        }\n    }\n\n    /// Cria uma nova instância do repositório que opera a partir de um diretório base específico.\n    /// Esta função é primariamente para uso em testes.\n    pub fn with_base_path(base_path: PathBuf) -\u003e Self {\n        Self { base_path }\n    }\n\n    /// Loads a single project from a specific project directory path.\n    pub fn load_from_path(\u0026self, project_dir: \u0026Path) -\u003e Result\u003cAnyProject, DomainError\u003e {\n        let manifest_path = project_dir.join(\"project.yaml\");\n        if !manifest_path.exists() {\n            return Err(DomainError::new(DomainErrorKind::ResourceNotFound {\n                code: \"unknown\".to_string(),\n            })\n            .with_context(format!(\"No 'project.yaml' found in {}\", project_dir.display())));\n        }\n        let manifest = self.load_manifest(\u0026manifest_path).map_err(|e| {\n            DomainError::new(DomainErrorKind::Generic {\n                message: format!(\"Failed to load project manifest: {e}\"),\n            })\n        })?;\n        let mut project = AnyProject::try_from(manifest).map_err(|e| {\n            DomainError::new(DomainErrorKind::Serialization {\n                format: \"YAML\".to_string(),\n                details: format!(\"Error converting project manifest: {e}\"),\n            })\n        })?;\n        self.load_tasks_for_project(\u0026mut project, \u0026manifest_path)?;\n        Ok(project)\n    }\n\n    /// Carrega e deserializa o manifesto de um projeto de um arquivo YAML.\n    fn load_manifest(\u0026self, path: \u0026Path) -\u003e Result\u003cProjectManifest, Box\u003cdyn Error\u003e\u003e {\n        let yaml = fs::read_to_string(path)?;\n        serde_yaml::from_str(\u0026yaml).map_err(|e| e.into())\n    }\n\n    /// Loads tasks from the `tasks` subdirectory of a project and adds them.\n    fn load_tasks_for_project(\u0026self, project: \u0026mut AnyProject, project_path: \u0026Path) -\u003e Result\u003c(), DomainError\u003e {\n        let tasks_dir = project_path.parent().unwrap().join(\"tasks\");\n        if !tasks_dir.exists() {\n            return Ok(());\n        }\n\n        let pattern = tasks_dir.join(\"*.yaml\");\n        let walker = glob(pattern.to_str().unwrap())\n            .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n\n        for entry in walker.flatten() {\n            let task_path = entry.path();\n            let yaml = fs::read_to_string(task_path).map_err(|e| {\n                DomainError::new(DomainErrorKind::Io {\n                    operation: \"reading task file\".to_string(),\n                    path: Some(task_path.to_string_lossy().to_string()),\n                })\n                .with_context(format!(\"Error reading task file: {e}\"))\n            })?;\n            let task_manifest: TaskManifest = serde_yaml::from_str(\u0026yaml).map_err(|e| {\n                DomainError::new(DomainErrorKind::Serialization {\n                    format: \"YAML\".to_string(),\n                    details: format!(\"Error deserializing task: {e}\"),\n                })\n            })?;\n            let task = AnyTask::try_from(task_manifest).map_err(|e| {\n                DomainError::new(DomainErrorKind::Serialization {\n                    format: \"YAML\".to_string(),\n                    details: format!(\"Error converting task manifest: {e}\"),\n                })\n            })?;\n            project.add_task(task);\n        }\n\n        Ok(())\n    }\n}\n\nimpl ProjectRepository for FileProjectRepository {\n    /// Salva um projeto.\n    /// Cria um diretório com o nome do projeto e salva um arquivo `project.yaml` dentro dele.\n    fn save(\u0026self, project: AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n        let project_dir = self.base_path.join(project.name());\n\n        // Save project manifest\n        fs::create_dir_all(\u0026project_dir).map_err(|e| {\n            DomainError::new(DomainErrorKind::Io {\n                operation: \"creating project directory\".to_string(),\n                path: Some(project_dir.to_string_lossy().to_string()),\n            })\n            .with_context(format!(\"Error creating project directory: {e}\"))\n        })?;\n        let manifest_path = project_dir.join(\"project.yaml\");\n        let project_manifest = ProjectManifest::from(project.clone());\n        let yaml = serde_yaml::to_string(\u0026project_manifest).map_err(|e| {\n            DomainError::new(DomainErrorKind::Serialization {\n                format: \"YAML\".to_string(),\n                details: format!(\"Error serializing project: {e}\"),\n            })\n        })?;\n        fs::write(\u0026manifest_path, yaml).map_err(|e| {\n            DomainError::new(DomainErrorKind::Io {\n                operation: \"saving project file\".to_string(),\n                path: Some(manifest_path.to_string_lossy().to_string()),\n            })\n            .with_context(format!(\"Error saving project file: {e}\"))\n        })?;\n\n        // Save tasks\n        let tasks_dir = project_dir.join(\"tasks\");\n        fs::create_dir_all(\u0026tasks_dir).map_err(|e| {\n            DomainError::new(DomainErrorKind::Io {\n                operation: \"creating tasks directory\".to_string(),\n                path: Some(tasks_dir.to_string_lossy().to_string()),\n            })\n            .with_context(format!(\"Error creating tasks directory: {e}\"))\n        })?;\n\n        for task in project.tasks().values() {\n            let task_manifest = TaskManifest::from(task.clone());\n            let task_yaml = serde_yaml::to_string(\u0026task_manifest).map_err(|e| {\n                DomainError::new(DomainErrorKind::Serialization {\n                    format: \"YAML\".to_string(),\n                    details: format!(\"Error serializing task: {e}\"),\n                })\n            })?;\n            let task_path = tasks_dir.join(format!(\"{}.yaml\", task.code()));\n            fs::write(\u0026task_path, task_yaml).map_err(|e| {\n                DomainError::new(DomainErrorKind::Io {\n                    operation: \"saving task file\".to_string(),\n                    path: Some(task_path.to_string_lossy().to_string()),\n                })\n                .with_context(format!(\"Error saving task file: {e}\"))\n            })?;\n        }\n\n        Ok(())\n    }\n\n    /// Carrega um projeto.\n    /// `path` deve ser o caminho para o diretório do projeto.\n    fn load(\u0026self) -\u003e Result\u003cAnyProject, DomainError\u003e {\n        let pattern = self.base_path.join(\"**/project.yaml\");\n        let walker = glob(pattern.to_str().unwrap())\n            .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n\n        if let Some(Ok(entry)) = walker.into_iter().next() {\n            let manifest_path = entry.path();\n            let manifest = self.load_manifest(manifest_path).map_err(|e| {\n                DomainError::new(DomainErrorKind::Generic {\n                    message: format!(\"Failed to load project manifest: {e}\"),\n                })\n            })?;\n            let mut project = AnyProject::try_from(manifest).map_err(|e| {\n                DomainError::new(DomainErrorKind::Serialization {\n                    format: \"YAML\".to_string(),\n                    details: format!(\"Error converting project manifest: {e}\"),\n                })\n            })?;\n            self.load_tasks_for_project(\u0026mut project, manifest_path)?;\n            Ok(project)\n        } else {\n            Err(DomainError::new(DomainErrorKind::ProjectNotFound {\n                code: \"unknown\".to_string(),\n            })\n            .with_context(\"No 'project.yaml' file found in subdirectories.\"))\n        }\n    }\n\n    fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyProject\u003e, DomainError\u003e {\n        let mut projects = Vec::new();\n        let mut processed_paths = std::collections::HashSet::new();\n\n        // Padrão para buscar em subdiretórios\n        let pattern = self.base_path.join(\"**/project.yaml\");\n        if let Ok(walker) = glob(pattern.to_str().unwrap()) {\n            for entry in walker.flatten() {\n                let manifest_path = entry.path();\n                if processed_paths.contains(manifest_path) {\n                    continue;\n                }\n                if let Ok(manifest) = self.load_manifest(manifest_path)\n                    \u0026\u0026 let Ok(mut project) = AnyProject::try_from(manifest)\n                    \u0026\u0026 self.load_tasks_for_project(\u0026mut project, manifest_path).is_ok()\n                {\n                    projects.push(project);\n                    processed_paths.insert(manifest_path.to_path_buf());\n                }\n            }\n        }\n\n        // Verifica também o diretório atual\n        let current_dir_manifest = self.base_path.join(\"project.yaml\");\n        if current_dir_manifest.exists()\n            \u0026\u0026 !processed_paths.contains(\u0026current_dir_manifest)\n            \u0026\u0026 let Ok(manifest) = self.load_manifest(\u0026current_dir_manifest)\n            \u0026\u0026 let Ok(mut project) = AnyProject::try_from(manifest)\n            \u0026\u0026 self.load_tasks_for_project(\u0026mut project, \u0026current_dir_manifest).is_ok()\n        {\n            projects.push(project);\n        }\n\n        Ok(projects)\n    }\n\n    fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyProject\u003e, DomainError\u003e {\n        // This is not the most performant implementation, but it is correct.\n        // It avoids duplicating the task loading logic.\n        let projects = self.find_all()?;\n        for project in projects {\n            if project.code() == code {\n                return Ok(Some(project));\n            }\n        }\n        Ok(None)\n    }\n\n    fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n        let pattern = self.base_path.join(\"**/project.yaml\");\n        let walker = glob(pattern.to_str().unwrap())\n            .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n\n        let mut max_code = 0;\n\n        for entry in walker.flatten() {\n            let manifest_path = entry.path();\n            if let Ok(manifest) = self.load_manifest(manifest_path)\n                \u0026\u0026 let Some(code) = manifest.metadata.code\n                \u0026\u0026 let Some(num_str) = code.strip_prefix(\"proj-\")\n                \u0026\u0026 let Ok(num) = num_str.parse::\u003cu32\u003e()\n                \u0026\u0026 num \u003e max_code\n            {\n                max_code = num;\n            }\n        }\n\n        Ok(format!(\"proj-{}\", max_code + 1))\n    }\n}\n\n// ===================================\n// TESTES\n// ===================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::project_management::{\n        builder::ProjectBuilder,\n        project::Project,\n        state::{InProgress, Planned},\n    };\n    use crate::infrastructure::persistence::manifests::project_manifest::{\n        ProjectManifest, ProjectMetadata, ProjectSpec, ProjectStatusManifest, VacationRulesManifest,\n    };\n    use std::fs;\n    use tempfile::tempdir;\n\n    use uuid7::uuid7;\n\n    fn create_test_project() -\u003e Project\u003cPlanned\u003e {\n        ProjectBuilder::new(\"Test Project\".to_string())\n            .code(\"TEST-001\".to_string())\n            .description(Some(\"A test project for repository testing\".to_string()))\n            .end_date(\"2024-12-31\".to_string())\n            .build()\n    }\n\n    fn create_test_project_manifest() -\u003e ProjectManifest {\n        ProjectManifest {\n            api_version: \"tasktaskrevolution.io/v1alpha1\".to_string(),\n            kind: \"Project\".to_string(),\n            metadata: ProjectMetadata {\n                id: Some(uuid7().to_string()),\n                code: Some(\"TEST-001\".to_string()),\n                name: \"Test Project\".to_string(),\n                description: \"A test project for repository testing\".to_string(),\n            },\n            spec: ProjectSpec {\n                timezone: Some(\"UTC\".to_string()),\n                start_date: Some(\"2024-01-01\".to_string()),\n                end_date: Some(\"2024-12-31\".to_string()),\n                status: ProjectStatusManifest::Planned,\n                vacation_rules: Some(VacationRulesManifest {\n                    max_concurrent_vacations: None,\n                    allow_layoff_vacations: None,\n                    require_layoff_vacation_period: None,\n                    layoff_periods: None,\n                }),\n            },\n        }\n    }\n\n    #[test]\n    fn test_project_manifest_serialization() {\n        let manifest = create_test_project_manifest();\n\n        let yaml = serde_yaml::to_string(\u0026manifest).expect(\"Failed to serialize to YAML\");\n        let deserialized: ProjectManifest = serde_yaml::from_str(\u0026yaml).expect(\"Failed to deserialize from YAML\");\n\n        assert_eq!(manifest.metadata.code, deserialized.metadata.code);\n        assert_eq!(manifest.metadata.name, deserialized.metadata.name);\n        assert_eq!(manifest.metadata.description, deserialized.metadata.description);\n        assert_eq!(manifest.spec.status, deserialized.spec.status);\n    }\n\n    #[test]\n    fn test_project_manifest_to_domain_conversion() {\n        let manifest = create_test_project_manifest();\n        // Test conversion from ProjectManifest to AnyProject\n        // Note: This requires implementing From\u003cProjectManifest\u003e for AnyProject\n        // For now, we'll test the manifest structure\n        assert_eq!(manifest.metadata.code, Some(\"TEST-001\".to_string()));\n        assert_eq!(manifest.metadata.name, \"Test Project\");\n        assert_eq!(manifest.metadata.description, \"A test project for repository testing\");\n        assert!(matches!(manifest.spec.status, ProjectStatusManifest::Planned));\n    }\n\n    #[test]\n    fn test_project_repository_save_and_load() {\n        let temp_dir = tempdir().expect(\"Failed to create temp directory\");\n        let repo_path = temp_dir.path().join(\"projects\");\n        fs::create_dir_all(\u0026repo_path).expect(\"Failed to create projects directory\");\n\n        let repository = FileProjectRepository::with_base_path(repo_path.to_path_buf());\n        let project = create_test_project();\n\n        // Save project\n        let save_result = repository.save(project.clone().into());\n        assert!(save_result.is_ok(), \"Failed to save project: {:?}\", save_result);\n\n        // Load project by code - we need to implement find_by_code or use a different approach\n        // For now, let's test that the project was saved by checking the file exists\n        let project_file = repo_path.join(\"Test Project\").join(\"project.yaml\");\n        assert!(project_file.exists(), \"Project file should exist after save\");\n    }\n\n    #[test]\n    fn test_project_repository_save_multiple_projects() {\n        let temp_dir = tempdir().expect(\"Failed to create temp directory\");\n        let repo_path = temp_dir.path().join(\"projects\");\n        fs::create_dir_all(\u0026repo_path).expect(\"Failed to create projects directory\");\n\n        let repository = FileProjectRepository::with_base_path(repo_path.to_path_buf());\n\n        // Create and save multiple projects\n        let project1 = ProjectBuilder::new(\"Project 1\".to_string())\n            .code(\"PROJ-001\".to_string())\n            .end_date(\"2024-12-31\".to_string())\n            .build();\n\n        let project2 = ProjectBuilder::new(\"Project 2\".to_string())\n            .code(\"PROJ-002\".to_string())\n            .end_date(\"2024-12-31\".to_string())\n            .build();\n\n        repository.save(project1.into()).expect(\"Failed to save project 1\");\n        repository.save(project2.into()).expect(\"Failed to save project 2\");\n\n        // Verify both projects were saved by checking files exist\n        let project1_file = repo_path.join(\"Project 1\").join(\"project.yaml\");\n        let project2_file = repo_path.join(\"Project 2\").join(\"project.yaml\");\n\n        assert!(project1_file.exists(), \"Project 1 file should exist\");\n        assert!(project2_file.exists(), \"Project 2 file should exist\");\n    }\n\n    #[test]\n    fn test_project_repository_update_project() {\n        let temp_dir = tempdir().expect(\"Failed to create temp directory\");\n        let repo_path = temp_dir.path().join(\"projects\");\n        fs::create_dir_all(\u0026repo_path).expect(\"Failed to create projects directory\");\n\n        let repository = FileProjectRepository::with_base_path(repo_path.to_path_buf());\n        let project = create_test_project();\n\n        // Save initial project\n        repository.save(project.clone().into()).expect(\"Failed to save project\");\n\n        // Update project state to InProgress\n        let in_progress_project: Project\u003cInProgress\u003e = project.start();\n        repository\n            .save(in_progress_project.clone().into())\n            .expect(\"Failed to update project\");\n\n        // Verify update by checking file exists\n        let project_file = repo_path.join(\"Test Project\").join(\"project.yaml\");\n        assert!(project_file.exists(), \"Updated project file should exist\");\n    }\n\n    #[test]\n    fn test_project_repository_save_and_verify() {\n        let temp_dir = tempdir().expect(\"Failed to create temp directory\");\n        let repo_path = temp_dir.path().join(\"projects\");\n        fs::create_dir_all(\u0026repo_path).expect(\"Failed to create projects directory\");\n\n        let repository = FileProjectRepository::with_base_path(repo_path.to_path_buf());\n        let project = create_test_project();\n\n        // Save project\n        repository.save(project.clone().into()).expect(\"Failed to save project\");\n\n        // Verify project exists\n        let project_file = repo_path.join(\"Test Project\").join(\"project.yaml\");\n        assert!(project_file.exists(), \"Project file should exist after save\");\n\n        // Verify project directory structure\n        let tasks_dir = repo_path.join(\"Test Project\").join(\"tasks\");\n        assert!(tasks_dir.exists(), \"Tasks directory should exist\");\n    }\n\n    #[test]\n    fn test_project_repository_error_handling() {\n        let temp_dir = tempdir().expect(\"Failed to create temp directory\");\n        let repo_path = temp_dir.path().join(\"projects\");\n        fs::create_dir_all(\u0026repo_path).expect(\"Failed to create projects directory\");\n\n        let repository = FileProjectRepository::with_base_path(repo_path.to_path_buf());\n\n        // Try to find non-existent project\n        let result = repository.find_by_code(\"NON-EXISTENT\");\n        assert!(result.is_ok(), \"Should return Ok(None) for non-existent project\");\n        assert!(result.unwrap().is_none(), \"Should return None for non-existent project\");\n    }\n\n    #[test]\n    fn test_project_repository_file_corruption_handling() {\n        let temp_dir = tempdir().expect(\"Failed to create temp directory\");\n        let repo_path = temp_dir.path().join(\"projects\");\n        fs::create_dir_all(\u0026repo_path).expect(\"Failed to create projects directory\");\n\n        let repository = FileProjectRepository::with_base_path(repo_path.to_path_buf());\n        let project = create_test_project();\n\n        // Save project\n        repository.save(project.clone().into()).expect(\"Failed to save project\");\n\n        // Corrupt the YAML file\n        let project_file = repo_path.join(\"Test Project\").join(\"project.yaml\");\n        fs::write(\u0026project_file, \"invalid: yaml: content: [\").expect(\"Failed to corrupt file\");\n\n        // Note: We can't test loading corrupted files yet since find_by_code is not fully implemented\n        // This test verifies that we can save projects and corrupt files\n        assert!(project_file.exists(), \"Project file should exist even if corrupted\");\n    }\n\n    #[test]\n    fn test_project_repository_concurrent_access() {\n        let temp_dir = tempdir().expect(\"Failed to create temp directory\");\n        let repo_path = temp_dir.path().join(\"projects\");\n        fs::create_dir_all(\u0026repo_path).expect(\"Failed to create projects directory\");\n\n        // Create multiple projects concurrently\n        let mut handles = vec![];\n\n        for i in 1..=5 {\n            let repo_path = repo_path.clone();\n            let handle = std::thread::spawn(move || {\n                let repo = FileProjectRepository::with_base_path(repo_path.to_path_buf());\n                let project = ProjectBuilder::new(format!(\"Project {}\", i))\n                    .code(format!(\"PROJ-{:03}\", i))\n                    .end_date(\"2024-12-31\".to_string())\n                    .build();\n                repo.save(project.into())\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all threads to complete\n        for handle in handles {\n            let result = handle.join().expect(\"Thread failed to complete\");\n            assert!(\n                result.is_ok(),\n                \"Failed to save project in concurrent access: {:?}\",\n                result\n            );\n        }\n\n        // Verify all projects were saved by checking files exist\n        for i in 1..=5 {\n            let project_file = repo_path.join(format!(\"Project {}\", i)).join(\"project.yaml\");\n            assert!(project_file.exists(), \"Project {} file should exist\", i);\n        }\n    }\n}\n","traces":[{"line":26,"address":[1360464],"length":1,"stats":{"Line":1}},{"line":28,"address":[1360477],"length":1,"stats":{"Line":1}},{"line":34,"address":[1360544],"length":1,"stats":{"Line":1}},{"line":39,"address":[1360576,1362466,1361331],"length":1,"stats":{"Line":1}},{"line":40,"address":[1360678],"length":1,"stats":{"Line":1}},{"line":41,"address":[1360823,1360740],"length":1,"stats":{"Line":2}},{"line":42,"address":[1361257,1360903,1361202],"length":1,"stats":{"Line":0}},{"line":43,"address":[1360844],"length":1,"stats":{"Line":0}},{"line":45,"address":[1361008,1361234,1360991,1361321],"length":1,"stats":{"Line":0}},{"line":47,"address":[1361363,1360883,1362464,1361561],"length":1,"stats":{"Line":2}},{"line":48,"address":[1711460],"length":1,"stats":{"Line":0}},{"line":49,"address":[1711320,1711364],"length":1,"stats":{"Line":0}},{"line":52,"address":[1361950,1361684,1361784,1362444],"length":1,"stats":{"Line":2}},{"line":53,"address":[1711807],"length":1,"stats":{"Line":0}},{"line":54,"address":[1711574],"length":1,"stats":{"Line":0}},{"line":55,"address":[1711648,1711705],"length":1,"stats":{"Line":0}},{"line":58,"address":[1362142,1362051],"length":1,"stats":{"Line":2}},{"line":59,"address":[1362326],"length":1,"stats":{"Line":1}},{"line":63,"address":[1362821,1362480,1362827],"length":1,"stats":{"Line":1}},{"line":64,"address":[1362547],"length":1,"stats":{"Line":1}},{"line":65,"address":[1362770,1362699],"length":1,"stats":{"Line":2}},{"line":69,"address":[1365571,1365722,1362848],"length":1,"stats":{"Line":1}},{"line":70,"address":[1362964],"length":1,"stats":{"Line":1}},{"line":71,"address":[1363068,1363151],"length":1,"stats":{"Line":2}},{"line":72,"address":[1363186],"length":1,"stats":{"Line":0}},{"line":75,"address":[1363261,1363203],"length":1,"stats":{"Line":2}},{"line":76,"address":[1363301,1363527,1363670,1365720,1363384],"length":1,"stats":{"Line":3}},{"line":77,"address":[1711952,1711979],"length":1,"stats":{"Line":1}},{"line":79,"address":[1363933,1364026,1363823],"length":1,"stats":{"Line":3}},{"line":80,"address":[1364111,1364284],"length":1,"stats":{"Line":2}},{"line":81,"address":[1364523,1364324,1365651],"length":1,"stats":{"Line":1}},{"line":82,"address":[1712144,1712393,1712708],"length":1,"stats":{"Line":0}},{"line":83,"address":[1712152],"length":1,"stats":{"Line":0}},{"line":84,"address":[1712224,1712290,1712361],"length":1,"stats":{"Line":0}},{"line":86,"address":[1712792,1712489,1712541,1712565,1712729],"length":1,"stats":{"Line":0}},{"line":88,"address":[1365630,1364620,1364897,1364699],"length":1,"stats":{"Line":2}},{"line":89,"address":[1713083],"length":1,"stats":{"Line":0}},{"line":90,"address":[1712854],"length":1,"stats":{"Line":0}},{"line":91,"address":[1712936,1712981],"length":1,"stats":{"Line":0}},{"line":94,"address":[1713200,1713543],"length":1,"stats":{"Line":2}},{"line":95,"address":[1713455],"length":1,"stats":{"Line":0}},{"line":96,"address":[1713222],"length":1,"stats":{"Line":0}},{"line":97,"address":[1713296,1713353],"length":1,"stats":{"Line":0}},{"line":100,"address":[1365416],"length":1,"stats":{"Line":1}},{"line":103,"address":[1364166],"length":1,"stats":{"Line":1}},{"line":110,"address":[1365744,1368973,1368815],"length":1,"stats":{"Line":1}},{"line":111,"address":[1365802,1365921],"length":1,"stats":{"Line":3}},{"line":114,"address":[1368953,1366252,1366003,1366086],"length":1,"stats":{"Line":5}},{"line":115,"address":[1714179,1713595,1713864],"length":1,"stats":{"Line":0}},{"line":116,"address":[1713603],"length":1,"stats":{"Line":0}},{"line":117,"address":[1713832,1713754,1713675],"length":1,"stats":{"Line":0}},{"line":119,"address":[1714200,1714263,1714012,1713960,1714036],"length":1,"stats":{"Line":0}},{"line":121,"address":[1366285],"length":1,"stats":{"Line":2}},{"line":122,"address":[1366360,1366427],"length":1,"stats":{"Line":5}},{"line":123,"address":[1714643,1714649,1714304],"length":1,"stats":{"Line":6}},{"line":124,"address":[1714555],"length":1,"stats":{"Line":0}},{"line":125,"address":[1714326],"length":1,"stats":{"Line":0}},{"line":126,"address":[1714408,1714453],"length":1,"stats":{"Line":0}},{"line":129,"address":[1368889,1366773,1366903,1367069],"length":1,"stats":{"Line":7}},{"line":130,"address":[1715283,1714699,1714968],"length":1,"stats":{"Line":0}},{"line":131,"address":[1714707],"length":1,"stats":{"Line":0}},{"line":132,"address":[1714858,1714779,1714936],"length":1,"stats":{"Line":0}},{"line":134,"address":[1715116,1715367,1715304,1715140,1715064],"length":1,"stats":{"Line":0}},{"line":138,"address":[1367102],"length":1,"stats":{"Line":2}},{"line":139,"address":[1367169,1368864,1367246,1367412],"length":1,"stats":{"Line":9}},{"line":140,"address":[1715435,1715704,1716019],"length":1,"stats":{"Line":0}},{"line":141,"address":[1715443],"length":1,"stats":{"Line":0}},{"line":142,"address":[1715594,1715515,1715672],"length":1,"stats":{"Line":0}},{"line":144,"address":[1715800,1716040,1715852,1715876,1716103],"length":1,"stats":{"Line":0}},{"line":147,"address":[1367445],"length":1,"stats":{"Line":8}},{"line":148,"address":[1367619,1367766],"length":1,"stats":{"Line":0}},{"line":149,"address":[1367789,1368843,1368018,1367852],"length":1,"stats":{"Line":0}},{"line":150,"address":[1716395],"length":1,"stats":{"Line":0}},{"line":151,"address":[1716166],"length":1,"stats":{"Line":0}},{"line":152,"address":[1716248,1716293],"length":1,"stats":{"Line":0}},{"line":155,"address":[1368206,1368123],"length":1,"stats":{"Line":0}},{"line":156,"address":[1368413,1368544,1368706],"length":1,"stats":{"Line":0}},{"line":157,"address":[1716539,1716808,1717123],"length":1,"stats":{"Line":0}},{"line":158,"address":[1716547],"length":1,"stats":{"Line":0}},{"line":159,"address":[1716619,1716776,1716698],"length":1,"stats":{"Line":0}},{"line":161,"address":[1716980,1716956,1717207,1717144,1716904],"length":1,"stats":{"Line":0}},{"line":165,"address":[1367634],"length":1,"stats":{"Line":2}},{"line":170,"address":[1368992,1371373,1371846],"length":1,"stats":{"Line":1}},{"line":171,"address":[1369057],"length":1,"stats":{"Line":1}},{"line":172,"address":[1369210,1369496,1371841,1369353,1369127],"length":1,"stats":{"Line":3}},{"line":173,"address":[1369330,1369400],"length":1,"stats":{"Line":1}},{"line":175,"address":[1369807,1369903,1369739,1369649],"length":1,"stats":{"Line":3}},{"line":176,"address":[1369951,1370042],"length":1,"stats":{"Line":0}},{"line":177,"address":[1370280,1371399,1370082],"length":1,"stats":{"Line":0}},{"line":178,"address":[1717588],"length":1,"stats":{"Line":0}},{"line":179,"address":[1717492,1717448],"length":1,"stats":{"Line":0}},{"line":182,"address":[1370403,1370669,1370503,1371379],"length":1,"stats":{"Line":0}},{"line":183,"address":[1717935],"length":1,"stats":{"Line":0}},{"line":184,"address":[1717702],"length":1,"stats":{"Line":0}},{"line":185,"address":[1717833,1717776],"length":1,"stats":{"Line":0}},{"line":188,"address":[1370800,1370863],"length":1,"stats":{"Line":0}},{"line":189,"address":[1371073],"length":1,"stats":{"Line":0}},{"line":191,"address":[1371651,1371761],"length":1,"stats":{"Line":2}},{"line":192,"address":[1371620],"length":1,"stats":{"Line":1}},{"line":194,"address":[1371718],"length":1,"stats":{"Line":1}},{"line":198,"address":[1371872,1373926,1375497],"length":1,"stats":{"Line":1}},{"line":199,"address":[1371926],"length":1,"stats":{"Line":1}},{"line":200,"address":[1372011],"length":1,"stats":{"Line":1}},{"line":203,"address":[1372067,1372143],"length":1,"stats":{"Line":2}},{"line":204,"address":[1372452,1372183,1372266],"length":1,"stats":{"Line":3}},{"line":205,"address":[1372554,1372650,1372462],"length":1,"stats":{"Line":3}},{"line":206,"address":[1372735,1372925],"length":1,"stats":{"Line":0}},{"line":207,"address":[1372968],"length":1,"stats":{"Line":0}},{"line":210,"address":[1373144,1374072,1373024,1373053],"length":1,"stats":{"Line":0}},{"line":211,"address":[1373346,1373273,1373200],"length":1,"stats":{"Line":0}},{"line":212,"address":[1373487,1373431],"length":1,"stats":{"Line":0}},{"line":214,"address":[1373660],"length":1,"stats":{"Line":0}},{"line":215,"address":[1373743],"length":1,"stats":{"Line":0}},{"line":221,"address":[1372839,1374126],"length":1,"stats":{"Line":2}},{"line":222,"address":[1374166,1374237,1375274],"length":1,"stats":{"Line":2}},{"line":223,"address":[1374375],"length":1,"stats":{"Line":0}},{"line":224,"address":[1374408,1374549],"length":1,"stats":{"Line":0}},{"line":225,"address":[1374751,1374678,1374605],"length":1,"stats":{"Line":0}},{"line":226,"address":[1374805,1374897],"length":1,"stats":{"Line":0}},{"line":228,"address":[1375085],"length":1,"stats":{"Line":0}},{"line":231,"address":[1374266],"length":1,"stats":{"Line":1}},{"line":234,"address":[1375536,1376389,1376395],"length":1,"stats":{"Line":1}},{"line":237,"address":[1375571],"length":1,"stats":{"Line":1}},{"line":238,"address":[1375763,1375861,1375988],"length":1,"stats":{"Line":3}},{"line":239,"address":[1376194,1376056],"length":1,"stats":{"Line":0}},{"line":240,"address":[1376308],"length":1,"stats":{"Line":0}},{"line":243,"address":[1376093],"length":1,"stats":{"Line":1}},{"line":246,"address":[1379683,1378841,1376432],"length":1,"stats":{"Line":0}},{"line":247,"address":[1376491],"length":1,"stats":{"Line":0}},{"line":248,"address":[1376569,1376652,1376932,1376789],"length":1,"stats":{"Line":0}},{"line":249,"address":[1376766,1376836],"length":1,"stats":{"Line":0}},{"line":251,"address":[1377055],"length":1,"stats":{"Line":0}},{"line":253,"address":[1377066,1377263,1377170],"length":1,"stats":{"Line":0}},{"line":254,"address":[1377348,1377723],"length":1,"stats":{"Line":0}},{"line":255,"address":[1377845,1379614,1377747],"length":1,"stats":{"Line":0}},{"line":256,"address":[1377887],"length":1,"stats":{"Line":0}},{"line":257,"address":[1377972,1378065],"length":1,"stats":{"Line":0}},{"line":258,"address":[1378187,1378226],"length":1,"stats":{"Line":0}},{"line":259,"address":[1378288],"length":1,"stats":{"Line":0}},{"line":261,"address":[1378301],"length":1,"stats":{"Line":0}},{"line":265,"address":[1377395],"length":1,"stats":{"Line":0}}],"covered":58,"coverable":141},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","persistence","resource_repository.rs"],"content":"use crate::{\n    domain::{\n        project_management::repository::ProjectRepository,\n        resource_management::{AnyResource, Period, PeriodType, repository::ResourceRepository},\n        shared::errors::{DomainError, DomainErrorKind},\n    },\n    infrastructure::persistence::{\n        manifests::resource_manifest::ResourceManifest, project_repository::FileProjectRepository,\n    },\n};\nuse chrono::{DateTime, Local, NaiveDate, Offset};\nuse glob::glob;\nuse serde_yaml;\nuse std::{\n    fs,\n    path::{Path, PathBuf},\n};\n\npub struct FileResourceRepository {\n    base_path: PathBuf,\n}\n\nimpl FileResourceRepository {\n    pub fn new\u003cP: AsRef\u003cPath\u003e\u003e(base_path: P) -\u003e Self {\n        Self {\n            base_path: base_path.as_ref().to_path_buf(),\n        }\n    }\n\n    fn get_resource_file_path(\u0026self, resource_name: \u0026str) -\u003e PathBuf {\n        self.base_path\n            .join(\"resources\")\n            .join(format!(\"{}.yaml\", resource_name.replace(' ', \"_\").to_lowercase()))\n    }\n\n    fn find_by_name(\u0026self, resource_name: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n        let file_path = self.get_resource_file_path(resource_name);\n        if !file_path.exists() {\n            return Ok(None);\n        }\n        let yaml = fs::read_to_string(\u0026file_path).map_err(|e| {\n            DomainError::new(DomainErrorKind::Io {\n                operation: \"reading resource file\".to_string(),\n                path: Some(file_path.to_string_lossy().to_string()),\n            })\n            .with_context(format!(\"Error reading resource file: {e}\"))\n        })?;\n        let manifest: ResourceManifest = serde_yaml::from_str(\u0026yaml).map_err(|e| {\n            DomainError::new(DomainErrorKind::Serialization {\n                format: \"YAML\".to_string(),\n                details: format!(\"Error deserializing resource: {}\", e),\n            })\n        })?;\n        let resource = AnyResource::try_from(manifest).map_err(|e| {\n            DomainError::new(DomainErrorKind::Serialization {\n                format: \"YAML\".to_string(),\n                details: format!(\"Error converting manifest: {}\", e),\n            })\n        })?;\n        Ok(Some(resource))\n    }\n\n    fn read_resource_from_dir(\u0026self, dir: \u0026Path) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n        let manifest_path = dir.join(\"resource.yaml\");\n        if !manifest_path.exists() {\n            return Ok(None);\n        }\n\n        let yaml = fs::read_to_string(\u0026manifest_path).map_err(|e| {\n            DomainError::new(DomainErrorKind::Io {\n                operation: \"file operation\".to_string(),\n                path: None,\n            })\n            .with_context(format!(\"Error reading resource manifest: {e}\"))\n        })?;\n        let manifest: ResourceManifest = serde_yaml::from_str(\u0026yaml).map_err(|e| {\n            DomainError::new(DomainErrorKind::Serialization {\n                format: \"YAML\".to_string(),\n                details: format!(\"Error deserializing resource: {}\", e),\n            })\n        })?;\n        let resource = AnyResource::try_from(manifest).map_err(|e| {\n            DomainError::new(DomainErrorKind::Serialization {\n                format: \"YAML\".to_string(),\n                details: format!(\"Error converting manifest: {}\", e),\n            })\n        })?;\n        Ok(Some(resource))\n    }\n}\n\nimpl ResourceRepository for FileResourceRepository {\n    fn save(\u0026self, resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n        let file_path = self.get_resource_file_path(resource.name());\n        let resource_manifest = ResourceManifest::from(resource.clone());\n        let yaml = serde_yaml::to_string(\u0026resource_manifest).map_err(|e| {\n            DomainError::new(DomainErrorKind::Serialization {\n                format: \"YAML\".to_string(),\n                details: format!(\"Error serializing resource: {}\", e),\n            })\n        })?;\n\n        fs::create_dir_all(file_path.parent().unwrap()).map_err(|e| {\n            DomainError::new(DomainErrorKind::Io {\n                operation: \"file operation\".to_string(),\n                path: None,\n            })\n            .with_context(format!(\"Error creating directory: {e}\"))\n        })?;\n\n        fs::write(file_path, yaml).map_err(|e| {\n            DomainError::new(DomainErrorKind::Io {\n                operation: \"file operation\".to_string(),\n                path: None,\n            })\n            .with_context(format!(\"Error saving resource: {e}\"))\n        })?;\n\n        Ok(resource)\n    }\n\n    fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n        let pattern = self.base_path.join(\"**/resources/**/*.yaml\");\n        let walker = glob(pattern.to_str().unwrap())\n            .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n        let mut resources = Vec::new();\n\n        for entry in walker {\n            let entry = entry.map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n            let file_path = entry.as_path();\n            let yaml = fs::read_to_string(file_path).map_err(|e| {\n                DomainError::new(DomainErrorKind::Io {\n                    operation: \"file operation\".to_string(),\n                    path: None,\n                })\n                .with_context(format!(\"Error reading resource file: {e}\"))\n            })?;\n\n            let resource_manifest: ResourceManifest = serde_yaml::from_str(\u0026yaml).map_err(|e| {\n                DomainError::new(DomainErrorKind::Serialization {\n                    format: \"YAML\".to_string(),\n                    details: format!(\"Error deserializing resource: {}\", e),\n                })\n            })?;\n\n            resources.push(AnyResource::try_from(resource_manifest).map_err(|e| {\n                DomainError::new(DomainErrorKind::Serialization {\n                    format: \"YAML\".to_string(),\n                    details: format!(\"Error converting manifest: {}\", e),\n                })\n            })?);\n        }\n\n        Ok(resources)\n    }\n\n    fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n        // Since resources are saved by name, we need to search through all resources\n        // to find one with the matching code\n        let all_resources = self.find_all()?;\n        for resource in all_resources {\n            if resource.code() == code {\n                return Ok(Some(resource));\n            }\n        }\n        Ok(None)\n    }\n\n    fn save_time_off(\n        \u0026self,\n        resource_name: \u0026str,\n        hours: u32,\n        _date: \u0026str,\n        _description: Option\u003cString\u003e,\n    ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n        let resource = self.find_by_name(resource_name)?.ok_or_else(|| {\n            DomainError::new(DomainErrorKind::ResourceNotFound {\n                code: \"unknown\".to_string(),\n            })\n            .with_context(\"Resource not found\".to_string())\n        })?;\n\n        let updated_resource = match resource {\n            AnyResource::Available(mut r) =\u003e {\n                r.time_off_balance += hours;\n                AnyResource::Available(r)\n            }\n            AnyResource::Assigned(mut r) =\u003e {\n                r.time_off_balance += hours;\n                AnyResource::Assigned(r)\n            }\n            AnyResource::Inactive(mut r) =\u003e {\n                r.time_off_balance += hours;\n                AnyResource::Inactive(r)\n            }\n        };\n        self.save(updated_resource)\n    }\n\n    fn save_vacation(\n        \u0026self,\n        resource_name: \u0026str,\n        start_date: \u0026str,\n        end_date: \u0026str,\n        is_time_off_compensation: bool,\n        compensated_hours: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n        let resource = self.find_by_name(resource_name)?.ok_or_else(|| {\n            DomainError::new(DomainErrorKind::ResourceNotFound {\n                code: \"unknown\".to_string(),\n            })\n            .with_context(\"Resource not found\".to_string())\n        })?;\n\n        let start_date = NaiveDate::parse_from_str(start_date, \"%Y-%m-%d\")\n            .map_err(|e| {\n                DomainError::new(DomainErrorKind::Generic {\n                    message: format!(\"Invalid start date: {}\", e),\n                })\n            })?\n            .and_hms_opt(0, 0, 0)\n            .unwrap();\n\n        let end_date = NaiveDate::parse_from_str(end_date, \"%Y-%m-%d\")\n            .map_err(|e| {\n                DomainError::new(DomainErrorKind::Generic {\n                    message: format!(\"Invalid end date: {}\", e),\n                })\n            })?\n            .and_hms_opt(0, 0, 0)\n            .unwrap();\n\n        if end_date \u003c start_date {\n            return Err(DomainError::new(DomainErrorKind::Generic {\n                message: \"End date must be after start date\".to_string(),\n            }));\n        }\n\n        let offset = Local::now().offset().fix();\n        let start_date: DateTime\u003cLocal\u003e = DateTime::from_naive_utc_and_offset(start_date, offset);\n        let end_date: DateTime\u003cLocal\u003e = DateTime::from_naive_utc_and_offset(end_date, offset);\n\n        let is_layoff = self.check_if_layoff_period(\u0026start_date, \u0026end_date);\n\n        let new_vacation = Period {\n            start_date,\n            end_date,\n            approved: true,\n            period_type: PeriodType::Vacation,\n            is_time_off_compensation,\n            compensated_hours,\n            is_layoff,\n        };\n\n        let add_vacation = |vacations: Option\u003cVec\u003cPeriod\u003e\u003e| -\u003e Option\u003cVec\u003cPeriod\u003e\u003e {\n            let mut v = vacations.unwrap_or_default();\n            v.push(new_vacation);\n            Some(v)\n        };\n\n        let updated_resource = match resource {\n            AnyResource::Available(mut r) =\u003e {\n                r.vacations = add_vacation(r.vacations);\n                AnyResource::Available(r)\n            }\n            AnyResource::Assigned(mut r) =\u003e {\n                r.vacations = add_vacation(r.vacations);\n                AnyResource::Assigned(r)\n            }\n            AnyResource::Inactive(_) =\u003e {\n                return Err(DomainError::new(DomainErrorKind::ResourceInvalidState {\n                    current: \"unknown\".to_string(),\n                    expected: \"valid\".to_string(),\n                })\n                .with_context(\"Cannot add vacation to inactive resource\".to_string()));\n            }\n        };\n\n        self.save(updated_resource)\n    }\n\n    fn check_if_layoff_period(\u0026self, start_date: \u0026DateTime\u003cLocal\u003e, end_date: \u0026DateTime\u003cLocal\u003e) -\u003e bool {\n        let project_repo = FileProjectRepository::new();\n\n        if let Ok(project) = project_repo.load()\n            \u0026\u0026 let Some(vacation_rules) = project.vacation_rules()\n            \u0026\u0026 let Some(layoff_periods) = \u0026vacation_rules.layoff_periods\n        {\n            for layoff_period in layoff_periods {\n                if let (Ok(layoff_start), Ok(layoff_end)) = (\n                    chrono::NaiveDate::parse_from_str(\u0026layoff_period.start_date, \"%Y-%m-%d\")\n                        .map(|d| d.and_hms_opt(0, 0, 0).unwrap())\n                        .map(|dt| DateTime::\u003cLocal\u003e::from_naive_utc_and_offset(dt, *start_date.offset())),\n                    chrono::NaiveDate::parse_from_str(\u0026layoff_period.end_date, \"%Y-%m-%d\")\n                        .map(|d| d.and_hms_opt(23, 59, 59).unwrap())\n                        .map(|dt| DateTime::\u003cLocal\u003e::from_naive_utc_and_offset(dt, *end_date.offset())),\n                ) \u0026\u0026 start_date \u003c= \u0026layoff_end\n                    \u0026\u0026 end_date \u003e= \u0026layoff_start\n                {\n                    return true;\n                }\n            }\n        }\n\n        false\n    }\n\n    fn get_next_code(\u0026self, resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n        let all_resources = self.find_all()?;\n        let prefix = resource_type.to_lowercase();\n        let prefix_with_dash = format!(\"{prefix}-\");\n\n        let max_num = all_resources\n            .iter()\n            .map(|r| match r {\n                AnyResource::Available(res) =\u003e (\u0026res.code, \u0026res.resource_type),\n                AnyResource::Assigned(res) =\u003e (\u0026res.code, \u0026res.resource_type),\n                AnyResource::Inactive(res) =\u003e (\u0026res.code, \u0026res.resource_type),\n            })\n            .filter(|(_, r_type)| r_type.to_lowercase() == prefix)\n            .filter_map(|(code, _)| code.strip_prefix(\u0026prefix_with_dash))\n            .filter_map(|num_str| num_str.parse::\u003cu32\u003e().ok())\n            .max()\n            .unwrap_or(0);\n\n        Ok(format!(\"{}{}\", prefix_with_dash, max_num + 1))\n    }\n}\n\nimpl Default for FileResourceRepository {\n    fn default() -\u003e Self {\n        Self::new(\".\")\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::resource_management::resource::Resource;\n    use crate::domain::resource_management::state::Available;\n    use crate::infrastructure::persistence::manifests::resource_manifest::ResourceManifest;\n    use std::fs;\n    use tempfile::tempdir;\n\n    fn create_test_resource(name: \u0026str, code: \u0026str, resource_type: \u0026str) -\u003e Resource\u003cAvailable\u003e {\n        Resource::new(\n            code.to_string(),\n            name.to_string(),\n            None,\n            resource_type.to_string(),\n            None,\n            0,\n        )\n    }\n\n    fn create_test_resource_manifest(name: \u0026str, code: \u0026str, resource_type: \u0026str) -\u003e ResourceManifest {\n        ResourceManifest {\n            api_version: \"tasktaskrevolution.io/v1alpha1\".to_string(),\n            kind: \"Resource\".to_string(),\n            metadata: crate::infrastructure::persistence::manifests::resource_manifest::ResourceMetadata {\n                id: Some(uuid7::uuid7().to_string()),\n                code: code.to_string(),\n                name: name.to_string(),\n                email: \"test@example.com\".to_string(),\n                resource_type: resource_type.to_string(),\n            },\n            spec: crate::infrastructure::persistence::manifests::resource_manifest::ResourceSpec {\n                time_off_balance: 0,\n                time_off_history: None,\n                project_assignments: None,\n                vacations: None,\n            },\n        }\n    }\n\n    #[test]\n    fn test_save_and_find_all() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        let resource1 = create_test_resource(\"test1\", \"dev-1\", \"dev\");\n        let resource2 = create_test_resource(\"test2\", \"dev-2\", \"dev\");\n\n        repo.save(resource1.clone().into()).unwrap();\n        repo.save(resource2.clone().into()).unwrap();\n\n        let resources = repo.find_all().unwrap();\n        assert_eq!(resources.len(), 2);\n        assert!(resources.iter().any(|r| r.name() == \"test1\"));\n        assert!(resources.iter().any(|r| r.name() == \"test2\"));\n    }\n\n    #[test]\n    fn test_save_vacation() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        let resource = create_test_resource(\"test\", \"dev-1\", \"dev\");\n        repo.save(resource.into()).unwrap();\n\n        let result = repo.save_vacation(\"test\", \"2024-01-01\", \"2024-01-31\", false, None);\n\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n\n        let vacations = match updated_resource {\n            AnyResource::Available(r) =\u003e r.vacations,\n            AnyResource::Assigned(r) =\u003e r.vacations,\n            AnyResource::Inactive(_) =\u003e None,\n        };\n        assert_eq!(vacations.unwrap().len(), 1);\n    }\n\n    #[test]\n    fn test_save_time_off() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        let resource = create_test_resource(\"test\", \"dev-1\", \"dev\");\n        repo.save(resource.into()).unwrap();\n\n        let result = repo.save_time_off(\"test\", 10, \"2024-01-01\", Some(\"Test time off\".to_string()));\n\n        assert!(result.is_ok());\n        let updated_resource = result.unwrap();\n        let balance = match updated_resource {\n            AnyResource::Available(r) =\u003e r.time_off_balance,\n            AnyResource::Assigned(r) =\u003e r.time_off_balance,\n            AnyResource::Inactive(r) =\u003e r.time_off_balance,\n        };\n        assert_eq!(balance, 10);\n    }\n\n    #[test]\n    fn test_get_next_code() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        // Test with no resources of a type\n        assert_eq!(repo.get_next_code(\"dev\").unwrap(), \"dev-1\");\n\n        // Add some resources\n        repo.save(create_test_resource(\"res1\", \"dev-1\", \"dev\").into()).unwrap();\n        repo.save(create_test_resource(\"res2\", \"qa-1\", \"qa\").into()).unwrap();\n        repo.save(create_test_resource(\"res3\", \"dev-2\", \"dev\").into()).unwrap();\n        repo.save(create_test_resource(\"res4\", \"dev-5\", \"dev\").into()) // Test with a gap\n            .unwrap();\n\n        // Test again for both types\n        assert_eq!(repo.get_next_code(\"dev\").unwrap(), \"dev-6\");\n        assert_eq!(repo.get_next_code(\"qa\").unwrap(), \"qa-2\");\n        assert_eq!(repo.get_next_code(\"manager\").unwrap(), \"manager-1\"); // Test new type\n    }\n\n    #[test]\n    fn test_resource_manifest_serialization() {\n        let manifest = create_test_resource_manifest(\"Test Resource\", \"TEST-001\", \"developer\");\n\n        let yaml = serde_yaml::to_string(\u0026manifest).expect(\"Failed to serialize to YAML\");\n        let deserialized: ResourceManifest = serde_yaml::from_str(\u0026yaml).expect(\"Failed to deserialize from YAML\");\n\n        assert_eq!(manifest.metadata.code, deserialized.metadata.code);\n        assert_eq!(manifest.metadata.name, deserialized.metadata.name);\n        assert_eq!(manifest.metadata.resource_type, deserialized.metadata.resource_type);\n        assert_eq!(manifest.metadata.email, deserialized.metadata.email);\n    }\n\n    #[test]\n    fn test_resource_repository_save_and_verify() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        let resource = create_test_resource(\"Test Resource\", \"TEST-001\", \"developer\");\n\n        // Save resource\n        let save_result = repo.save(resource.clone().into());\n        assert!(save_result.is_ok(), \"Failed to save resource: {:?}\", save_result);\n\n        // Verify resource was saved by checking file exists\n        let resource_file = temp_dir.path().join(\"resources\").join(\"test_resource.yaml\");\n        assert!(resource_file.exists(), \"Resource file should exist after save\");\n\n        // Verify resource directory structure\n        let resources_dir = temp_dir.path().join(\"resources\");\n        assert!(resources_dir.exists(), \"Resources directory should exist\");\n    }\n\n    #[test]\n    fn test_resource_repository_save_multiple_resources() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        // Create and save multiple resources\n        let resource1 = create_test_resource(\"Developer 1\", \"DEV-001\", \"developer\");\n        let resource2 = create_test_resource(\"QA Engineer\", \"QA-001\", \"qa\");\n        let resource3 = create_test_resource(\"Manager\", \"MGR-001\", \"manager\");\n\n        repo.save(resource1.into()).expect(\"Failed to save resource 1\");\n        repo.save(resource2.into()).expect(\"Failed to save resource 2\");\n        repo.save(resource3.into()).expect(\"Failed to save resource 3\");\n\n        // Verify all resources were saved by checking files exist\n        let dev_file = temp_dir.path().join(\"resources\").join(\"developer_1.yaml\");\n        let qa_file = temp_dir.path().join(\"resources\").join(\"qa_engineer.yaml\");\n        let mgr_file = temp_dir.path().join(\"resources\").join(\"manager.yaml\");\n\n        assert!(dev_file.exists(), \"Developer file should exist\");\n        assert!(qa_file.exists(), \"QA file should exist\");\n        assert!(mgr_file.exists(), \"Manager file should exist\");\n    }\n\n    #[test]\n    fn test_resource_repository_find_by_code() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        let resource = create_test_resource(\"Test Resource\", \"TEST-001\", \"developer\");\n        repo.save(resource.clone().into()).expect(\"Failed to save resource\");\n\n        // Find resource by code\n        let found_resource = repo.find_by_code(\"TEST-001\");\n        assert!(\n            found_resource.is_ok(),\n            \"Failed to find resource by code: {:?}\",\n            found_resource\n        );\n\n        let found_resource = found_resource.unwrap();\n        assert!(found_resource.is_some(), \"Resource should be found\");\n\n        let found_resource = found_resource.unwrap();\n        assert_eq!(found_resource.code(), \"TEST-001\");\n        assert_eq!(found_resource.name(), \"Test Resource\");\n    }\n\n    #[test]\n    fn test_resource_repository_error_handling() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        // Try to find non-existent resource\n        let result = repo.find_by_code(\"NON-EXISTENT\");\n        assert!(result.is_ok(), \"Should return Ok(None) for non-existent resource\");\n        assert!(\n            result.unwrap().is_none(),\n            \"Should return None for non-existent resource\"\n        );\n    }\n\n    #[test]\n    fn test_resource_repository_file_corruption_handling() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        let resource = create_test_resource(\"Test Resource\", \"TEST-001\", \"developer\");\n        repo.save(resource.clone().into()).expect(\"Failed to save resource\");\n\n        // Corrupt the YAML file\n        let resource_file = temp_dir.path().join(\"resources\").join(\"test_resource.yaml\");\n        fs::write(\u0026resource_file, \"invalid: yaml: content: [\").expect(\"Failed to corrupt file\");\n\n        // Note: We can't test loading corrupted files yet since find_by_code is not fully implemented\n        // This test verifies that we can save resources and corrupt files\n        assert!(resource_file.exists(), \"Resource file should exist even if corrupted\");\n    }\n\n    #[test]\n    fn test_resource_repository_concurrent_access() {\n        let temp_dir = tempdir().unwrap();\n\n        // Create multiple resources concurrently\n        let mut handles = vec![];\n\n        for i in 1..=5 {\n            let temp_dir = temp_dir.path().to_path_buf();\n            let handle = std::thread::spawn(move || {\n                let repo = FileResourceRepository::new(temp_dir);\n                let resource = create_test_resource(\u0026format!(\"Resource {}\", i), \u0026format!(\"RES-{:03}\", i), \"developer\");\n                repo.save(resource.into())\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all threads to complete\n        for handle in handles {\n            let result = handle.join().expect(\"Thread failed to complete\");\n            assert!(\n                result.is_ok(),\n                \"Failed to save resource in concurrent access: {:?}\",\n                result\n            );\n        }\n\n        // Verify all resources were saved by checking files exist\n        for i in 1..=5 {\n            let resource_file = temp_dir.path().join(\"resources\").join(format!(\"resource_{}.yaml\", i));\n            assert!(resource_file.exists(), \"Resource {} file should exist\", i);\n        }\n    }\n\n    #[test]\n    fn test_resource_repository_vacation_validation() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        let resource = create_test_resource(\"Test Resource\", \"TEST-001\", \"developer\");\n        repo.save(resource.into()).expect(\"Failed to save resource\");\n\n        // Test invalid date range (end date before start date)\n        let result = repo.save_vacation(\"Test Resource\", \"2024-12-31\", \"2024-01-01\", false, None);\n        assert!(result.is_err(), \"Should return error for invalid date range\");\n\n        // Test valid date range\n        let result = repo.save_vacation(\"Test Resource\", \"2024-01-01\", \"2024-12-31\", false, None);\n        assert!(result.is_ok(), \"Should succeed with valid date range\");\n    }\n\n    #[test]\n    fn test_resource_repository_time_off_accumulation() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileResourceRepository::new(temp_dir.path());\n\n        let resource = create_test_resource(\"Test Resource\", \"TEST-001\", \"developer\");\n        repo.save(resource.into()).expect(\"Failed to save resource\");\n\n        // Add multiple time off entries\n        repo.save_time_off(\"Test Resource\", 8, \"2024-01-01\", Some(\"Morning off\".to_string()))\n            .expect(\"Failed to save time off 1\");\n        repo.save_time_off(\"Test Resource\", 4, \"2024-01-02\", Some(\"Afternoon off\".to_string()))\n            .expect(\"Failed to save time off 2\");\n\n        // Verify total balance\n        let updated_resource = repo\n            .find_by_name(\"Test Resource\")\n            .expect(\"Failed to find resource\")\n            .unwrap();\n        let balance = match updated_resource {\n            AnyResource::Available(r) =\u003e r.time_off_balance,\n            AnyResource::Assigned(r) =\u003e r.time_off_balance,\n            AnyResource::Inactive(r) =\u003e r.time_off_balance,\n        };\n        assert_eq!(balance, 12, \"Time off balance should accumulate\");\n    }\n}\n","traces":[{"line":24,"address":[1431392,1431248,1431297,1431441,1431536,1431690],"length":1,"stats":{"Line":2}},{"line":26,"address":[1431271,1431333,1431477,1431415,1431622,1431563],"length":1,"stats":{"Line":4}},{"line":30,"address":[2485332,2485338,2484736],"length":1,"stats":{"Line":2}},{"line":31,"address":[2484800,2484845],"length":1,"stats":{"Line":5}},{"line":33,"address":[2484862],"length":1,"stats":{"Line":0}},{"line":36,"address":[2486793,2485360,2486780],"length":1,"stats":{"Line":1}},{"line":37,"address":[2485401],"length":1,"stats":{"Line":2}},{"line":38,"address":[2485432,2485509],"length":1,"stats":{"Line":4}},{"line":39,"address":[2485535],"length":1,"stats":{"Line":0}},{"line":41,"address":[1432423,1431712,1432417],"length":1,"stats":{"Line":6}},{"line":42,"address":[1432008,1431739,1432323],"length":1,"stats":{"Line":0}},{"line":43,"address":[1431747],"length":1,"stats":{"Line":0}},{"line":44,"address":[1431976,1431819,1431898],"length":1,"stats":{"Line":0}},{"line":46,"address":[1432104,1432156,1432180,1432344,1432407],"length":1,"stats":{"Line":0}},{"line":48,"address":[1432448,1432787,1432793],"length":1,"stats":{"Line":4}},{"line":49,"address":[1432699],"length":1,"stats":{"Line":0}},{"line":50,"address":[1432470],"length":1,"stats":{"Line":0}},{"line":51,"address":[1432597,1432552],"length":1,"stats":{"Line":0}},{"line":54,"address":[1433159,1432816],"length":1,"stats":{"Line":4}},{"line":55,"address":[1433071],"length":1,"stats":{"Line":0}},{"line":56,"address":[1432838],"length":1,"stats":{"Line":0}},{"line":57,"address":[1432912,1432969],"length":1,"stats":{"Line":0}},{"line":60,"address":[2486652],"length":1,"stats":{"Line":1}},{"line":63,"address":[2488296,2488283,2486816],"length":1,"stats":{"Line":0}},{"line":64,"address":[2486883],"length":1,"stats":{"Line":0}},{"line":65,"address":[2486937,2487020],"length":1,"stats":{"Line":0}},{"line":66,"address":[2487046],"length":1,"stats":{"Line":0}},{"line":69,"address":[2487301,2487142,2488291,2487100],"length":1,"stats":{"Line":0}},{"line":70,"address":[1433303,1433205,1433570],"length":1,"stats":{"Line":0}},{"line":71,"address":[1433213],"length":1,"stats":{"Line":0}},{"line":72,"address":[1433295],"length":1,"stats":{"Line":0}},{"line":74,"address":[1433591,1433425,1433635,1433401],"length":1,"stats":{"Line":0}},{"line":76,"address":[1433664,1434003,1434009],"length":1,"stats":{"Line":0}},{"line":77,"address":[1433915],"length":1,"stats":{"Line":0}},{"line":78,"address":[1433686],"length":1,"stats":{"Line":0}},{"line":79,"address":[1433768,1433813],"length":1,"stats":{"Line":0}},{"line":82,"address":[1434375,1434032],"length":1,"stats":{"Line":0}},{"line":83,"address":[1434287],"length":1,"stats":{"Line":0}},{"line":84,"address":[1434054],"length":1,"stats":{"Line":0}},{"line":85,"address":[1434128,1434185],"length":1,"stats":{"Line":0}},{"line":88,"address":[2488155],"length":1,"stats":{"Line":0}},{"line":93,"address":[2489850,2488320,2489768],"length":1,"stats":{"Line":1}},{"line":94,"address":[2488488,2488363],"length":1,"stats":{"Line":3}},{"line":95,"address":[2488516,2488577],"length":1,"stats":{"Line":7}},{"line":96,"address":[1434745,1434739,1434400],"length":1,"stats":{"Line":7}},{"line":97,"address":[1434651],"length":1,"stats":{"Line":0}},{"line":98,"address":[1434422],"length":1,"stats":{"Line":0}},{"line":99,"address":[1434504,1434549],"length":1,"stats":{"Line":0}},{"line":103,"address":[2489245,2488924,2488992,2489702],"length":1,"stats":{"Line":5}},{"line":104,"address":[1435154,1434789,1434887],"length":1,"stats":{"Line":0}},{"line":105,"address":[1434797],"length":1,"stats":{"Line":0}},{"line":106,"address":[1434879],"length":1,"stats":{"Line":0}},{"line":108,"address":[1434985,1435009,1435219,1435175],"length":1,"stats":{"Line":0}},{"line":111,"address":[1435709,1435248,1435715],"length":1,"stats":{"Line":3}},{"line":112,"address":[1435634,1435367,1435269],"length":1,"stats":{"Line":0}},{"line":113,"address":[1435277],"length":1,"stats":{"Line":0}},{"line":114,"address":[1435359],"length":1,"stats":{"Line":0}},{"line":116,"address":[1435655,1435489,1435465,1435699],"length":1,"stats":{"Line":0}},{"line":119,"address":[2489577],"length":1,"stats":{"Line":3}},{"line":122,"address":[2492763,2489888,2492647],"length":1,"stats":{"Line":1}},{"line":123,"address":[2489947],"length":1,"stats":{"Line":1}},{"line":124,"address":[2490017,2490100,2490366,2490223,2492761],"length":1,"stats":{"Line":3}},{"line":125,"address":[2490200,2490270],"length":1,"stats":{"Line":1}},{"line":126,"address":[2490599],"length":1,"stats":{"Line":1}},{"line":128,"address":[2490908,2490647,2490814],"length":1,"stats":{"Line":4}},{"line":129,"address":[1435824,1435851],"length":1,"stats":{"Line":2}},{"line":130,"address":[2491415,2491486],"length":1,"stats":{"Line":2}},{"line":131,"address":[1435984,1436445,1436451],"length":1,"stats":{"Line":1}},{"line":132,"address":[1436103,1436370,1436005],"length":1,"stats":{"Line":0}},{"line":133,"address":[1436013],"length":1,"stats":{"Line":0}},{"line":134,"address":[1436095],"length":1,"stats":{"Line":0}},{"line":136,"address":[1436435,1436225,1436201,1436391],"length":1,"stats":{"Line":0}},{"line":139,"address":[2491875,2492073,2491796,2492653],"length":1,"stats":{"Line":3}},{"line":140,"address":[1436715],"length":1,"stats":{"Line":0}},{"line":141,"address":[1436486],"length":1,"stats":{"Line":0}},{"line":142,"address":[1436568,1436613],"length":1,"stats":{"Line":0}},{"line":146,"address":[1436832,1437175],"length":1,"stats":{"Line":4}},{"line":147,"address":[1437087],"length":1,"stats":{"Line":0}},{"line":148,"address":[1436854],"length":1,"stats":{"Line":0}},{"line":149,"address":[1436928,1436985],"length":1,"stats":{"Line":0}},{"line":154,"address":[2491030],"length":1,"stats":{"Line":2}},{"line":157,"address":[2492784,2493652,2493658],"length":1,"stats":{"Line":1}},{"line":160,"address":[2492819],"length":1,"stats":{"Line":1}},{"line":161,"address":[2493011,2493236,2493109],"length":1,"stats":{"Line":3}},{"line":162,"address":[2493457,2493313],"length":1,"stats":{"Line":2}},{"line":163,"address":[2493571],"length":1,"stats":{"Line":1}},{"line":166,"address":[2493350],"length":1,"stats":{"Line":1}},{"line":169,"address":[2493696,2494842,2495403],"length":1,"stats":{"Line":1}},{"line":176,"address":[2494274,2493792,2495359,2495401,2493888],"length":1,"stats":{"Line":2}},{"line":177,"address":[1437258,1437389,1437216],"length":1,"stats":{"Line":0}},{"line":178,"address":[1437224],"length":1,"stats":{"Line":0}},{"line":180,"address":[1437410,1437327,1437351,1437456],"length":1,"stats":{"Line":0}},{"line":183,"address":[2494390],"length":1,"stats":{"Line":1}},{"line":184,"address":[2494453],"length":1,"stats":{"Line":1}},{"line":185,"address":[2494492,2494642,2494725],"length":1,"stats":{"Line":2}},{"line":186,"address":[2494649],"length":1,"stats":{"Line":2}},{"line":188,"address":[2494514],"length":1,"stats":{"Line":0}},{"line":189,"address":[2494984,2494549,2494920],"length":1,"stats":{"Line":0}},{"line":190,"address":[2494927],"length":1,"stats":{"Line":0}},{"line":192,"address":[2494574],"length":1,"stats":{"Line":0}},{"line":193,"address":[2495049,2494613,2495135],"length":1,"stats":{"Line":0}},{"line":194,"address":[2495056],"length":1,"stats":{"Line":0}},{"line":197,"address":[2494815],"length":1,"stats":{"Line":1}},{"line":200,"address":[2498002,2499112,2495424],"length":1,"stats":{"Line":1}},{"line":208,"address":[1437710,1437735,1437472],"length":1,"stats":{"Line":1}},{"line":209,"address":[1437488,1437530,1437661],"length":1,"stats":{"Line":0}},{"line":210,"address":[1437496],"length":1,"stats":{"Line":0}},{"line":212,"address":[1437623,1437599,1437682,1437728],"length":1,"stats":{"Line":0}},{"line":215,"address":[2496183,2496262,2496055,2496398,2498978],"length":1,"stats":{"Line":6}},{"line":216,"address":[2496239],"length":1,"stats":{"Line":2}},{"line":217,"address":[1437884],"length":1,"stats":{"Line":0}},{"line":218,"address":[1437767],"length":1,"stats":{"Line":0}},{"line":224,"address":[2496774,2496638,2498973,2496526],"length":1,"stats":{"Line":2}},{"line":225,"address":[1437952],"length":1,"stats":{"Line":1}},{"line":226,"address":[1438092],"length":1,"stats":{"Line":0}},{"line":227,"address":[1437975],"length":1,"stats":{"Line":0}},{"line":233,"address":[2496886],"length":1,"stats":{"Line":1}},{"line":234,"address":[2498856],"length":1,"stats":{"Line":1}},{"line":235,"address":[2496946],"length":1,"stats":{"Line":1}},{"line":239,"address":[2496927,2496980],"length":1,"stats":{"Line":2}},{"line":240,"address":[2497035],"length":1,"stats":{"Line":1}},{"line":241,"address":[2497096],"length":1,"stats":{"Line":1}},{"line":243,"address":[2497174],"length":1,"stats":{"Line":1}},{"line":255,"address":[2497349],"length":1,"stats":{"Line":2}},{"line":256,"address":[1438203],"length":1,"stats":{"Line":1}},{"line":257,"address":[1438218],"length":1,"stats":{"Line":1}},{"line":258,"address":[1438307],"length":1,"stats":{"Line":1}},{"line":261,"address":[2497397],"length":1,"stats":{"Line":1}},{"line":262,"address":[2497470],"length":1,"stats":{"Line":1}},{"line":263,"address":[2497508,2497820],"length":1,"stats":{"Line":2}},{"line":264,"address":[2497868],"length":1,"stats":{"Line":1}},{"line":266,"address":[2497606],"length":1,"stats":{"Line":0}},{"line":267,"address":[2497644,2498127],"length":1,"stats":{"Line":0}},{"line":268,"address":[2498175],"length":1,"stats":{"Line":0}},{"line":271,"address":[2498494,2498673,2498725],"length":1,"stats":{"Line":0}},{"line":272,"address":[2497742],"length":1,"stats":{"Line":0}},{"line":273,"address":[2498419],"length":1,"stats":{"Line":0}},{"line":275,"address":[2498601,2498632,2498846,2498705],"length":1,"stats":{"Line":0}},{"line":279,"address":[2497975],"length":1,"stats":{"Line":1}},{"line":282,"address":[2500557,2500634,2499168],"length":1,"stats":{"Line":1}},{"line":283,"address":[2499199],"length":1,"stats":{"Line":1}},{"line":285,"address":[2499285,2499238,2499358,2500614],"length":1,"stats":{"Line":3}},{"line":286,"address":[2499463,2499406],"length":1,"stats":{"Line":0}},{"line":287,"address":[2499578,2499523],"length":1,"stats":{"Line":0}},{"line":289,"address":[2499586],"length":1,"stats":{"Line":0}},{"line":290,"address":[2500183],"length":1,"stats":{"Line":0}},{"line":291,"address":[2499893,2499714],"length":1,"stats":{"Line":0}},{"line":292,"address":[2499982],"length":1,"stats":{"Line":0}},{"line":293,"address":[1438480,1438504],"length":1,"stats":{"Line":0}},{"line":294,"address":[2500025],"length":1,"stats":{"Line":0}},{"line":295,"address":[1438576,1438593],"length":1,"stats":{"Line":0}},{"line":296,"address":[2500152],"length":1,"stats":{"Line":0}},{"line":297,"address":[2500349],"length":1,"stats":{"Line":0}},{"line":298,"address":[2500405],"length":1,"stats":{"Line":0}},{"line":300,"address":[2500453],"length":1,"stats":{"Line":0}},{"line":305,"address":[2499857],"length":1,"stats":{"Line":1}},{"line":308,"address":[2500656,2501723,2501729],"length":1,"stats":{"Line":1}},{"line":309,"address":[2500707],"length":1,"stats":{"Line":1}},{"line":310,"address":[2500893],"length":1,"stats":{"Line":1}},{"line":311,"address":[2500949,2501017],"length":1,"stats":{"Line":2}},{"line":313,"address":[2501376,2501122],"length":1,"stats":{"Line":2}},{"line":315,"address":[1438752,1438767],"length":1,"stats":{"Line":3}},{"line":316,"address":[1438833],"length":1,"stats":{"Line":1}},{"line":317,"address":[1438866],"length":1,"stats":{"Line":0}},{"line":318,"address":[1438895],"length":1,"stats":{"Line":0}},{"line":320,"address":[1438962,1438944],"length":1,"stats":{"Line":3}},{"line":321,"address":[1439104,1439141],"length":1,"stats":{"Line":3}},{"line":322,"address":[1439184,1439229],"length":1,"stats":{"Line":3}},{"line":326,"address":[2501383],"length":1,"stats":{"Line":1}},{"line":331,"address":[2501744],"length":1,"stats":{"Line":0}},{"line":332,"address":[2501752],"length":1,"stats":{"Line":0}}],"covered":80,"coverable":171},{"path":["/","home","flavio","projects","tasktaskrevolution","src","infrastructure","persistence","task_repository.rs"],"content":"use crate::{\n    domain::{\n        shared::errors::{DomainError, DomainErrorKind},\n        task_management::{AnyTask, repository::TaskRepository},\n    },\n    infrastructure::persistence::manifests::task_manifest::TaskManifest,\n};\nuse glob::glob;\nuse serde_yaml;\nuse std::{\n    fs,\n    path::{Path, PathBuf},\n};\n\npub struct FileTaskRepository {\n    base_path: PathBuf,\n}\n\nimpl FileTaskRepository {\n    pub fn new\u003cP: AsRef\u003cPath\u003e\u003e(base_path: P) -\u003e Self {\n        Self {\n            base_path: base_path.as_ref().to_path_buf(),\n        }\n    }\n\n    fn get_task_file_path(\u0026self, task_name: \u0026str) -\u003e PathBuf {\n        self.base_path\n            .join(\"tasks\")\n            .join(format!(\"{}.yaml\", task_name.replace(' ', \"_\").to_lowercase()))\n    }\n\n    fn load_manifest(\u0026self, path: \u0026Path) -\u003e Result\u003cTaskManifest, Box\u003cdyn std::error::Error\u003e\u003e {\n        let yaml = fs::read_to_string(path)?;\n        serde_yaml::from_str(\u0026yaml).map_err(|e| e.into())\n    }\n}\n\nimpl TaskRepository for FileTaskRepository {\n    fn save(\u0026self, task: AnyTask) -\u003e Result\u003cAnyTask, DomainError\u003e {\n        let file_path = self.get_task_file_path(task.name());\n        let task_manifest = TaskManifest::from(task.clone());\n        let yaml = serde_yaml::to_string(\u0026task_manifest).map_err(|e| {\n            DomainError::new(DomainErrorKind::Serialization {\n                format: \"YAML\".to_string(),\n                details: format!(\"Error serializing task: {}\", e),\n            })\n        })?;\n\n        fs::create_dir_all(file_path.parent().unwrap()).map_err(|e| {\n            DomainError::new(DomainErrorKind::Io {\n                operation: \"file operation\".to_string(),\n                path: None,\n            })\n            .with_context(format!(\"Error creating directory: {e}\"))\n        })?;\n\n        fs::write(file_path, yaml).map_err(|e| {\n            DomainError::new(DomainErrorKind::Io {\n                operation: \"file operation\".to_string(),\n                path: None,\n            })\n            .with_context(format!(\"Error saving task: {e}\"))\n        })?;\n\n        Ok(task)\n    }\n\n    fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyTask\u003e, DomainError\u003e {\n        let pattern = self.base_path.join(\"**/tasks/**/*.yaml\");\n        let walker = glob(pattern.to_str().unwrap())\n            .map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n        let mut tasks = Vec::new();\n\n        for entry in walker {\n            let entry = entry.map_err(|e| DomainError::new(DomainErrorKind::Generic { message: e.to_string() }))?;\n            let file_path = entry.as_path();\n            let yaml = fs::read_to_string(file_path).map_err(|e| {\n                DomainError::new(DomainErrorKind::Io {\n                    operation: \"file operation\".to_string(),\n                    path: None,\n                })\n                .with_context(format!(\"Error reading task file: {e}\"))\n            })?;\n\n            let task_manifest: TaskManifest = serde_yaml::from_str(\u0026yaml).map_err(|e| {\n                DomainError::new(DomainErrorKind::Serialization {\n                    format: \"YAML\".to_string(),\n                    details: format!(\"Error deserializing task: {}\", e),\n                })\n            })?;\n\n            tasks.push(AnyTask::try_from(task_manifest).map_err(|e| {\n                DomainError::new(DomainErrorKind::Serialization {\n                    format: \"YAML\".to_string(),\n                    details: format!(\"Error converting manifest: {}\", e),\n                })\n            })?);\n        }\n\n        Ok(tasks)\n    }\n\n    fn find_by_code(\u0026self, code: \u0026str) -\u003e Result\u003cOption\u003cAnyTask\u003e, DomainError\u003e {\n        // Since tasks are saved by name, we need to search through all tasks\n        // to find one with the matching code\n        let all_tasks = self.find_all()?;\n        for task in all_tasks {\n            if task.code() == code {\n                return Ok(Some(task));\n            }\n        }\n        Ok(None)\n    }\n\n    fn find_by_project(\u0026self, project_code: \u0026str) -\u003e Result\u003cVec\u003cAnyTask\u003e, DomainError\u003e {\n        let all_tasks = self.find_all()?;\n        let project_tasks: Vec\u003cAnyTask\u003e = all_tasks\n            .into_iter()\n            .filter(|task| task.project_code() == project_code)\n            .collect();\n        Ok(project_tasks)\n    }\n\n    fn get_next_code(\u0026self, project_code: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n        let all_tasks = self.find_all()?;\n        let project_tasks: Vec\u003c\u0026AnyTask\u003e = all_tasks\n            .iter()\n            .filter(|task| task.project_code() == project_code)\n            .collect();\n\n        let max_code = project_tasks\n            .iter()\n            .filter_map(|task| {\n                let code = task.code();\n                if code.starts_with(\u0026format!(\"{}-\", project_code)) {\n                    code.strip_prefix(\u0026format!(\"{}-\", project_code))\n                        .and_then(|num_str| num_str.parse::\u003cu32\u003e().ok())\n                } else {\n                    None\n                }\n            })\n            .max()\n            .unwrap_or(0);\n\n        Ok(format!(\"{}-{}\", project_code, max_code + 1))\n    }\n}\n\nimpl Default for FileTaskRepository {\n    fn default() -\u003e Self {\n        Self::new(\".\")\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::task_management::{builder::TaskBuilder, state::Planned, task::Task};\n    use crate::infrastructure::persistence::manifests::task_manifest::TaskManifest;\n    use chrono::NaiveDate;\n    use std::fs;\n    use tempfile::tempdir;\n\n    fn create_test_task(name: \u0026str, code: \u0026str, project_code: \u0026str) -\u003e Task\u003cPlanned\u003e {\n        TaskBuilder::new()\n            .project_code(project_code.to_string())\n            .name(name.to_string())\n            .code(code.to_string())\n            .dates(\n                NaiveDate::from_ymd_opt(2024, 1, 1).unwrap(),\n                NaiveDate::from_ymd_opt(2024, 12, 31).unwrap(),\n            )\n            .unwrap()\n            .assign_resource(\"RES-001\")\n            .validate_vacations(\u0026[])\n            .unwrap()\n            .build()\n            .unwrap()\n    }\n\n    fn create_test_task_manifest(name: \u0026str, code: \u0026str, project_code: \u0026str) -\u003e TaskManifest {\n        // Create a simple task first, then convert it to manifest\n        let task = create_test_task(name, code, project_code);\n        let any_task: crate::domain::task_management::AnyTask = task.into();\n        TaskManifest::from(any_task)\n    }\n\n    #[test]\n    fn test_task_manifest_serialization() {\n        let manifest = create_test_task_manifest(\"Test Task\", \"TEST-001\", \"PROJ-001\");\n\n        let yaml = serde_yaml::to_string(\u0026manifest).expect(\"Failed to serialize to YAML\");\n        let deserialized: TaskManifest = serde_yaml::from_str(\u0026yaml).expect(\"Failed to deserialize from YAML\");\n\n        assert_eq!(manifest.metadata.code, deserialized.metadata.code);\n        assert_eq!(manifest.metadata.name, deserialized.metadata.name);\n        assert_eq!(manifest.spec.project_code, deserialized.spec.project_code);\n        assert!(matches!(\n            deserialized.spec.status,\n            crate::infrastructure::persistence::manifests::task_manifest::Status::Planned\n        ));\n    }\n\n    #[test]\n    fn test_task_repository_save_and_verify() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileTaskRepository::new(temp_dir.path());\n\n        let task = create_test_task(\"Test Task\", \"TEST-001\", \"PROJ-001\");\n\n        // Save task\n        let save_result = repo.save(task.clone().into());\n        assert!(save_result.is_ok(), \"Failed to save task: {:?}\", save_result);\n\n        // Verify task was saved by checking file exists\n        let task_file = temp_dir.path().join(\"tasks\").join(\"test_task.yaml\");\n        assert!(task_file.exists(), \"Task file should exist after save\");\n\n        // Verify task directory structure\n        let tasks_dir = temp_dir.path().join(\"tasks\");\n        assert!(tasks_dir.exists(), \"Tasks directory should exist\");\n    }\n\n    #[test]\n    fn test_task_repository_save_multiple_tasks() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileTaskRepository::new(temp_dir.path());\n\n        // Create and save multiple tasks\n        let task1 = create_test_task(\"Task 1\", \"TASK-001\", \"PROJ-001\");\n        let task2 = create_test_task(\"Task 2\", \"TASK-002\", \"PROJ-001\");\n        let task3 = create_test_task(\"Task 3\", \"TASK-003\", \"PROJ-002\");\n\n        repo.save(task1.into()).expect(\"Failed to save task 1\");\n        repo.save(task2.into()).expect(\"Failed to save task 2\");\n        repo.save(task3.into()).expect(\"Failed to save task 3\");\n\n        // Verify all tasks were saved by checking files exist\n        let task1_file = temp_dir.path().join(\"tasks\").join(\"task_1.yaml\");\n        let task2_file = temp_dir.path().join(\"tasks\").join(\"task_2.yaml\");\n        let task3_file = temp_dir.path().join(\"tasks\").join(\"task_3.yaml\");\n\n        assert!(task1_file.exists(), \"Task 1 file should exist\");\n        assert!(task2_file.exists(), \"Task 2 file should exist\");\n        assert!(task3_file.exists(), \"Task 3 file should exist\");\n    }\n\n    #[test]\n    fn test_task_repository_find_by_code() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileTaskRepository::new(temp_dir.path());\n\n        let task = create_test_task(\"Test Task\", \"TEST-001\", \"PROJ-001\");\n        repo.save(task.clone().into()).expect(\"Failed to save task\");\n\n        // Find task by code\n        let found_task = repo.find_by_code(\"TEST-001\");\n        assert!(found_task.is_ok(), \"Failed to find task by code: {:?}\", found_task);\n\n        let found_task = found_task.unwrap();\n        assert!(found_task.is_some(), \"Task should be found\");\n\n        let found_task = found_task.unwrap();\n        assert_eq!(found_task.code(), \"TEST-001\");\n        assert_eq!(found_task.name(), \"Test Task\");\n    }\n\n    #[test]\n    fn test_task_repository_find_by_project() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileTaskRepository::new(temp_dir.path());\n\n        // Create tasks for different projects\n        let task1 = create_test_task(\"Task 1\", \"TASK-001\", \"PROJ-001\");\n        let task2 = create_test_task(\"Task 2\", \"TASK-002\", \"PROJ-001\");\n        let task3 = create_test_task(\"Task 3\", \"TASK-003\", \"PROJ-002\");\n\n        repo.save(task1.into()).expect(\"Failed to save task 1\");\n        repo.save(task2.into()).expect(\"Failed to save task 2\");\n        repo.save(task3.into()).expect(\"Failed to save task 3\");\n\n        // Find tasks by project\n        let proj1_tasks = repo\n            .find_by_project(\"PROJ-001\")\n            .expect(\"Failed to find tasks for PROJ-001\");\n        let proj2_tasks = repo\n            .find_by_project(\"PROJ-002\")\n            .expect(\"Failed to find tasks for PROJ-002\");\n\n        assert_eq!(proj1_tasks.len(), 2, \"PROJ-001 should have 2 tasks\");\n        assert_eq!(proj2_tasks.len(), 1, \"PROJ-002 should have 1 task\");\n    }\n\n    #[test]\n    fn test_task_repository_error_handling() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileTaskRepository::new(temp_dir.path());\n\n        // Try to find non-existent task\n        let result = repo.find_by_code(\"NON-EXISTENT\");\n        assert!(result.is_ok(), \"Should return Ok(None) for non-existent task\");\n        assert!(result.unwrap().is_none(), \"Should return None for non-existent task\");\n    }\n\n    #[test]\n    fn test_task_repository_file_corruption_handling() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileTaskRepository::new(temp_dir.path());\n\n        let task = create_test_task(\"Test Task\", \"TEST-001\", \"PROJ-001\");\n        repo.save(task.clone().into()).expect(\"Failed to save task\");\n\n        // Corrupt the YAML file\n        let task_file = temp_dir.path().join(\"tasks\").join(\"test_task.yaml\");\n        fs::write(\u0026task_file, \"invalid: yaml: content: [\").expect(\"Failed to corrupt file\");\n\n        // Note: We can't test loading corrupted files yet since find_by_code is not fully implemented\n        // This test verifies that we can save tasks and corrupt files\n        assert!(task_file.exists(), \"Task file should exist even if corrupted\");\n    }\n\n    #[test]\n    fn test_task_repository_concurrent_access() {\n        let temp_dir = tempdir().unwrap();\n\n        // Create multiple tasks concurrently\n        let mut handles = vec![];\n\n        for i in 1..=5 {\n            let temp_dir = temp_dir.path().to_path_buf();\n            let handle = std::thread::spawn(move || {\n                let repo = FileTaskRepository::new(temp_dir);\n                let task = create_test_task(\u0026format!(\"Task {}\", i), \u0026format!(\"TASK-{:03}\", i), \"PROJ-001\");\n                repo.save(task.into())\n            });\n            handles.push(handle);\n        }\n\n        // Wait for all threads to complete\n        for handle in handles {\n            let result = handle.join().expect(\"Thread failed to complete\");\n            assert!(result.is_ok(), \"Failed to save task in concurrent access: {:?}\", result);\n        }\n\n        // Verify all tasks were saved by checking files exist\n        for i in 1..=5 {\n            let task_file = temp_dir.path().join(\"tasks\").join(format!(\"task_{}.yaml\", i));\n            assert!(task_file.exists(), \"Task {} file should exist\", i);\n        }\n    }\n\n    #[test]\n    fn test_task_repository_get_next_code() {\n        let temp_dir = tempdir().unwrap();\n        let repo = FileTaskRepository::new(temp_dir.path());\n\n        // Test with no tasks of a project\n        assert_eq!(repo.get_next_code(\"PROJ-001\").unwrap(), \"PROJ-001-1\");\n\n        // Add some tasks\n        repo.save(create_test_task(\"Task 1\", \"PROJ-001-1\", \"PROJ-001\").into())\n            .unwrap();\n        repo.save(create_test_task(\"Task 2\", \"PROJ-001-2\", \"PROJ-001\").into())\n            .unwrap();\n        repo.save(create_test_task(\"Task 3\", \"PROJ-001-5\", \"PROJ-001\").into())\n            .unwrap(); // Test with a gap\n\n        // Test again\n        assert_eq!(repo.get_next_code(\"PROJ-001\").unwrap(), \"PROJ-001-6\");\n        assert_eq!(repo.get_next_code(\"PROJ-002\").unwrap(), \"PROJ-002-1\"); // Test new project\n    }\n}\n","traces":[{"line":20,"address":[2648049,2647905,2647680,2647856,2648000,2647834],"length":1,"stats":{"Line":3}},{"line":22,"address":[2648023,2647766,2647879,2647707,2648085,2647941],"length":1,"stats":{"Line":6}},{"line":26,"address":[1877370,1877364,1876768],"length":1,"stats":{"Line":3}},{"line":27,"address":[1876832,1876877],"length":1,"stats":{"Line":7}},{"line":29,"address":[1876894],"length":1,"stats":{"Line":0}},{"line":32,"address":[1877392,1877739,1877733],"length":1,"stats":{"Line":0}},{"line":33,"address":[1877459],"length":1,"stats":{"Line":0}},{"line":34,"address":[1877682,1877611],"length":1,"stats":{"Line":0}},{"line":39,"address":[1877760,1879208,1879290],"length":1,"stats":{"Line":1}},{"line":40,"address":[1877928,1877803],"length":1,"stats":{"Line":7}},{"line":41,"address":[1877956,1878017],"length":1,"stats":{"Line":8}},{"line":42,"address":[1878040,1878259,1878100,1879214],"length":1,"stats":{"Line":8}},{"line":43,"address":[2648427],"length":1,"stats":{"Line":0}},{"line":44,"address":[2648198],"length":1,"stats":{"Line":0}},{"line":45,"address":[2648280,2648325],"length":1,"stats":{"Line":0}},{"line":49,"address":[1878364,1878432,1879142,1878685],"length":1,"stats":{"Line":5}},{"line":50,"address":[2648565,2648930,2648663],"length":1,"stats":{"Line":0}},{"line":51,"address":[2648573],"length":1,"stats":{"Line":0}},{"line":52,"address":[2648655],"length":1,"stats":{"Line":0}},{"line":54,"address":[2648785,2648951,2648761,2648995],"length":1,"stats":{"Line":0}},{"line":57,"address":[1878990,1879128,1878710],"length":1,"stats":{"Line":3}},{"line":58,"address":[2649143,2649045,2649410],"length":1,"stats":{"Line":0}},{"line":59,"address":[2649053],"length":1,"stats":{"Line":0}},{"line":60,"address":[2649135],"length":1,"stats":{"Line":0}},{"line":62,"address":[2649431,2649241,2649475,2649265],"length":1,"stats":{"Line":0}},{"line":65,"address":[1879017],"length":1,"stats":{"Line":1}},{"line":68,"address":[1882087,1882203,1879328],"length":1,"stats":{"Line":1}},{"line":69,"address":[1879387],"length":1,"stats":{"Line":1}},{"line":70,"address":[1879457,1879540,1879806,1879663,1882201],"length":1,"stats":{"Line":4}},{"line":71,"address":[1879640,1879710],"length":1,"stats":{"Line":1}},{"line":72,"address":[1880039],"length":1,"stats":{"Line":2}},{"line":74,"address":[1880254,1880087,1880348],"length":1,"stats":{"Line":4}},{"line":75,"address":[2649600,2649627],"length":1,"stats":{"Line":2}},{"line":76,"address":[1880855,1880926],"length":1,"stats":{"Line":2}},{"line":77,"address":[1882114,1881139,1880950],"length":1,"stats":{"Line":1}},{"line":78,"address":[2649781,2649879,2650146],"length":1,"stats":{"Line":0}},{"line":79,"address":[2649789],"length":1,"stats":{"Line":0}},{"line":80,"address":[2649871],"length":1,"stats":{"Line":0}},{"line":82,"address":[2650167,2650211,2649977,2650001],"length":1,"stats":{"Line":0}},{"line":85,"address":[2650585,2650579,2650240],"length":1,"stats":{"Line":2}},{"line":86,"address":[2650491],"length":1,"stats":{"Line":0}},{"line":87,"address":[2650262],"length":1,"stats":{"Line":0}},{"line":88,"address":[2650389,2650344],"length":1,"stats":{"Line":0}},{"line":92,"address":[2650608,2650951],"length":1,"stats":{"Line":2}},{"line":93,"address":[2650863],"length":1,"stats":{"Line":0}},{"line":94,"address":[2650630],"length":1,"stats":{"Line":0}},{"line":95,"address":[2650761,2650704],"length":1,"stats":{"Line":0}},{"line":100,"address":[1880470],"length":1,"stats":{"Line":1}},{"line":103,"address":[1882224,1883092,1883098],"length":1,"stats":{"Line":1}},{"line":106,"address":[1882259],"length":1,"stats":{"Line":1}},{"line":107,"address":[1882451,1882549,1882676],"length":1,"stats":{"Line":3}},{"line":108,"address":[1882753,1882897],"length":1,"stats":{"Line":2}},{"line":109,"address":[1883011],"length":1,"stats":{"Line":1}},{"line":112,"address":[1882790],"length":1,"stats":{"Line":1}},{"line":115,"address":[1883596,1883571,1883136],"length":1,"stats":{"Line":1}},{"line":116,"address":[1883170,1883294],"length":1,"stats":{"Line":2}},{"line":117,"address":[1883354],"length":1,"stats":{"Line":1}},{"line":119,"address":[2651008,2650976],"length":1,"stats":{"Line":3}},{"line":121,"address":[1883507],"length":1,"stats":{"Line":1}},{"line":124,"address":[1883616,1884470,1884464],"length":1,"stats":{"Line":1}},{"line":125,"address":[1883651],"length":1,"stats":{"Line":1}},{"line":126,"address":[1883835],"length":1,"stats":{"Line":1}},{"line":128,"address":[1883939],"length":1,"stats":{"Line":3}},{"line":131,"address":[1883977,1884143],"length":1,"stats":{"Line":2}},{"line":133,"address":[1884084],"length":1,"stats":{"Line":2}},{"line":134,"address":[2651148],"length":1,"stats":{"Line":1}},{"line":135,"address":[2651203,2651428],"length":1,"stats":{"Line":1}},{"line":136,"address":[2651455,2651698],"length":1,"stats":{"Line":2}},{"line":137,"address":[2651758,2651706,2651744,2651626],"length":1,"stats":{"Line":3}},{"line":139,"address":[2651420],"length":1,"stats":{"Line":0}},{"line":145,"address":[1884150],"length":1,"stats":{"Line":1}},{"line":150,"address":[1884496],"length":1,"stats":{"Line":0}},{"line":151,"address":[1884504],"length":1,"stats":{"Line":0}}],"covered":45,"coverable":73},{"path":["/","home","flavio","projects","tasktaskrevolution","src","interface","assets.rs"],"content":"use rust_embed::RustEmbed;\n\n#[derive(RustEmbed)]\n#[folder = \"templates/\"]\npub struct TemplateAssets;\n\n#[derive(RustEmbed)]\n#[folder = \"static/\"]\npub struct StaticAssets;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","interface","cli.rs"],"content":"use crate::domain::company_settings::repository::ConfigRepository;\nuse crate::{\n    application::{\n        build_use_case::BuildUseCase,\n        create::{\n            project::CreateProjectUseCase, resource::CreateResourceUseCase, task::CreateTaskArgs,\n            task::CreateTaskUseCase, time_off::CreateTimeOffUseCase, vacation::CreateVacationUseCase,\n        },\n        initialize_repository_use_case::InitializeRepositoryUseCase,\n        list::{projects::ListProjectsUseCase, resources::ListResourcesUseCase, tasks::ListTasksUseCase},\n        project::assign_resource_to_task::AssignResourceToTaskUseCase,\n        project::{\n            cancel_project::CancelProjectUseCase,\n            describe_project::DescribeProjectUseCase,\n            update_project::{UpdateProjectArgs, UpdateProjectUseCase},\n        },\n        report::{task::TaskReportUseCase, vacation::VacationReportUseCase},\n        resource::{\n            deactivate_resource::DeactivateResourceUseCase,\n            describe_resource::DescribeResourceUseCase,\n            update_resource::{UpdateResourceArgs, UpdateResourceUseCase},\n        },\n        task::{\n            delete_task::CancelTaskUseCase,\n            describe_task::DescribeTaskUseCase,\n            link_task::LinkTaskUseCase,\n            update_task::{UpdateTaskArgs, UpdateTaskUseCase},\n        },\n        validate::vacations::ValidateVacationsUseCase,\n    },\n    infrastructure::persistence::{\n        config_repository::FileConfigRepository, project_repository::FileProjectRepository,\n        resource_repository::FileResourceRepository,\n    },\n};\nuse clap::{Parser, Subcommand};\nuse csv::Writer;\nuse serde::Deserialize;\nuse std::{env, path::PathBuf};\n\n#[derive(Parser)]\n#[clap(author = env!(\"CARGO_PKG_AUTHORS\"),\n    version = env!(\"CARGO_PKG_VERSION\"),\n    about = env!(\"CARGO_PKG_DESCRIPTION\"),\n    long_about = None)]\n#[clap(propagate_version = true)]\npub struct Cli {\n    #[clap(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    Init {\n        path: Option\u003cPathBuf\u003e,\n        #[clap(long, value_name = \"NAME\")]\n        manager_name: String,\n        #[clap(long, value_name = \"EMAIL\")]\n        manager_email: String,\n    },\n    Build {\n        /// Opcional: Caminho para o diretório do projeto.\n        /// Se não for fornecido, usa o diretório atual.\n        path: Option\u003cPathBuf\u003e,\n    },\n    Create {\n        #[clap(subcommand)]\n        create_command: CreateCommands,\n    },\n    List {\n        #[clap(subcommand)]\n        list_command: ListCommands,\n    },\n    Validate {\n        #[clap(subcommand)]\n        validate_command: ValidateCommands,\n    },\n    Report {\n        #[clap(subcommand)]\n        report_command: ReportCommands,\n    },\n    /// Update an existing entity (project, resource, task).\n    Update {\n        #[clap(subcommand)]\n        update_command: UpdateCommands,\n    },\n    /// Delete an entity (soft delete).\n    Delete {\n        #[clap(subcommand)]\n        delete_command: DeleteCommands,\n    },\n    /// Describe a resource to see its details.\n    Describe {\n        #[clap(subcommand)]\n        describe_command: DescribeCommands,\n    },\n    /// Manage tasks within a project\n    Task {\n        #[clap(subcommand)]\n        task_command: TaskCommands,\n    },\n}\n\n#[derive(Subcommand, Debug)]\npub enum CreateCommands {\n    Project {\n        name: String,\n        description: Option\u003cString\u003e,\n    },\n    Resource {\n        name: String,\n        resource_type: String,\n    },\n    Vacation {\n        #[arg(long, short)]\n        resource: String,\n        #[arg(long, short)]\n        start_date: String,\n        #[arg(long, short)]\n        end_date: String,\n        #[arg(long, short, default_value = \"false\")]\n        is_time_off_compensation: bool,\n        #[arg(long, short)]\n        compensated_hours: Option\u003cu32\u003e,\n    },\n    TimeOff {\n        #[arg(long)]\n        resource: String,\n        #[arg(long)]\n        hours: u32,\n        #[arg(long)]\n        date: String,\n        #[arg(long)]\n        description: Option\u003cString\u003e,\n    },\n    Task {\n        #[arg(long)]\n        project_code: Option\u003cString\u003e,\n        #[arg(long)]\n        code: Option\u003cString\u003e,\n        #[arg(long)]\n        name: String,\n        #[arg(long)]\n        description: Option\u003cString\u003e,\n        #[arg(long)]\n        start_date: String,\n        #[arg(long)]\n        due_date: String,\n        #[arg(long, value_delimiter = ',')]\n        assignees: Vec\u003cString\u003e,\n    },\n}\n\n#[derive(Subcommand, Debug)]\npub enum ListCommands {\n    Projects,\n    Resources,\n    Tasks,\n}\n\n#[derive(Debug, Subcommand)]\npub enum UpdateCommands {\n    /// Update an existing project's details.\n    Project {\n        /// The new name of the project.\n        #[clap(long)]\n        name: Option\u003cString\u003e,\n        /// The new description of the project.\n        #[clap(long)]\n        description: Option\u003cString\u003e,\n    },\n    /// Update an existing resource's details.\n    Resource {\n        /// The code of the resource to update.\n        code: String,\n        /// The new name for the resource.\n        #[clap(long)]\n        name: Option\u003cString\u003e,\n        /// The new email for the resource.\n        #[clap(long)]\n        email: Option\u003cString\u003e,\n        /// The new type for the resource (e.g., Developer, QA).\n        #[clap(long)]\n        resource_type: Option\u003cString\u003e,\n    },\n    /// Update an existing task's details.\n    Task {\n        /// The code of the task to update.\n        code: String,\n        /// The new name for the task.\n        #[clap(long)]\n        name: Option\u003cString\u003e,\n        /// The new description for the task.\n        #[clap(long)]\n        description: Option\u003cString\u003e,\n        /// The new start date for the task (YYYY-MM-DD).\n        #[clap(long)]\n        start_date: Option\u003cString\u003e,\n        /// The new due date for the task (YYYY-MM-DD).\n        #[clap(long)]\n        due_date: Option\u003cString\u003e,\n    },\n}\n\n#[derive(Debug, Subcommand)]\npub enum DeleteCommands {\n    /// Deletes (cancels) the current project.\n    #[clap(alias = \"proj\")]\n    Project {},\n    /// Deletes (deactivates) a resource.\n    #[clap(alias = \"res\")]\n    Resource {\n        /// The code of the resource to delete.\n        code: String,\n    },\n    /// Deletes (cancels) a task.\n    Task {\n        /// The code of the task to delete.\n        code: String,\n    },\n}\n\n#[derive(Debug, Subcommand)]\npub enum DescribeCommands {\n    /// Describe the current project's details.\n    #[clap(alias = \"proj\")]\n    Project {},\n    /// Describe a resource to see its details.\n    #[clap(alias = \"res\")]\n    Resource {\n        /// The code of the resource to describe.\n        code: String,\n    },\n    /// Describe a task to see its details.\n    Task {\n        /// The code of the task to describe.\n        code: String,\n    },\n    /// Describe the global configuration.\n    Config {},\n}\n\n#[derive(Subcommand)]\nenum ValidateCommands {\n    Vacations,\n}\n\n#[derive(Subcommand)]\nenum ReportCommands {\n    Vacation,\n    Task,\n}\n\n#[derive(Subcommand, Debug)]\nenum TaskCommands {\n    /// Assign one or more resources to a task\n    Assign {\n        /// The code of the task to assign resources to\n        #[arg(long, short)]\n        task: String,\n        /// A comma-separated list of resource codes to assign\n        #[arg(long, short, value_delimiter = ',')]\n        resources: Vec\u003cString\u003e,\n    },\n    /// Link one task as a dependency of another\n    Link {\n        /// The task that will have a new dependency\n        #[arg(value_name = \"TASK_CODE\")]\n        task: String,\n        /// The task that must be completed first\n        #[arg(long = \"waits-for\", value_name = \"DEPENDENCY_CODE\")]\n        dependency: String,\n    },\n}\n\npub fn run(cli: Cli) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync + 'static\u003e\u003e {\n    match \u0026cli.command {\n        Commands::Init {\n            path,\n            manager_name,\n            manager_email,\n        } =\u003e {\n            let repository = FileConfigRepository::new();\n            let use_case = InitializeRepositoryUseCase::new(repository);\n            let repo_path = path.clone().unwrap_or(std::env::current_dir()?);\n\n            use_case.execute(repo_path, manager_name.clone(), manager_email.clone())?;\n            Ok(())\n        }\n        Commands::Build { path } =\u003e {\n            let project_path = path.clone().unwrap_or_else(|| PathBuf::from(\".\"));\n            let output_dir = project_path.join(\"public\");\n\n            match BuildUseCase::new(project_path, output_dir.to_str().unwrap()) {\n                Ok(use_case) =\u003e {\n                    if let Err(e) = use_case.execute() {\n                        println!(\"❌ Erro ao construir o site: {e}\");\n                    }\n                }\n                Err(e) =\u003e {\n                    println!(\"❌ Erro ao inicializar o builder: {e}\");\n                }\n            }\n            Ok(())\n        }\n        Commands::Create { create_command } =\u003e match create_command {\n            CreateCommands::Project { name, description } =\u003e {\n                let repository = FileProjectRepository::new();\n                let use_case = CreateProjectUseCase::new(repository);\n\n                use_case.execute(name, description.as_deref())?;\n                Ok(())\n            }\n            CreateCommands::Resource { name, resource_type } =\u003e {\n                let repository = FileResourceRepository::new(\".\");\n                let use_case = CreateResourceUseCase::new(repository);\n\n                let _ = use_case.execute(name, resource_type);\n                Ok(())\n            }\n            CreateCommands::Vacation {\n                resource,\n                start_date,\n                end_date,\n                is_time_off_compensation,\n                compensated_hours,\n            } =\u003e {\n                let repository = FileResourceRepository::new(\".\");\n                let use_case = CreateVacationUseCase::new(repository);\n\n                match use_case.execute(\n                    resource,\n                    start_date,\n                    end_date,\n                    *is_time_off_compensation,\n                    *compensated_hours,\n                ) {\n                    Ok(result) =\u003e {\n                        if result.success {\n                            println!(\"✅ {}\", result.message);\n                        } else {\n                            println!(\"❌ {}\", result.message);\n                        }\n                    }\n                    Err(e) =\u003e println!(\"❌ Erro inesperado: {e}\"),\n                };\n                Ok(())\n            }\n            CreateCommands::TimeOff {\n                resource,\n                hours,\n                date,\n                description,\n            } =\u003e {\n                let repository = FileResourceRepository::new(\".\");\n                let use_case = CreateTimeOffUseCase::new(repository);\n\n                match use_case.execute(resource, *hours, date, description.as_deref()) {\n                    Ok(result) =\u003e {\n                        if result.success {\n                            println!(\"✅ {}\", result.message);\n                            println!(\"📊 Novo saldo: {} horas\", result.time_off_balance);\n                            if let Some(desc) = \u0026result.description {\n                                println!(\"📝 Descrição: {desc}\");\n                            }\n                            println!(\"📅 Data: {}\", result.date);\n                        } else {\n                            println!(\"❌ {}\", result.message);\n                        }\n                    }\n                    Err(e) =\u003e println!(\"❌ Erro inesperado: {e}\"),\n                };\n                Ok(())\n            }\n            CreateCommands::Task {\n                project_code,\n                code: _,\n                name,\n                description,\n                start_date,\n                due_date,\n                assignees,\n            } =\u003e {\n                use chrono::NaiveDate;\n\n                #[derive(Deserialize)]\n                struct ProjMetadata {\n                    code: String,\n                }\n\n                #[derive(Deserialize)]\n                struct ProjManifest {\n                    metadata: ProjMetadata,\n                }\n\n                let final_project_code = match project_code.as_ref() {\n                    Some(code) =\u003e code.clone(),\n                    None =\u003e {\n                        let manifest_path = PathBuf::from(\"project.yaml\");\n                        if !manifest_path.exists() {\n                            println!(\n                                \"❌ Erro: Comando executado fora de um diretório de projeto. Especifique --project-code.\"\n                            );\n                            return Ok(());\n                        }\n                        let content = match std::fs::read_to_string(manifest_path) {\n                            Ok(c) =\u003e c,\n                            Err(e) =\u003e {\n                                println!(\"❌ Erro ao ler 'project.yaml': {e}\");\n                                return Ok(());\n                            }\n                        };\n                        let manifest: ProjManifest = match serde_yaml::from_str(\u0026content) {\n                            Ok(m) =\u003e m,\n                            Err(e) =\u003e {\n                                println!(\"❌ Erro ao analisar 'project.yaml': {e}\");\n                                return Ok(());\n                            }\n                        };\n                        manifest.metadata.code\n                    }\n                };\n\n                let repository = FileProjectRepository::new();\n\n                let start = match NaiveDate::parse_from_str(start_date, \"%Y-%m-%d\") {\n                    Ok(date) =\u003e date,\n                    Err(_) =\u003e {\n                        println!(\"❌ Erro: Data de início inválida. Use o formato YYYY-MM-DD\");\n                        return Ok(());\n                    }\n                };\n\n                let due = match NaiveDate::parse_from_str(due_date, \"%Y-%m-%d\") {\n                    Ok(date) =\u003e date,\n                    Err(_) =\u003e {\n                        println!(\"❌ Erro: Data de vencimento inválida. Use o formato YYYY-MM-DD\");\n                        return Ok(());\n                    }\n                };\n\n                let use_case = CreateTaskUseCase::new(repository);\n\n                let args = CreateTaskArgs {\n                    project_code: final_project_code,\n                    name: name.clone(),\n                    start_date: start,\n                    due_date: due,\n                    assigned_resources: assignees.clone(),\n                };\n\n                match use_case.execute(args) {\n                    Ok(_) =\u003e {\n                        println!(\"✅ Task '{name}' criada com sucesso!\");\n                        // The generated task code is now an internal detail of the project aggregate,\n                        // and the main success message is printed by the use case.\n                        if let Some(desc) = description {\n                            println!(\"📝 Descrição: {desc}\");\n                        }\n                        println!(\"📅 Período: {start_date} até {due_date}\");\n                        if !assignees.is_empty() {\n                            println!(\"👥 Responsáveis: {}\", assignees.join(\", \"));\n                        }\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Erro ao criar task: {e}\");\n                    }\n                };\n                Ok(())\n            }\n        },\n        Commands::List { list_command } =\u003e match list_command {\n            ListCommands::Projects =\u003e {\n                let repository = FileProjectRepository::new();\n                let use_case = ListProjectsUseCase::new(repository);\n                match use_case.execute() {\n                    Ok(projects) =\u003e {\n                        if projects.is_empty() {\n                            println!(\"Nenhum projeto encontrado.\");\n                        } else {\n                            println!(\"{:\u003c15} {:\u003c30}\", \"CÓDIGO\", \"NOME\");\n                            println!(\"{:-\u003c15} {:-\u003c30}\", \"\", \"\");\n                            for project in projects {\n                                println!(\"{:\u003c15} {:\u003c30}\", project.code(), project.name());\n                            }\n                        }\n                    }\n                    Err(e) =\u003e println!(\"❌ Erro ao listar projetos: {e}\"),\n                }\n                Ok(())\n            }\n            ListCommands::Resources =\u003e {\n                let repository = FileResourceRepository::new(\".\");\n                let use_case = ListResourcesUseCase::new(repository);\n                match use_case.execute() {\n                    Ok(resources) =\u003e {\n                        if resources.is_empty() {\n                            println!(\"Nenhum recurso encontrado.\");\n                        } else {\n                            println!(\"{:\u003c15} {:\u003c25} {:\u003c20}\", \"CÓDIGO\", \"NOME\", \"TIPO\");\n                            println!(\"{:-\u003c15} {:-\u003c25} {:-\u003c20}\", \"\", \"\", \"\");\n                            for resource in resources {\n                                println!(\n                                    \"{:\u003c15} {:\u003c25} {:\u003c20}\",\n                                    resource.code(),\n                                    resource.name(),\n                                    resource.resource_type()\n                                );\n                            }\n                        }\n                    }\n                    Err(e) =\u003e println!(\"❌ Erro ao listar recursos: {e}\"),\n                }\n                Ok(())\n            }\n            ListCommands::Tasks =\u003e {\n                let repository = FileProjectRepository::new();\n                let use_case = ListTasksUseCase::new(repository);\n                match use_case.execute() {\n                    Ok(tasks) =\u003e {\n                        if tasks.is_empty() {\n                            println!(\"Nenhuma tarefa encontrada.\");\n                        } else {\n                            println!(\n                                \"{:\u003c15} {:\u003c40} {:\u003c15} {:\u003c20}\",\n                                \"CÓDIGO\", \"NOME\", \"STATUS\", \"RESPONSÁVEIS\"\n                            );\n                            println!(\"{:-\u003c15} {:-\u003c40} {:-\u003c15} {:-\u003c20}\", \"\", \"\", \"\", \"\");\n                            for task in tasks {\n                                let assignees = task.assigned_resources().join(\", \");\n                                println!(\n                                    \"{:\u003c15} {:\u003c40} {:\u003c15} {:\u003c20}\",\n                                    task.code(),\n                                    task.name(),\n                                    task.status().to_string(),\n                                    assignees\n                                );\n                            }\n                        }\n                    }\n                    Err(e) =\u003e println!(\"❌ Erro ao listar tarefas: {e}\"),\n                }\n                Ok(())\n            }\n        },\n        Commands::Update { update_command } =\u003e match update_command {\n            UpdateCommands::Task {\n                code,\n                name,\n                description,\n                start_date,\n                due_date,\n            } =\u003e {\n                use chrono::NaiveDate;\n                use serde::Deserialize;\n\n                #[derive(Deserialize)]\n                struct ProjMetadata {\n                    code: String,\n                }\n\n                #[derive(Deserialize)]\n                struct ProjManifest {\n                    metadata: ProjMetadata,\n                }\n\n                let project_manifest_path = PathBuf::from(\"project.yaml\");\n                let project_code = if project_manifest_path.exists() {\n                    let content = std::fs::read_to_string(project_manifest_path)?;\n                    let manifest: ProjManifest = serde_yaml::from_str(\u0026content)?;\n                    manifest.metadata.code\n                } else {\n                    println!(\"❌ Error: This command must be run from within a project directory.\");\n                    return Ok(());\n                };\n\n                let parsed_start_date = match start_date\n                    .as_ref()\n                    .map(|s| NaiveDate::parse_from_str(s, \"%Y-%m-%d\"))\n                    .transpose()\n                {\n                    Ok(date) =\u003e date,\n                    Err(_) =\u003e {\n                        println!(\"❌ Error: Invalid start date format. Use YYYY-MM-DD.\");\n                        return Ok(());\n                    }\n                };\n\n                let parsed_due_date = match due_date\n                    .as_ref()\n                    .map(|s| NaiveDate::parse_from_str(s, \"%Y-%m-%d\"))\n                    .transpose()\n                {\n                    Ok(date) =\u003e date,\n                    Err(_) =\u003e {\n                        println!(\"❌ Error: Invalid due date format. Use YYYY-MM-DD.\");\n                        return Ok(());\n                    }\n                };\n\n                let project_repo = FileProjectRepository::new();\n                let use_case = UpdateTaskUseCase::new(project_repo);\n\n                let args = UpdateTaskArgs {\n                    name: name.clone(),\n                    description: description.clone(),\n                    start_date: parsed_start_date,\n                    due_date: parsed_due_date,\n                };\n\n                match use_case.execute(\u0026project_code, code, args) {\n                    Ok(updated_task) =\u003e {\n                        println!(\"✅ Successfully updated task '{}'.\", updated_task.code());\n                        println!(\"   Name: {}\", updated_task.name());\n                        println!(\"   Description: {}\", updated_task.description().map_or(\"N/A\", |d| d));\n                        println!(\"   Start Date: {}\", updated_task.start_date());\n                        println!(\"   Due Date: {}\", updated_task.due_date());\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error updating task: {e}\");\n                    }\n                }\n                Ok(())\n            }\n            UpdateCommands::Resource {\n                code,\n                name,\n                email,\n                resource_type,\n            } =\u003e {\n                let resource_repo = FileResourceRepository::new(\".\");\n                let use_case = UpdateResourceUseCase::new(resource_repo);\n\n                let args = UpdateResourceArgs {\n                    name: name.clone(),\n                    email: email.clone(),\n                    resource_type: resource_type.clone(),\n                };\n\n                match use_case.execute(code, args) {\n                    Ok(updated_resource) =\u003e {\n                        println!(\"✅ Successfully updated resource '{}'.\", updated_resource.code());\n                        println!(\"   Name: {}\", updated_resource.name());\n                        println!(\"   Email: {}\", updated_resource.email().map_or(\"N/A\", |e| e));\n                        println!(\"   Type: {}\", updated_resource.resource_type());\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error updating resource: {e}\");\n                    }\n                }\n                Ok(())\n            }\n            UpdateCommands::Project { name, description } =\u003e {\n                use serde::Deserialize;\n\n                #[derive(Deserialize)]\n                struct ProjMetadata {\n                    code: String,\n                }\n\n                #[derive(Deserialize)]\n                struct ProjManifest {\n                    metadata: ProjMetadata,\n                }\n\n                let project_manifest_path = PathBuf::from(\"project.yaml\");\n                let project_code = if project_manifest_path.exists() {\n                    let content = std::fs::read_to_string(project_manifest_path)?;\n                    let manifest: ProjManifest = serde_yaml::from_str(\u0026content)?;\n                    manifest.metadata.code\n                } else {\n                    println!(\"❌ Error: This command must be run from within a project directory.\");\n                    return Ok(());\n                };\n\n                let project_repo = FileProjectRepository::new();\n                let use_case = UpdateProjectUseCase::new(project_repo);\n\n                let args = UpdateProjectArgs {\n                    name: name.clone(),\n                    description: description.clone(),\n                };\n\n                match use_case.execute(\u0026project_code, args) {\n                    Ok(updated_project) =\u003e {\n                        println!(\"✅ Successfully updated project '{}'.\", updated_project.code());\n                        println!(\"   Name: {}\", updated_project.name());\n                        println!(\"   Description: {}\", updated_project.description().map_or(\"N/A\", |d| d));\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error updating project: {e}\");\n                    }\n                }\n                Ok(())\n            }\n        },\n        Commands::Delete { delete_command } =\u003e match delete_command {\n            DeleteCommands::Task { code } =\u003e {\n                use serde::Deserialize;\n\n                #[derive(Deserialize)]\n                struct ProjMetadata {\n                    code: String,\n                }\n\n                #[derive(Deserialize)]\n                struct ProjManifest {\n                    metadata: ProjMetadata,\n                }\n\n                let project_manifest_path = PathBuf::from(\"project.yaml\");\n                let project_code = if project_manifest_path.exists() {\n                    let content = std::fs::read_to_string(project_manifest_path)?;\n                    let manifest: ProjManifest = serde_yaml::from_str(\u0026content)?;\n                    manifest.metadata.code\n                } else {\n                    println!(\"❌ Error: This command must be run from within a project directory.\");\n                    return Ok(());\n                };\n\n                let project_repo = FileProjectRepository::new();\n                let use_case = CancelTaskUseCase::new(project_repo);\n\n                match use_case.execute(\u0026project_code, code) {\n                    Ok(cancelled_task) =\u003e {\n                        println!(\n                            \"✅ Successfully cancelled task '{}' (status is now '{}').\",\n                            cancelled_task.code(),\n                            cancelled_task.status()\n                        );\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error deleting task: {e}\");\n                    }\n                }\n                Ok(())\n            }\n            DeleteCommands::Project {} =\u003e {\n                use serde::Deserialize;\n\n                #[derive(Deserialize)]\n                struct ProjMetadata {\n                    code: String,\n                }\n\n                #[derive(Deserialize)]\n                struct ProjManifest {\n                    metadata: ProjMetadata,\n                }\n\n                let project_manifest_path = PathBuf::from(\"project.yaml\");\n                let project_code = if project_manifest_path.exists() {\n                    let content = std::fs::read_to_string(project_manifest_path)?;\n                    let manifest: ProjManifest = serde_yaml::from_str(\u0026content)?;\n                    manifest.metadata.code\n                } else {\n                    println!(\"❌ Error: This command must be run from within a project directory.\");\n                    return Ok(());\n                };\n\n                let project_repo = FileProjectRepository::new();\n                let use_case = CancelProjectUseCase::new(project_repo);\n\n                match use_case.execute(\u0026project_code) {\n                    Ok(cancelled_project) =\u003e {\n                        println!(\n                            \"✅ Successfully cancelled project '{}'. Its status is now '{}'.\",\n                            cancelled_project.code(),\n                            cancelled_project.status()\n                        );\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error deleting project: {e}\");\n                    }\n                }\n                Ok(())\n            }\n            DeleteCommands::Resource { code } =\u003e {\n                let resource_repo = FileResourceRepository::new(\".\");\n                let use_case = DeactivateResourceUseCase::new(resource_repo);\n\n                match use_case.execute(code) {\n                    Ok(deactivated_resource) =\u003e {\n                        println!(\n                            \"✅ Successfully deactivated resource '{}'. Status is now Inactive.\",\n                            deactivated_resource.code(),\n                        );\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error deleting resource: {e}\");\n                    }\n                }\n                Ok(())\n            }\n        },\n        Commands::Describe { describe_command } =\u003e match describe_command {\n            DescribeCommands::Resource { code } =\u003e {\n                let repo = FileResourceRepository::new(\".\");\n                let use_case = DescribeResourceUseCase::new(repo);\n\n                match use_case.execute(code) {\n                    Ok(resource) =\u003e {\n                        println!(\"{:\u003c20} {}\", \"Name:\", resource.name());\n                        println!(\"{:\u003c20} {}\", \"Code:\", resource.code());\n                        println!(\"{:\u003c20} {}\", \"Type:\", resource.resource_type());\n                        println!(\"{:\u003c20} {}\", \"Status:\", resource.status());\n                        println!(\"{:\u003c20} {}\", \"Email:\", resource.email().map_or(\"N/A\", |e| e));\n                        println!(\"{:\u003c20} {} hours\", \"TimeOff Balance:\", resource.time_off_balance());\n\n                        println!(\"{:\u003c20}\", \"\\nVacations:\");\n                        if let Some(vacations) = resource.vacations() {\n                            if vacations.is_empty() {\n                                println!(\"  No vacations scheduled.\");\n                            } else {\n                                for v in vacations {\n                                    println!(\n                                        \"  - From {} to {} ({})\",\n                                        v.start_date.format(\"%Y-%m-%d\"),\n                                        v.end_date.format(\"%Y-%m-%d\"),\n                                        v.period_type\n                                    );\n                                }\n                            }\n                        } else {\n                            println!(\"  No vacations scheduled.\");\n                        }\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error describing resource: {e}\");\n                    }\n                }\n                Ok(())\n            }\n            DescribeCommands::Project {} =\u003e {\n                use serde::Deserialize;\n\n                #[derive(Deserialize)]\n                struct ProjMetadata {\n                    code: String,\n                }\n\n                #[derive(Deserialize)]\n                struct ProjManifest {\n                    metadata: ProjMetadata,\n                }\n\n                let project_manifest_path = PathBuf::from(\"project.yaml\");\n                let project_code = if project_manifest_path.exists() {\n                    let content = std::fs::read_to_string(project_manifest_path)?;\n                    let manifest: ProjManifest = serde_yaml::from_str(\u0026content)?;\n                    manifest.metadata.code\n                } else {\n                    println!(\"❌ Error: This command must be run from within a project directory.\");\n                    return Ok(());\n                };\n\n                let repo = FileProjectRepository::new();\n                let use_case = DescribeProjectUseCase::new(repo);\n\n                match use_case.execute(\u0026project_code) {\n                    Ok(project) =\u003e {\n                        println!(\"{:\u003c20} {}\", \"Name:\", project.name());\n                        println!(\"{:\u003c20} {}\", \"Code:\", project.code());\n                        println!(\"{:\u003c20} {}\", \"Status:\", project.status());\n                        println!(\"{:\u003c20} {}\", \"Description:\", project.description().map_or(\"N/A\", |d| d));\n\n                        println!(\"{:\u003c20}\", \"\\nTasks:\");\n                        let tasks = project.tasks();\n                        if tasks.is_empty() {\n                            println!(\"  No tasks in this project.\");\n                        } else {\n                            println!(\"  {:\u003c15} {:\u003c40} {:\u003c15}\", \"CODE\", \"NAME\", \"STATUS\");\n                            println!(\"  {:-\u003c15} {:-\u003c40} {:-\u003c15}\", \"\", \"\", \"\");\n                            for task in tasks.values() {\n                                println!(\"  {:\u003c15} {:\u003c40} {:\u003c15}\", task.code(), task.name(), task.status());\n                            }\n                        }\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error describing project: {e}\");\n                    }\n                }\n                Ok(())\n            }\n            DescribeCommands::Task { code } =\u003e {\n                use serde::Deserialize;\n\n                #[derive(Deserialize)]\n                struct ProjMetadata {\n                    code: String,\n                }\n\n                #[derive(Deserialize)]\n                struct ProjManifest {\n                    metadata: ProjMetadata,\n                }\n\n                let project_manifest_path = PathBuf::from(\"project.yaml\");\n                let project_code = if project_manifest_path.exists() {\n                    let content = std::fs::read_to_string(project_manifest_path)?;\n                    let manifest: ProjManifest = serde_yaml::from_str(\u0026content)?;\n                    manifest.metadata.code\n                } else {\n                    println!(\"❌ Error: This command must be run from within a project directory.\");\n                    return Ok(());\n                };\n\n                let repo = FileProjectRepository::new();\n                let use_case = DescribeTaskUseCase::new(repo);\n\n                match use_case.execute(\u0026project_code, code) {\n                    Ok(task) =\u003e {\n                        println!(\"{:\u003c20} {}\", \"Name:\", task.name());\n                        println!(\"{:\u003c20} {}\", \"Code:\", task.code());\n                        println!(\"{:\u003c20} {}\", \"Project Code:\", task.project_code());\n                        println!(\"{:\u003c20} {}\", \"Status:\", task.status());\n                        println!(\"{:\u003c20} {}\", \"Description:\", task.description().map_or(\"N/A\", |d| d));\n                        println!(\"{:\u003c20} {}\", \"Start Date:\", task.start_date());\n                        println!(\"{:\u003c20} {}\", \"Due Date:\", task.due_date());\n\n                        println!(\"{:\u003c20}\", \"\\nAssigned Resources:\");\n                        let assignees = task.assigned_resources();\n                        if assignees.is_empty() {\n                            println!(\"  No resources assigned.\");\n                        } else {\n                            for res_code in assignees {\n                                println!(\"  - {res_code}\");\n                            }\n                        }\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error describing task: {e}\");\n                    }\n                }\n                Ok(())\n            }\n            DescribeCommands::Config {} =\u003e {\n                let repo = FileConfigRepository::new();\n                match repo.load() {\n                    Ok((config, _)) =\u003e {\n                        println!(\"{:\u003c20} {}\", \"Manager Name:\", config.manager_name);\n                        println!(\"{:\u003c20} {}\", \"Manager Email:\", config.manager_email);\n                    }\n                    Err(e) =\u003e {\n                        println!(\"❌ Error describing configuration: {e}\");\n                    }\n                }\n                Ok(())\n            }\n        },\n        Commands::Validate { validate_command } =\u003e {\n            match validate_command {\n                ValidateCommands::Vacations =\u003e {\n                    let project_repository = FileProjectRepository::new();\n                    let resource_repository = FileResourceRepository::new(\".\");\n                    let use_case = ValidateVacationsUseCase::new(project_repository, resource_repository);\n\n                    match use_case.execute() {\n                        Ok(mensagens) =\u003e {\n                            println!(\"\\nResultado da validação de férias:\");\n                            println!(\"--------------------------------\");\n                            for mensagem in mensagens {\n                                println!(\"{mensagem}\");\n                            }\n                        }\n                        Err(e) =\u003e println!(\"Erro ao validar férias: {e}\"),\n                    }\n                }\n            }\n            Ok(())\n        }\n        Commands::Report { report_command } =\u003e {\n            match report_command {\n                ReportCommands::Vacation =\u003e {\n                    let project_repository = FileProjectRepository::new();\n                    let resource_repository = FileResourceRepository::new(\".\");\n                    let use_case = VacationReportUseCase::new(project_repository, resource_repository);\n\n                    let file_path = \"vacation_report.csv\";\n                    match Writer::from_path(file_path) {\n                        Ok(mut writer) =\u003e {\n                            if let Err(e) = use_case.execute(\u0026mut writer) {\n                                println!(\"❌ Erro ao gerar relatório: {e}\");\n                            } else {\n                                println!(\"✅ Relatório de férias gerado com sucesso em: {file_path}\");\n                            }\n                        }\n                        Err(e) =\u003e {\n                            println!(\"❌ Erro ao criar arquivo de relatório: {e}\");\n                        }\n                    }\n                }\n                ReportCommands::Task =\u003e {\n                    let project_repo = FileProjectRepository::new();\n                    let use_case = TaskReportUseCase::new(project_repo);\n\n                    let file_path = \"tasks_report.csv\";\n                    match Writer::from_path(file_path) {\n                        Ok(mut writer) =\u003e {\n                            if let Err(e) = use_case.execute(\u0026mut writer) {\n                                println!(\"❌ Erro ao gerar relatório de tarefas: {e}\");\n                            } else {\n                                println!(\"✅ Relatório de tarefas gerado com sucesso em: {file_path}\");\n                            }\n                        }\n                        Err(e) =\u003e {\n                            println!(\"❌ Erro ao criar arquivo de relatório de tarefas: {e}\");\n                        }\n                    }\n                }\n            }\n            Ok(())\n        }\n        Commands::Task { task_command } =\u003e {\n            match task_command {\n                TaskCommands::Assign { task, resources } =\u003e {\n                    // Since a task is part of a project, we need to find the project first.\n                    // We infer the project code from the current directory's `project.yaml`.\n                    let project_manifest_path = PathBuf::from(\"project.yaml\");\n                    let project_code = if project_manifest_path.exists() {\n                        let content = std::fs::read_to_string(project_manifest_path)?;\n                        #[derive(Deserialize)]\n                        struct ProjMetadata {\n                            code: String,\n                        }\n                        #[derive(Deserialize)]\n                        struct ProjManifest {\n                            metadata: ProjMetadata,\n                        }\n                        let manifest: ProjManifest = serde_yaml::from_str(\u0026content)?;\n                        manifest.metadata.code\n                    } else {\n                        println!(\"❌ Error: This command must be run from within a project directory.\");\n                        return Ok(());\n                    };\n\n                    let project_repo = FileProjectRepository::new();\n                    let resource_repo = FileResourceRepository::new(\".\");\n                    let use_case = AssignResourceToTaskUseCase::new(project_repo, resource_repo);\n                    let resource_refs: Vec\u003c\u0026str\u003e = resources.iter().map(|s| s.as_str()).collect();\n                    match use_case.execute(\u0026project_code, task, \u0026resource_refs) {\n                        Ok(updated_project) =\u003e {\n                            if let Some(updated_task) = updated_project.tasks().get(task) {\n                                println!(\"✅ Successfully assigned resources to task '{}'.\", updated_task.code());\n                                println!(\"   New assignees: {}\", updated_task.assigned_resources().join(\", \"));\n                            } else {\n                                println!(\"❌ Error: Task '{}' not found in updated project\", task);\n                            }\n                        }\n                        Err(e) =\u003e {\n                            println!(\"❌ Error assigning resources: {e}\");\n                        }\n                    }\n                }\n                TaskCommands::Link { task, dependency } =\u003e {\n                    use serde::Deserialize;\n                    use std::path::PathBuf;\n\n                    let project_manifest_path = PathBuf::from(\"project.yaml\");\n                    let project_code = if project_manifest_path.exists() {\n                        let content = std::fs::read_to_string(project_manifest_path)?;\n                        #[derive(Deserialize)]\n                        struct ProjMetadata {\n                            code: String,\n                        }\n                        #[derive(Deserialize)]\n                        struct ProjManifest {\n                            metadata: ProjMetadata,\n                        }\n                        let manifest: ProjManifest = serde_yaml::from_str(\u0026content)?;\n                        manifest.metadata.code\n                    } else {\n                        println!(\"❌ Error: This command must be run from within a project directory.\");\n                        return Ok(());\n                    };\n\n                    let project_repo = FileProjectRepository::new();\n                    let use_case = LinkTaskUseCase::new(project_repo);\n\n                    match use_case.execute(\u0026project_code, task, dependency) {\n                        Ok(_) =\u003e {\n                            println!(\"✅ Successfully linked task '{task}' to wait for '{dependency}'.\");\n                        }\n                        Err(e) =\u003e {\n                            println!(\"❌ Error linking task: {e}\");\n                        }\n                    }\n                }\n            }\n            Ok(())\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use clap::CommandFactory;\n\n    #[test]\n    fn test_cli_creation() {\n        let cli = Cli::command();\n        assert_eq!(cli.get_name(), \"TaskTaskRevolution\");\n    }\n\n    #[test]\n    fn test_cli_version() {\n        let cli = Cli::command();\n        let version = cli.get_version();\n        assert!(version.is_some());\n        let version_str = version.unwrap().to_string();\n        assert!(!version_str.is_empty());\n    }\n\n    #[test]\n    fn test_cli_about() {\n        let cli = Cli::command();\n        let about = cli.get_about();\n        assert!(about.is_some());\n        let about_str = about.unwrap().to_string();\n        assert!(!about_str.is_empty());\n    }\n\n    #[test]\n    fn test_cli_author() {\n        let cli = Cli::command();\n        let author = cli.get_author();\n        assert!(author.is_some());\n        let author_str = author.unwrap().to_string();\n        assert!(!author_str.is_empty());\n    }\n\n    #[test]\n    fn test_init_command_parsing() {\n        let args = vec![\n            \"ttr\",\n            \"init\",\n            \"--manager-name\",\n            \"John Doe\",\n            \"--manager-email\",\n            \"john@example.com\",\n        ];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Init {\n            manager_name,\n            manager_email,\n            ..\n        } = cli.command\n        {\n            assert_eq!(manager_name, \"John Doe\");\n            assert_eq!(manager_email, \"john@example.com\");\n        } else {\n            panic!(\"Expected Init command\");\n        }\n    }\n\n    #[test]\n    fn test_init_command_with_path() {\n        let args = vec![\n            \"ttr\",\n            \"init\",\n            \"/tmp/test\",\n            \"--manager-name\",\n            \"John Doe\",\n            \"--manager-email\",\n            \"john@example.com\",\n        ];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Init {\n            path,\n            manager_name,\n            manager_email,\n        } = cli.command\n        {\n            assert_eq!(path, Some(PathBuf::from(\"/tmp/test\")));\n            assert_eq!(manager_name, \"John Doe\");\n            assert_eq!(manager_email, \"john@example.com\");\n        } else {\n            panic!(\"Expected Init command\");\n        }\n    }\n\n    #[test]\n    fn test_build_command_parsing() {\n        let args = vec![\"ttr\", \"build\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Build { path } = cli.command {\n            assert_eq!(path, None);\n        } else {\n            panic!(\"Expected Build command\");\n        }\n    }\n\n    #[test]\n    fn test_build_command_with_path() {\n        let args = vec![\"ttr\", \"build\", \"/tmp/test\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Build { path } = cli.command {\n            assert_eq!(path, Some(PathBuf::from(\"/tmp/test\")));\n        } else {\n            panic!(\"Expected Build command\");\n        }\n    }\n\n    #[test]\n    fn test_create_project_command() {\n        let args = vec![\"ttr\", \"create\", \"project\", \"My Project\", \"A test project\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Create { create_command } = cli.command {\n            if let CreateCommands::Project { name, description } = create_command {\n                assert_eq!(name, \"My Project\");\n                assert_eq!(description, Some(\"A test project\".to_string()));\n            } else {\n                panic!(\"Expected CreateCommands::Project\");\n            }\n        } else {\n            panic!(\"Expected Create command\");\n        }\n    }\n\n    #[test]\n    fn test_create_project_command_no_description() {\n        let args = vec![\"ttr\", \"create\", \"project\", \"My Project\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Create { create_command } = cli.command {\n            if let CreateCommands::Project { name, description } = create_command {\n                assert_eq!(name, \"My Project\");\n                assert_eq!(description, None);\n            } else {\n                panic!(\"Expected CreateCommands::Project\");\n            }\n        } else {\n            panic!(\"Expected Create command\");\n        }\n    }\n\n    #[test]\n    fn test_create_resource_command() {\n        let args = vec![\"ttr\", \"create\", \"resource\", \"John Doe\", \"Developer\"];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Create { create_command } = cli.command {\n            if let CreateCommands::Resource { name, resource_type } = create_command {\n                assert_eq!(name, \"John Doe\");\n                assert_eq!(resource_type, \"Developer\");\n            } else {\n                panic!(\"Expected CreateCommands::Resource\");\n            }\n        } else {\n            panic!(\"Expected Create command\");\n        }\n    }\n\n    #[test]\n    fn test_create_vacation_command() {\n        let args = vec![\n            \"ttr\",\n            \"create\",\n            \"vacation\",\n            \"--resource\",\n            \"RES-001\",\n            \"--start-date\",\n            \"2024-01-01\",\n            \"--end-date\",\n            \"2024-01-05\",\n        ];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Create { create_command } = cli.command {\n            if let CreateCommands::Vacation {\n                resource,\n                start_date,\n                end_date,\n                is_time_off_compensation,\n                compensated_hours,\n            } = create_command\n            {\n                assert_eq!(resource, \"RES-001\");\n                assert_eq!(start_date, \"2024-01-01\");\n                assert_eq!(end_date, \"2024-01-05\");\n                assert_eq!(is_time_off_compensation, false);\n                assert_eq!(compensated_hours, None);\n            } else {\n                panic!(\"Expected CreateCommands::Vacation\");\n            }\n        } else {\n            panic!(\"Expected Create command\");\n        }\n    }\n\n    #[test]\n    fn test_create_vacation_command_with_compensation() {\n        let args = vec![\n            \"ttr\",\n            \"create\",\n            \"vacation\",\n            \"--resource\",\n            \"RES-001\",\n            \"--start-date\",\n            \"2024-01-01\",\n            \"--end-date\",\n            \"2024-01-05\",\n            \"--is-time-off-compensation\",\n            \"--compensated-hours\",\n            \"40\",\n        ];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Create { create_command } = cli.command {\n            if let CreateCommands::Vacation {\n                resource,\n                start_date,\n                end_date,\n                is_time_off_compensation,\n                compensated_hours,\n            } = create_command\n            {\n                assert_eq!(resource, \"RES-001\");\n                assert_eq!(start_date, \"2024-01-01\");\n                assert_eq!(end_date, \"2024-01-05\");\n                assert_eq!(is_time_off_compensation, true);\n                assert_eq!(compensated_hours, Some(40));\n            } else {\n                panic!(\"Expected CreateCommands::Vacation\");\n            }\n        } else {\n            panic!(\"Expected Create command\");\n        }\n    }\n\n    #[test]\n    fn test_create_time_off_command() {\n        let args = vec![\n            \"ttr\",\n            \"create\",\n            \"time-off\",\n            \"--resource\",\n            \"RES-001\",\n            \"--hours\",\n            \"8\",\n            \"--date\",\n            \"2024-01-01\",\n            \"--description\",\n            \"Sick leave\",\n        ];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Create { create_command } = cli.command {\n            if let CreateCommands::TimeOff {\n                resource,\n                hours,\n                date,\n                description,\n            } = create_command\n            {\n                assert_eq!(resource, \"RES-001\");\n                assert_eq!(hours, 8);\n                assert_eq!(date, \"2024-01-01\");\n                assert_eq!(description, Some(\"Sick leave\".to_string()));\n            } else {\n                panic!(\"Expected CreateCommands::TimeOff\");\n            }\n        } else {\n            panic!(\"Expected Create command\");\n        }\n    }\n\n    #[test]\n    fn test_create_time_off_command_no_description() {\n        let args = vec![\n            \"ttr\",\n            \"create\",\n            \"time-off\",\n            \"--resource\",\n            \"RES-001\",\n            \"--hours\",\n            \"8\",\n            \"--date\",\n            \"2024-01-01\",\n        ];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Create { create_command } = cli.command {\n            if let CreateCommands::TimeOff {\n                resource,\n                hours,\n                date,\n                description,\n            } = create_command\n            {\n                assert_eq!(resource, \"RES-001\");\n                assert_eq!(hours, 8);\n                assert_eq!(date, \"2024-01-01\");\n                assert_eq!(description, None);\n            } else {\n                panic!(\"Expected CreateCommands::TimeOff\");\n            }\n        } else {\n            panic!(\"Expected Create command\");\n        }\n    }\n\n    #[test]\n    fn test_create_task_command() {\n        let args = vec![\n            \"ttr\",\n            \"create\",\n            \"task\",\n            \"--project-code\",\n            \"PROJ-001\",\n            \"--code\",\n            \"TASK-001\",\n            \"--name\",\n            \"Implement feature\",\n            \"--description\",\n            \"A test task\",\n            \"--start-date\",\n            \"2024-01-01\",\n            \"--due-date\",\n            \"2024-01-15\",\n            \"--assignees\",\n            \"RES-001,RES-002\",\n        ];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Create { create_command } = cli.command {\n            if let CreateCommands::Task {\n                project_code,\n                code,\n                name,\n                description,\n                start_date,\n                due_date,\n                assignees,\n            } = create_command\n            {\n                assert_eq!(project_code, Some(\"PROJ-001\".to_string()));\n                assert_eq!(code, Some(\"TASK-001\".to_string()));\n                assert_eq!(name, \"Implement feature\");\n                assert_eq!(description, Some(\"A test task\".to_string()));\n                assert_eq!(start_date, \"2024-01-01\");\n                assert_eq!(due_date, \"2024-01-15\");\n                assert_eq!(assignees, vec![\"RES-001\".to_string(), \"RES-002\".to_string()]);\n            } else {\n                panic!(\"Expected CreateCommands::Task\");\n            }\n        } else {\n            panic!(\"Expected Create command\");\n        }\n    }\n\n    #[test]\n    fn test_create_task_command_minimal() {\n        let args = vec![\n            \"ttr\",\n            \"create\",\n            \"task\",\n            \"--name\",\n            \"Implement feature\",\n            \"--start-date\",\n            \"2024-01-01\",\n            \"--due-date\",\n            \"2024-01-15\",\n        ];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Create { create_command } = cli.command {\n            if let CreateCommands::Task {\n                project_code,\n                code,\n                name,\n                description,\n                start_date,\n                due_date,\n                assignees,\n            } = create_command\n            {\n                assert_eq!(project_code, None);\n                assert_eq!(code, None);\n                assert_eq!(name, \"Implement feature\");\n                assert_eq!(description, None);\n                assert_eq!(start_date, \"2024-01-01\");\n                assert_eq!(due_date, \"2024-01-15\");\n                assert_eq!(assignees, Vec::\u003cString\u003e::new());\n            } else {\n                panic!(\"Expected CreateCommands::Task\");\n            }\n        } else {\n            panic!(\"Expected Create command\");\n        }\n    }\n\n    #[test]\n    fn test_list_commands() {\n        let commands = vec![\"projects\", \"resources\", \"tasks\"];\n\n        for command in commands {\n            let args = vec![\"ttr\", \"list\", command];\n            let cli = Cli::try_parse_from(args).unwrap();\n\n            if let Commands::List { list_command } = cli.command {\n                match command {\n                    \"projects\" =\u003e {\n                        if let ListCommands::Projects = list_command {\n                            // OK\n                        } else {\n                            panic!(\"Expected ListCommands::Projects\");\n                        }\n                    }\n                    \"resources\" =\u003e {\n                        if let ListCommands::Resources = list_command {\n                            // OK\n                        } else {\n                            panic!(\"Expected ListCommands::Resources\");\n                        }\n                    }\n                    \"tasks\" =\u003e {\n                        if let ListCommands::Tasks = list_command {\n                            // OK\n                        } else {\n                            panic!(\"Expected ListCommands::Tasks\");\n                        }\n                    }\n                    _ =\u003e panic!(\"Unexpected command: {}\", command),\n                }\n            } else {\n                panic!(\"Expected List command\");\n            }\n        }\n    }\n\n    #[test]\n    fn test_update_project_command() {\n        let args = vec![\n            \"ttr\",\n            \"update\",\n            \"project\",\n            \"--name\",\n            \"New Project Name\",\n            \"--description\",\n            \"New description\",\n        ];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Update { update_command } = cli.command {\n            if let UpdateCommands::Project { name, description } = update_command {\n                assert_eq!(name, Some(\"New Project Name\".to_string()));\n                assert_eq!(description, Some(\"New description\".to_string()));\n            } else {\n                panic!(\"Expected UpdateCommands::Project\");\n            }\n        } else {\n            panic!(\"Expected Update command\");\n        }\n    }\n\n    #[test]\n    fn test_update_resource_command() {\n        let args = vec![\n            \"ttr\",\n            \"update\",\n            \"resource\",\n            \"RES-001\",\n            \"--name\",\n            \"New Name\",\n            \"--email\",\n            \"new@email.com\",\n            \"--resource-type\",\n            \"Senior Developer\",\n        ];\n        let cli = Cli::try_parse_from(args).unwrap();\n\n        if let Commands::Update { update_command } = cli.command {\n            if let UpdateCommands::Resource {\n                code,\n                name,\n                email,\n                resource_type,\n            } = update_command\n            {\n                assert_eq!(code, \"RES-001\");\n                assert_eq!(name, Some(\"New Name\".to_string()));\n                assert_eq!(email, Some(\"new@email.com\".to_string()));\n                assert_eq!(resource_type, Some(\"Senior Developer\".to_string()));\n            } else {\n                panic!(\"Expected UpdateCommands::Resource\");\n            }\n        } else {\n            panic!(\"Expected Update command\");\n        }\n    }\n\n    #[test]\n    fn test_cli_help() {\n        let mut cli = Cli::command();\n        let help = cli.render_help().to_string();\n        assert!(help.contains(\"TaskTaskRevolution\"));\n        assert!(help.contains(\"Commands:\"));\n        assert!(help.contains(\"init\"));\n        assert!(help.contains(\"build\"));\n        assert!(help.contains(\"create\"));\n        assert!(help.contains(\"list\"));\n        assert!(help.contains(\"validate\"));\n        assert!(help.contains(\"report\"));\n        assert!(help.contains(\"update\"));\n        assert!(help.contains(\"delete\"));\n        assert!(help.contains(\"describe\"));\n        assert!(help.contains(\"task\"));\n    }\n\n    #[test]\n    fn test_cli_version_flag() {\n        let cli = Cli::command();\n        let version = cli.render_version().to_string();\n        assert!(!version.is_empty());\n    }\n\n    #[test]\n    fn test_cli_long_about() {\n        let cli = Cli::command();\n        let long_about = cli.get_long_about();\n        // long_about pode ser None, então não podemos fazer assert direto\n        // mas podemos verificar que não quebra\n        assert!(true); // Placeholder assertion\n    }\n\n    #[test]\n    fn test_cli_propagate_version() {\n        let mut cli = Cli::command();\n        // Verificar que a versão é propagada para subcomandos\n        let help = cli.render_help().to_string();\n        assert!(help.contains(\"--version\"));\n    }\n\n    #[test]\n    fn test_cli_subcommand_help() {\n        let mut cli = Cli::command();\n        let help = cli.render_help().to_string();\n\n        // Verificar que todos os subcomandos estão documentados\n        // Nota: Alguns comandos podem não aparecer no help principal\n        assert!(help.contains(\"Commands:\"));\n        assert!(help.contains(\"Init\") || help.contains(\"init\"));\n        assert!(help.contains(\"Build\") || help.contains(\"build\"));\n        assert!(help.contains(\"Create\") || help.contains(\"create\"));\n        assert!(help.contains(\"List\") || help.contains(\"list\"));\n        assert!(help.contains(\"Validate\") || help.contains(\"validate\"));\n        assert!(help.contains(\"Report\") || help.contains(\"report\"));\n        assert!(help.contains(\"Update\") || help.contains(\"update\"));\n        assert!(help.contains(\"Delete\") || help.contains(\"delete\"));\n        assert!(help.contains(\"Describe\") || help.contains(\"describe\"));\n        assert!(help.contains(\"Task\") || help.contains(\"task\"));\n    }\n\n    #[test]\n    fn test_cli_author_environment_variable() {\n        // Este teste verifica que o autor é lido da variável de ambiente CARGO_PKG_AUTHORS\n        let cli = Cli::command();\n        let author = cli.get_author();\n        assert!(author.is_some());\n        let author_str = author.unwrap().to_string();\n        // O autor deve ser uma string válida\n        assert!(!author_str.is_empty());\n        assert!(!author_str.contains(\"CARGO_PKG_AUTHORS\"));\n    }\n\n    #[test]\n    fn test_cli_version_environment_variable() {\n        // Este teste verifica que a versão é lida da variável de ambiente CARGO_PKG_VERSION\n        let cli = Cli::command();\n        let version = cli.get_version();\n        assert!(version.is_some());\n        let version_str = version.unwrap().to_string();\n        // A versão deve ser uma string válida\n        assert!(!version_str.is_empty());\n        assert!(!version_str.contains(\"CARGO_PKG_VERSION\"));\n    }\n\n    #[test]\n    fn test_cli_description_environment_variable() {\n        // Este teste verifica que a descrição é lida da variável de ambiente CARGO_PKG_DESCRIPTION\n        let cli = Cli::command();\n        let description = cli.get_about();\n        assert!(description.is_some());\n        let description_str = description.unwrap().to_string();\n        // A descrição deve ser uma string válida\n        assert!(!description_str.is_empty());\n        assert!(!description_str.contains(\"CARGO_PKG_DESCRIPTION\"));\n    }\n}\n","traces":[{"line":276,"address":[1511433,1463424,1465512],"length":1,"stats":{"Line":0}},{"line":277,"address":[1463470],"length":1,"stats":{"Line":0}},{"line":278,"address":[1463814],"length":1,"stats":{"Line":0}},{"line":283,"address":[1463842],"length":1,"stats":{"Line":0}},{"line":284,"address":[1464487],"length":1,"stats":{"Line":0}},{"line":285,"address":[1464502,1465578,1464558,1465644],"length":1,"stats":{"Line":0}},{"line":287,"address":[1465448,1465518,1464875,1465213,1465490],"length":1,"stats":{"Line":0}},{"line":288,"address":[1465379],"length":1,"stats":{"Line":0}},{"line":290,"address":[1463860],"length":1,"stats":{"Line":0}},{"line":291,"address":[1463872,1465666],"length":1,"stats":{"Line":0}},{"line":292,"address":[1465712,1465792],"length":1,"stats":{"Line":0}},{"line":294,"address":[1465824,1466776],"length":1,"stats":{"Line":0}},{"line":295,"address":[1466219],"length":1,"stats":{"Line":0}},{"line":296,"address":[1466308,1466229],"length":1,"stats":{"Line":0}},{"line":297,"address":[1466403,1466465],"length":1,"stats":{"Line":0}},{"line":300,"address":[1466125],"length":1,"stats":{"Line":0}},{"line":301,"address":[1466173,1466676],"length":1,"stats":{"Line":0}},{"line":304,"address":[1466608],"length":1,"stats":{"Line":0}},{"line":306,"address":[1463902],"length":1,"stats":{"Line":0}},{"line":307,"address":[1466828],"length":1,"stats":{"Line":0}},{"line":308,"address":[1466879],"length":1,"stats":{"Line":0}},{"line":309,"address":[1467392],"length":1,"stats":{"Line":0}},{"line":311,"address":[1467407,1467510,1467827],"length":1,"stats":{"Line":0}},{"line":312,"address":[1467781],"length":1,"stats":{"Line":0}},{"line":314,"address":[1466897],"length":1,"stats":{"Line":0}},{"line":315,"address":[1466940],"length":1,"stats":{"Line":0}},{"line":316,"address":[1467877],"length":1,"stats":{"Line":0}},{"line":318,"address":[1467892,1467995],"length":1,"stats":{"Line":0}},{"line":319,"address":[1468088],"length":1,"stats":{"Line":0}},{"line":321,"address":[1467001],"length":1,"stats":{"Line":0}},{"line":328,"address":[1467090],"length":1,"stats":{"Line":0}},{"line":329,"address":[1468134],"length":1,"stats":{"Line":0}},{"line":331,"address":[1468412],"length":1,"stats":{"Line":0}},{"line":332,"address":[1468149],"length":1,"stats":{"Line":0}},{"line":333,"address":[1468252],"length":1,"stats":{"Line":0}},{"line":334,"address":[1468315],"length":1,"stats":{"Line":0}},{"line":335,"address":[1468402],"length":1,"stats":{"Line":0}},{"line":336,"address":[1468406],"length":1,"stats":{"Line":0}},{"line":338,"address":[1468551],"length":1,"stats":{"Line":0}},{"line":339,"address":[1468615],"length":1,"stats":{"Line":0}},{"line":340,"address":[1468652,1468805],"length":1,"stats":{"Line":0}},{"line":342,"address":[1468719,1468625],"length":1,"stats":{"Line":0}},{"line":345,"address":[1468493,1468914],"length":1,"stats":{"Line":0}},{"line":347,"address":[1468876],"length":1,"stats":{"Line":0}},{"line":349,"address":[1467151],"length":1,"stats":{"Line":0}},{"line":355,"address":[1467217],"length":1,"stats":{"Line":0}},{"line":356,"address":[1469049],"length":1,"stats":{"Line":0}},{"line":358,"address":[1469064,1469175],"length":1,"stats":{"Line":0}},{"line":359,"address":[1469462],"length":1,"stats":{"Line":0}},{"line":360,"address":[1469488],"length":1,"stats":{"Line":0}},{"line":361,"address":[1469525,1469684],"length":1,"stats":{"Line":0}},{"line":362,"address":[1469753],"length":1,"stats":{"Line":0}},{"line":363,"address":[1469849],"length":1,"stats":{"Line":0}},{"line":364,"address":[1469976,1469922],"length":1,"stats":{"Line":0}},{"line":366,"address":[1470047,1469949],"length":1,"stats":{"Line":0}},{"line":368,"address":[1469498,1469595],"length":1,"stats":{"Line":0}},{"line":371,"address":[1469404,1470159],"length":1,"stats":{"Line":0}},{"line":373,"address":[1470121],"length":1,"stats":{"Line":0}},{"line":375,"address":[1467319],"length":1,"stats":{"Line":0}},{"line":396,"address":[1467354,1470286],"length":1,"stats":{"Line":0}},{"line":397,"address":[1471489,1470325],"length":1,"stats":{"Line":0}},{"line":399,"address":[1470370],"length":1,"stats":{"Line":0}},{"line":400,"address":[1470401,1470497],"length":1,"stats":{"Line":0}},{"line":401,"address":[1470613,1470524],"length":1,"stats":{"Line":0}},{"line":404,"address":[1470632],"length":1,"stats":{"Line":0}},{"line":406,"address":[1470550,1470663],"length":1,"stats":{"Line":0}},{"line":407,"address":[1470746],"length":1,"stats":{"Line":0}},{"line":408,"address":[1470700],"length":1,"stats":{"Line":0}},{"line":409,"address":[1470716,1471322],"length":1,"stats":{"Line":0}},{"line":410,"address":[1471391],"length":1,"stats":{"Line":0}},{"line":413,"address":[1470818,1470909],"length":1,"stats":{"Line":0}},{"line":414,"address":[1470995],"length":1,"stats":{"Line":0}},{"line":415,"address":[1470953],"length":1,"stats":{"Line":0}},{"line":416,"address":[1470985,1471156],"length":1,"stats":{"Line":0}},{"line":417,"address":[1471225],"length":1,"stats":{"Line":0}},{"line":420,"address":[1471027],"length":1,"stats":{"Line":0}},{"line":424,"address":[1471102],"length":1,"stats":{"Line":0}},{"line":426,"address":[1471636,1471543],"length":1,"stats":{"Line":0}},{"line":427,"address":[1471748],"length":1,"stats":{"Line":0}},{"line":429,"address":[1473482,1471719],"length":1,"stats":{"Line":0}},{"line":430,"address":[1473501],"length":1,"stats":{"Line":0}},{"line":434,"address":[1471769],"length":1,"stats":{"Line":0}},{"line":435,"address":[1471928],"length":1,"stats":{"Line":0}},{"line":437,"address":[1473436,1471899],"length":1,"stats":{"Line":0}},{"line":438,"address":[1473455],"length":1,"stats":{"Line":0}},{"line":442,"address":[1471949],"length":1,"stats":{"Line":0}},{"line":446,"address":[1472052],"length":1,"stats":{"Line":0}},{"line":449,"address":[1472138],"length":1,"stats":{"Line":0}},{"line":452,"address":[1472400,1472353],"length":1,"stats":{"Line":0}},{"line":454,"address":[1472550],"length":1,"stats":{"Line":0}},{"line":457,"address":[1472654],"length":1,"stats":{"Line":0}},{"line":458,"address":[1472788,1472702],"length":1,"stats":{"Line":0}},{"line":460,"address":[1472862,1472737],"length":1,"stats":{"Line":0}},{"line":461,"address":[1472982],"length":1,"stats":{"Line":0}},{"line":462,"address":[1473094,1473021],"length":1,"stats":{"Line":0}},{"line":465,"address":[1472428],"length":1,"stats":{"Line":0}},{"line":466,"address":[1472540,1473328],"length":1,"stats":{"Line":0}},{"line":469,"address":[1473048],"length":1,"stats":{"Line":0}},{"line":472,"address":[1463982],"length":1,"stats":{"Line":0}},{"line":474,"address":[1473593],"length":1,"stats":{"Line":0}},{"line":475,"address":[1473664],"length":1,"stats":{"Line":0}},{"line":476,"address":[1473734,1473687],"length":1,"stats":{"Line":0}},{"line":477,"address":[1473884],"length":1,"stats":{"Line":0}},{"line":478,"address":[1473932,1473994],"length":1,"stats":{"Line":0}},{"line":479,"address":[1474057,1475077],"length":1,"stats":{"Line":0}},{"line":481,"address":[1474000,1474086],"length":1,"stats":{"Line":0}},{"line":482,"address":[1474222],"length":1,"stats":{"Line":0}},{"line":483,"address":[1474598,1474408],"length":1,"stats":{"Line":0}},{"line":484,"address":[1474785,1474672],"length":1,"stats":{"Line":0}},{"line":488,"address":[1473762,1475182],"length":1,"stats":{"Line":0}},{"line":490,"address":[1475126],"length":1,"stats":{"Line":0}},{"line":493,"address":[1473600],"length":1,"stats":{"Line":0}},{"line":494,"address":[1475317],"length":1,"stats":{"Line":0}},{"line":495,"address":[1475340,1475387],"length":1,"stats":{"Line":0}},{"line":496,"address":[1475537],"length":1,"stats":{"Line":0}},{"line":497,"address":[1475585,1475647],"length":1,"stats":{"Line":0}},{"line":498,"address":[1475725,1476970],"length":1,"stats":{"Line":0}},{"line":500,"address":[1475754,1475653],"length":1,"stats":{"Line":0}},{"line":501,"address":[1475933],"length":1,"stats":{"Line":0}},{"line":502,"address":[1476170,1476360],"length":1,"stats":{"Line":0}},{"line":503,"address":[1476580],"length":1,"stats":{"Line":0}},{"line":512,"address":[1475415,1477075],"length":1,"stats":{"Line":0}},{"line":514,"address":[1477019],"length":1,"stats":{"Line":0}},{"line":517,"address":[1473638],"length":1,"stats":{"Line":0}},{"line":518,"address":[1477210],"length":1,"stats":{"Line":0}},{"line":519,"address":[1477280,1477233],"length":1,"stats":{"Line":0}},{"line":520,"address":[1477430],"length":1,"stats":{"Line":0}},{"line":521,"address":[1477478,1477540],"length":1,"stats":{"Line":0}},{"line":522,"address":[1479239,1477633],"length":1,"stats":{"Line":0}},{"line":524,"address":[1477662,1477546],"length":1,"stats":{"Line":0}},{"line":528,"address":[1477884],"length":1,"stats":{"Line":0}},{"line":529,"address":[1478362,1478172],"length":1,"stats":{"Line":0}},{"line":530,"address":[1478558,1478445],"length":1,"stats":{"Line":0}},{"line":531,"address":[1478768],"length":1,"stats":{"Line":0}},{"line":541,"address":[1479344,1477308],"length":1,"stats":{"Line":0}},{"line":543,"address":[1479288],"length":1,"stats":{"Line":0}},{"line":546,"address":[1464135],"length":1,"stats":{"Line":0}},{"line":547,"address":[1482760],"length":1,"stats":{"Line":0}},{"line":567,"address":[1482849],"length":1,"stats":{"Line":0}},{"line":568,"address":[1486948,1486852],"length":1,"stats":{"Line":0}},{"line":569,"address":[1487114,1487001,1490038],"length":1,"stats":{"Line":0}},{"line":570,"address":[1487299,1489984,1487390],"length":1,"stats":{"Line":0}},{"line":571,"address":[1487538],"length":1,"stats":{"Line":0}},{"line":573,"address":[1487064,1486975],"length":1,"stats":{"Line":0}},{"line":574,"address":[1487083],"length":1,"stats":{"Line":0}},{"line":577,"address":[1487691,1487762],"length":1,"stats":{"Line":0}},{"line":578,"address":[1487597],"length":1,"stats":{"Line":0}},{"line":579,"address":[1957737,1957728],"length":1,"stats":{"Line":0}},{"line":580,"address":[1487739],"length":1,"stats":{"Line":0}},{"line":582,"address":[1487843],"length":1,"stats":{"Line":0}},{"line":584,"address":[1489935,1487806],"length":1,"stats":{"Line":0}},{"line":585,"address":[1489954],"length":1,"stats":{"Line":0}},{"line":589,"address":[1487985,1487914],"length":1,"stats":{"Line":0}},{"line":590,"address":[1487864],"length":1,"stats":{"Line":0}},{"line":591,"address":[1487891],"length":1,"stats":{"Line":0}},{"line":592,"address":[1487962],"length":1,"stats":{"Line":0}},{"line":594,"address":[1488058],"length":1,"stats":{"Line":0}},{"line":596,"address":[1488029,1489882],"length":1,"stats":{"Line":0}},{"line":597,"address":[1489901],"length":1,"stats":{"Line":0}},{"line":601,"address":[1488087],"length":1,"stats":{"Line":0}},{"line":602,"address":[1488110],"length":1,"stats":{"Line":0}},{"line":605,"address":[1488125],"length":1,"stats":{"Line":0}},{"line":606,"address":[1488192],"length":1,"stats":{"Line":0}},{"line":611,"address":[1488360,1488464],"length":1,"stats":{"Line":0}},{"line":612,"address":[1488823],"length":1,"stats":{"Line":0}},{"line":613,"address":[1488833,1488912],"length":1,"stats":{"Line":0}},{"line":614,"address":[1489032],"length":1,"stats":{"Line":0}},{"line":615,"address":[1972496,1972512],"length":1,"stats":{"Line":0}},{"line":616,"address":[1489401],"length":1,"stats":{"Line":0}},{"line":617,"address":[1489532],"length":1,"stats":{"Line":0}},{"line":619,"address":[1488665],"length":1,"stats":{"Line":0}},{"line":620,"address":[1488777,1489745],"length":1,"stats":{"Line":0}},{"line":623,"address":[1489670],"length":1,"stats":{"Line":0}},{"line":625,"address":[1482648],"length":1,"stats":{"Line":0}},{"line":631,"address":[1482714],"length":1,"stats":{"Line":0}},{"line":632,"address":[1485209],"length":1,"stats":{"Line":0}},{"line":635,"address":[1485224],"length":1,"stats":{"Line":0}},{"line":636,"address":[1485291],"length":1,"stats":{"Line":0}},{"line":637,"address":[1485359],"length":1,"stats":{"Line":0}},{"line":640,"address":[1485531,1485611],"length":1,"stats":{"Line":0}},{"line":641,"address":[1485925],"length":1,"stats":{"Line":0}},{"line":642,"address":[1486014,1485935],"length":1,"stats":{"Line":0}},{"line":643,"address":[1486134],"length":1,"stats":{"Line":0}},{"line":644,"address":[1486293],"length":1,"stats":{"Line":0}},{"line":645,"address":[1486503],"length":1,"stats":{"Line":0}},{"line":647,"address":[1485767],"length":1,"stats":{"Line":0}},{"line":648,"address":[1486747,1485879],"length":1,"stats":{"Line":0}},{"line":651,"address":[1486669],"length":1,"stats":{"Line":0}},{"line":653,"address":[1482540],"length":1,"stats":{"Line":0}},{"line":666,"address":[1482583],"length":1,"stats":{"Line":0}},{"line":667,"address":[1482883,1482979],"length":1,"stats":{"Line":0}},{"line":668,"address":[1483032,1485118,1483145],"length":1,"stats":{"Line":0}},{"line":669,"address":[1485064,1483330,1483421],"length":1,"stats":{"Line":0}},{"line":670,"address":[1483569],"length":1,"stats":{"Line":0}},{"line":672,"address":[1483006,1483095],"length":1,"stats":{"Line":0}},{"line":673,"address":[1483114],"length":1,"stats":{"Line":0}},{"line":676,"address":[1483628],"length":1,"stats":{"Line":0}},{"line":677,"address":[1483695],"length":1,"stats":{"Line":0}},{"line":680,"address":[1483710],"length":1,"stats":{"Line":0}},{"line":681,"address":[1483774],"length":1,"stats":{"Line":0}},{"line":684,"address":[1483994,1483914],"length":1,"stats":{"Line":0}},{"line":685,"address":[1484267],"length":1,"stats":{"Line":0}},{"line":686,"address":[1484356,1484277],"length":1,"stats":{"Line":0}},{"line":687,"address":[1484476],"length":1,"stats":{"Line":0}},{"line":688,"address":[1484635],"length":1,"stats":{"Line":0}},{"line":690,"address":[1484109],"length":1,"stats":{"Line":0}},{"line":691,"address":[1484911,1484221],"length":1,"stats":{"Line":0}},{"line":694,"address":[1484836],"length":1,"stats":{"Line":0}},{"line":697,"address":[1464243],"length":1,"stats":{"Line":0}},{"line":698,"address":[1490210],"length":1,"stats":{"Line":0}},{"line":711,"address":[1490230],"length":1,"stats":{"Line":0}},{"line":712,"address":[1492858,1492762],"length":1,"stats":{"Line":0}},{"line":713,"address":[1494572,1492911,1493024],"length":1,"stats":{"Line":0}},{"line":714,"address":[1493209,1494518,1493300],"length":1,"stats":{"Line":0}},{"line":715,"address":[1493448],"length":1,"stats":{"Line":0}},{"line":717,"address":[1492885,1492974],"length":1,"stats":{"Line":0}},{"line":718,"address":[1492993],"length":1,"stats":{"Line":0}},{"line":721,"address":[1493507],"length":1,"stats":{"Line":0}},{"line":722,"address":[1493574],"length":1,"stats":{"Line":0}},{"line":724,"address":[1493689,1493589],"length":1,"stats":{"Line":0}},{"line":725,"address":[1493962],"length":1,"stats":{"Line":0}},{"line":726,"address":[1494075],"length":1,"stats":{"Line":0}},{"line":732,"address":[1493804],"length":1,"stats":{"Line":0}},{"line":733,"address":[1493916,1494383],"length":1,"stats":{"Line":0}},{"line":736,"address":[1494316],"length":1,"stats":{"Line":0}},{"line":751,"address":[1490113],"length":1,"stats":{"Line":0}},{"line":752,"address":[1490264,1490360],"length":1,"stats":{"Line":0}},{"line":753,"address":[1490413,1491986,1490526],"length":1,"stats":{"Line":0}},{"line":754,"address":[1490802,1491932,1490711],"length":1,"stats":{"Line":0}},{"line":755,"address":[1490950],"length":1,"stats":{"Line":0}},{"line":757,"address":[1490476,1490387],"length":1,"stats":{"Line":0}},{"line":758,"address":[1490495],"length":1,"stats":{"Line":0}},{"line":761,"address":[1491009],"length":1,"stats":{"Line":0}},{"line":762,"address":[1491076],"length":1,"stats":{"Line":0}},{"line":764,"address":[1491091,1491183],"length":1,"stats":{"Line":0}},{"line":765,"address":[1491376],"length":1,"stats":{"Line":0}},{"line":766,"address":[1491489],"length":1,"stats":{"Line":0}},{"line":772,"address":[1491218],"length":1,"stats":{"Line":0}},{"line":773,"address":[1491330,1491797],"length":1,"stats":{"Line":0}},{"line":776,"address":[1491730],"length":1,"stats":{"Line":0}},{"line":778,"address":[1490152],"length":1,"stats":{"Line":0}},{"line":779,"address":[1490172],"length":1,"stats":{"Line":0}},{"line":780,"address":[1492077],"length":1,"stats":{"Line":0}},{"line":782,"address":[1492092,1492187],"length":1,"stats":{"Line":0}},{"line":783,"address":[1492389],"length":1,"stats":{"Line":0}},{"line":784,"address":[1492494],"length":1,"stats":{"Line":0}},{"line":789,"address":[1492231],"length":1,"stats":{"Line":0}},{"line":790,"address":[1492343,1492675],"length":1,"stats":{"Line":0}},{"line":793,"address":[1492605],"length":1,"stats":{"Line":0}},{"line":796,"address":[1464322],"length":1,"stats":{"Line":0}},{"line":797,"address":[1494689],"length":1,"stats":{"Line":0}},{"line":798,"address":[1494709],"length":1,"stats":{"Line":0}},{"line":799,"address":[1498733],"length":1,"stats":{"Line":0}},{"line":801,"address":[1498748,1498843],"length":1,"stats":{"Line":0}},{"line":802,"address":[1499045],"length":1,"stats":{"Line":0}},{"line":803,"address":[1499134,1499055],"length":1,"stats":{"Line":0}},{"line":804,"address":[1499352],"length":1,"stats":{"Line":0}},{"line":805,"address":[1499609],"length":1,"stats":{"Line":0}},{"line":806,"address":[1499866],"length":1,"stats":{"Line":0}},{"line":807,"address":[1500123],"length":1,"stats":{"Line":0}},{"line":808,"address":[1500431],"length":1,"stats":{"Line":0}},{"line":810,"address":[1500653],"length":1,"stats":{"Line":0}},{"line":811,"address":[1500780],"length":1,"stats":{"Line":0}},{"line":812,"address":[1500914,1500964],"length":1,"stats":{"Line":0}},{"line":813,"address":[1501603,1501009],"length":1,"stats":{"Line":0}},{"line":815,"address":[1501054,1500986],"length":1,"stats":{"Line":0}},{"line":816,"address":[1501252],"length":1,"stats":{"Line":0}},{"line":825,"address":[1501627,1500928],"length":1,"stats":{"Line":0}},{"line":828,"address":[1498887],"length":1,"stats":{"Line":0}},{"line":829,"address":[1501721,1498999],"length":1,"stats":{"Line":0}},{"line":832,"address":[1501651],"length":1,"stats":{"Line":0}},{"line":847,"address":[1494647],"length":1,"stats":{"Line":0}},{"line":848,"address":[1494819,1494915],"length":1,"stats":{"Line":0}},{"line":849,"address":[1494968,1495081,1498642],"length":1,"stats":{"Line":0}},{"line":850,"address":[1495357,1498588,1495266],"length":1,"stats":{"Line":0}},{"line":851,"address":[1495505],"length":1,"stats":{"Line":0}},{"line":853,"address":[1494942,1495031],"length":1,"stats":{"Line":0}},{"line":854,"address":[1495050],"length":1,"stats":{"Line":0}},{"line":857,"address":[1495564],"length":1,"stats":{"Line":0}},{"line":858,"address":[1495631],"length":1,"stats":{"Line":0}},{"line":860,"address":[1495738,1495646],"length":1,"stats":{"Line":0}},{"line":861,"address":[1495931],"length":1,"stats":{"Line":0}},{"line":862,"address":[1496020,1495941],"length":1,"stats":{"Line":0}},{"line":863,"address":[1496238],"length":1,"stats":{"Line":0}},{"line":864,"address":[1496495],"length":1,"stats":{"Line":0}},{"line":865,"address":[1998489,1998480],"length":1,"stats":{"Line":0}},{"line":867,"address":[1497036],"length":1,"stats":{"Line":0}},{"line":868,"address":[1497163],"length":1,"stats":{"Line":0}},{"line":869,"address":[1497194],"length":1,"stats":{"Line":0}},{"line":870,"address":[1497293,1498362],"length":1,"stats":{"Line":0}},{"line":872,"address":[1497221,1497322],"length":1,"stats":{"Line":0}},{"line":873,"address":[1497501],"length":1,"stats":{"Line":0}},{"line":874,"address":[1497754],"length":1,"stats":{"Line":0}},{"line":875,"address":[1497904,1497969],"length":1,"stats":{"Line":0}},{"line":879,"address":[1495773],"length":1,"stats":{"Line":0}},{"line":880,"address":[1498453,1495885],"length":1,"stats":{"Line":0}},{"line":883,"address":[1498386],"length":1,"stats":{"Line":0}},{"line":885,"address":[1494747],"length":1,"stats":{"Line":0}},{"line":898,"address":[1494767],"length":1,"stats":{"Line":0}},{"line":899,"address":[1501808,1501904],"length":1,"stats":{"Line":0}},{"line":900,"address":[1505658,1501957,1502070],"length":1,"stats":{"Line":0}},{"line":901,"address":[1502255,1505604,1502346],"length":1,"stats":{"Line":0}},{"line":902,"address":[1502494],"length":1,"stats":{"Line":0}},{"line":904,"address":[1501931,1502020],"length":1,"stats":{"Line":0}},{"line":905,"address":[1502039],"length":1,"stats":{"Line":0}},{"line":908,"address":[1502553],"length":1,"stats":{"Line":0}},{"line":909,"address":[1502620],"length":1,"stats":{"Line":0}},{"line":911,"address":[1502735,1502635],"length":1,"stats":{"Line":0}},{"line":912,"address":[1503008],"length":1,"stats":{"Line":0}},{"line":913,"address":[1503097,1503018],"length":1,"stats":{"Line":0}},{"line":914,"address":[1503315],"length":1,"stats":{"Line":0}},{"line":915,"address":[1503572],"length":1,"stats":{"Line":0}},{"line":916,"address":[1503829],"length":1,"stats":{"Line":0}},{"line":917,"address":[1504086],"length":1,"stats":{"Line":0}},{"line":918,"address":[1504394],"length":1,"stats":{"Line":0}},{"line":919,"address":[1504623],"length":1,"stats":{"Line":0}},{"line":921,"address":[1504844],"length":1,"stats":{"Line":0}},{"line":922,"address":[1504971],"length":1,"stats":{"Line":0}},{"line":923,"address":[1505048],"length":1,"stats":{"Line":0}},{"line":924,"address":[1505114,1505381],"length":1,"stats":{"Line":0}},{"line":926,"address":[1505091,1505159],"length":1,"stats":{"Line":0}},{"line":927,"address":[1505307,1505265],"length":1,"stats":{"Line":0}},{"line":931,"address":[1502850],"length":1,"stats":{"Line":0}},{"line":932,"address":[1502962,1505469],"length":1,"stats":{"Line":0}},{"line":935,"address":[1505402],"length":1,"stats":{"Line":0}},{"line":938,"address":[1494809],"length":1,"stats":{"Line":0}},{"line":939,"address":[1505796,1505749],"length":1,"stats":{"Line":0}},{"line":940,"address":[1505999],"length":1,"stats":{"Line":0}},{"line":941,"address":[1506009,1506099],"length":1,"stats":{"Line":0}},{"line":942,"address":[1506235],"length":1,"stats":{"Line":0}},{"line":944,"address":[1505841],"length":1,"stats":{"Line":0}},{"line":945,"address":[1505953,1506593],"length":1,"stats":{"Line":0}},{"line":948,"address":[1506688],"length":1,"stats":{"Line":0}},{"line":951,"address":[1464053],"length":1,"stats":{"Line":0}},{"line":954,"address":[1464069],"length":1,"stats":{"Line":0}},{"line":955,"address":[1479463],"length":1,"stats":{"Line":0}},{"line":956,"address":[1479539],"length":1,"stats":{"Line":0}},{"line":958,"address":[1479673,1479626],"length":1,"stats":{"Line":0}},{"line":959,"address":[1479823],"length":1,"stats":{"Line":0}},{"line":960,"address":[1479863,1479930],"length":1,"stats":{"Line":0}},{"line":961,"address":[1479949],"length":1,"stats":{"Line":0}},{"line":962,"address":[1480196,1479994],"length":1,"stats":{"Line":0}},{"line":963,"address":[1480265,1480381],"length":1,"stats":{"Line":0}},{"line":966,"address":[1479701,1480502],"length":1,"stats":{"Line":0}},{"line":970,"address":[1480629],"length":1,"stats":{"Line":0}},{"line":972,"address":[1464087],"length":1,"stats":{"Line":0}},{"line":973,"address":[1464102],"length":1,"stats":{"Line":0}},{"line":975,"address":[1480690],"length":1,"stats":{"Line":0}},{"line":976,"address":[1480697],"length":1,"stats":{"Line":0}},{"line":977,"address":[1480773],"length":1,"stats":{"Line":0}},{"line":979,"address":[1480844],"length":1,"stats":{"Line":0}},{"line":980,"address":[1480871,1480942],"length":1,"stats":{"Line":0}},{"line":981,"address":[1481048],"length":1,"stats":{"Line":0}},{"line":982,"address":[1481066,1481145],"length":1,"stats":{"Line":0}},{"line":983,"address":[1481305,1481240],"length":1,"stats":{"Line":0}},{"line":985,"address":[1481404],"length":1,"stats":{"Line":0}},{"line":988,"address":[1480970],"length":1,"stats":{"Line":0}},{"line":989,"address":[1481564,1481002],"length":1,"stats":{"Line":0}},{"line":994,"address":[1480672],"length":1,"stats":{"Line":0}},{"line":995,"address":[1481714],"length":1,"stats":{"Line":0}},{"line":997,"address":[1481721],"length":1,"stats":{"Line":0}},{"line":998,"address":[1481748,1481819],"length":1,"stats":{"Line":0}},{"line":999,"address":[1481925],"length":1,"stats":{"Line":0}},{"line":1000,"address":[1482022,1481943],"length":1,"stats":{"Line":0}},{"line":1001,"address":[1482117,1482182],"length":1,"stats":{"Line":0}},{"line":1003,"address":[1482281],"length":1,"stats":{"Line":0}},{"line":1006,"address":[1481847],"length":1,"stats":{"Line":0}},{"line":1007,"address":[1482441,1481879],"length":1,"stats":{"Line":0}},{"line":1012,"address":[1481663],"length":1,"stats":{"Line":0}},{"line":1014,"address":[1464389],"length":1,"stats":{"Line":0}},{"line":1015,"address":[1464412],"length":1,"stats":{"Line":0}},{"line":1016,"address":[1506870],"length":1,"stats":{"Line":0}},{"line":1019,"address":[1506905],"length":1,"stats":{"Line":0}},{"line":1020,"address":[1506936,1507032],"length":1,"stats":{"Line":0}},{"line":1021,"address":[1507198,1509509,1507085],"length":1,"stats":{"Line":0}},{"line":1030,"address":[1507474,1507383,1509455],"length":1,"stats":{"Line":0}},{"line":1031,"address":[1507622],"length":1,"stats":{"Line":0}},{"line":1033,"address":[1507059,1507148],"length":1,"stats":{"Line":0}},{"line":1034,"address":[1507167],"length":1,"stats":{"Line":0}},{"line":1037,"address":[1507681],"length":1,"stats":{"Line":0}},{"line":1038,"address":[1507732],"length":1,"stats":{"Line":0}},{"line":1039,"address":[1507805],"length":1,"stats":{"Line":0}},{"line":1040,"address":[1507884,1507967],"length":1,"stats":{"Line":0}},{"line":1041,"address":[1508171,1508072],"length":1,"stats":{"Line":0}},{"line":1042,"address":[1508536],"length":1,"stats":{"Line":0}},{"line":1043,"address":[1508546,1508609],"length":1,"stats":{"Line":0}},{"line":1044,"address":[1508703,1508772],"length":1,"stats":{"Line":0}},{"line":1045,"address":[1508892],"length":1,"stats":{"Line":0}},{"line":1047,"address":[1508726,1509137],"length":1,"stats":{"Line":0}},{"line":1050,"address":[1508378],"length":1,"stats":{"Line":0}},{"line":1051,"address":[1508490,1509267],"length":1,"stats":{"Line":0}},{"line":1055,"address":[1506801],"length":1,"stats":{"Line":0}},{"line":1059,"address":[1506828],"length":1,"stats":{"Line":0}},{"line":1060,"address":[1509680,1509584],"length":1,"stats":{"Line":0}},{"line":1061,"address":[1509733,1509846,1511358],"length":1,"stats":{"Line":0}},{"line":1070,"address":[1511304,1510031,1510122],"length":1,"stats":{"Line":0}},{"line":1071,"address":[1510267],"length":1,"stats":{"Line":0}},{"line":1073,"address":[1509796,1509707],"length":1,"stats":{"Line":0}},{"line":1074,"address":[1509815],"length":1,"stats":{"Line":0}},{"line":1077,"address":[1510326],"length":1,"stats":{"Line":0}},{"line":1078,"address":[1510393],"length":1,"stats":{"Line":0}},{"line":1080,"address":[1510482,1510408],"length":1,"stats":{"Line":0}},{"line":1082,"address":[1510782,1510899],"length":1,"stats":{"Line":0}},{"line":1084,"address":[1510652],"length":1,"stats":{"Line":0}},{"line":1085,"address":[1510764,1511099],"length":1,"stats":{"Line":0}},{"line":1090,"address":[1509404],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":406},{"path":["/","home","flavio","projects","tasktaskrevolution","src","interface","mod.rs"],"content":"pub mod assets;\npub mod cli;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","main.rs"],"content":"#[allow(non_snake_case)]\nmod application;\n#[allow(non_snake_case)]\nmod domain;\n#[allow(non_snake_case)]\nmod infrastructure;\n#[allow(non_snake_case)]\nmod interface;\n\nuse clap::Parser;\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync + 'static\u003e\u003e {\n    let cli = interface::cli::Cli::parse();\n    interface::cli::run(cli)\n}\n","traces":[{"line":12,"address":[2021008],"length":1,"stats":{"Line":0}},{"line":13,"address":[2021025],"length":1,"stats":{"Line":0}},{"line":14,"address":[2021035],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","flavio","projects","tasktaskrevolution","tests","integration","mod.rs"],"content":"// Integration tests module\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","mod.rs"],"content":"pub mod build_use_case;\npub mod initialize_repository_use_case;\n\npub mod create;\npub mod list;\npub mod project;\npub mod report;\npub mod resource;\npub mod task;\npub mod validate;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","validate","mod.rs"],"content":"pub mod vacations;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","flavio","projects","tasktaskrevolution","src","application","validate","vacations.rs"],"content":"use crate::domain::{\n    project_management::{repository::ProjectRepository, vacation_rules::VacationRules, layoff_period::LayoffPeriod},\n    resource_management::repository::ResourceRepository,\n    resource_management::resource::Period,\n    shared::errors::DomainError,\n};\nuse chrono::{DateTime, FixedOffset, Local, NaiveDate, Offset, TimeZone};\n\npub struct ValidateVacationsUseCase\u003cP: ProjectRepository, R: ResourceRepository\u003e {\n    project_repository: P,\n    resource_repository: R,\n}\n\nimpl\u003cP: ProjectRepository, R: ResourceRepository\u003e ValidateVacationsUseCase\u003cP, R\u003e {\n    pub fn new(project_repository: P, resource_repository: R) -\u003e Self {\n        Self {\n            project_repository,\n            resource_repository,\n        }\n    }\n\n    fn check_vacation_overlap(\u0026self, period1: \u0026Period, period2: \u0026Period) -\u003e bool {\n        period1.start_date \u003c= period2.end_date \u0026\u0026 period2.start_date \u003c= period1.end_date\n    }\n\n    fn check_layoff_overlap(\u0026self, vacation_period: \u0026Period, layoff_period: \u0026(String, String)) -\u003e bool {\n        let layoff_start = NaiveDate::parse_from_str(\u0026layoff_period.0, \"%Y-%m-%d\")\n            .unwrap()\n            .and_hms_opt(0, 0, 0)\n            .unwrap();\n        let layoff_end = NaiveDate::parse_from_str(\u0026layoff_period.1, \"%Y-%m-%d\")\n            .unwrap()\n            .and_hms_opt(0, 0, 0)\n            .unwrap();\n\n        let offset = Local::now().offset().fix();\n        let layoff_start: DateTime\u003cFixedOffset\u003e = DateTime::from_naive_utc_and_offset(layoff_start, offset);\n        let layoff_end: DateTime\u003cFixedOffset\u003e = DateTime::from_naive_utc_and_offset(layoff_end, offset);\n\n        vacation_period.start_date \u003c= layoff_end \u0026\u0026 layoff_start \u003c= vacation_period.end_date\n    }\n\n    fn has_valid_layoff_vacation(\u0026self, vacations: \u0026[Period], vacation_rules: \u0026VacationRules) -\u003e bool {\n        if let Some(layoff_periods) = \u0026vacation_rules.layoff_periods\n            \u0026\u0026 let Some(require_layoff) = vacation_rules.require_layoff_vacation_period\n            \u0026\u0026 require_layoff\n        {\n            // Verifica se pelo menos uma férias coincide com algum período de layoff\n            for vacation in vacations {\n                for layoff_period in layoff_periods {\n                    if self.check_layoff_overlap(\n                        vacation,\n                        \u0026(layoff_period.start_date.clone(), layoff_period.end_date.clone()),\n                    ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n        true\n    }\n\n    pub fn execute(\u0026self) -\u003e Result\u003cVec\u003cString\u003e, DomainError\u003e {\n        let resources = self.resource_repository.find_all()?;\n        let project = self.project_repository.load()?;\n        let mut mensagens = Vec::new();\n\n        // Verificar sobreposição entre todos os recursos\n        for (i, resource1) in resources.iter().enumerate() {\n            if let Some(vacations1) = resource1.vacations() {\n                // Verificar sobreposição com outros recursos\n                for resource2 in resources.iter().skip(i + 1) {\n                    if let Some(vacations2) = resource2.vacations() {\n                        for period1 in vacations1 {\n                            for period2 in vacations2 {\n                                if self.check_vacation_overlap(period1, period2) {\n                                    mensagens.push(format!(\n                                        \"⚠️ Sobreposição detectada: {} e {} têm férias sobrepostas entre {} e {}\",\n                                        resource1.name(),\n                                        resource2.name(),\n                                        period1.start_date.format(\"%d/%m/%Y\"),\n                                        period1.end_date.format(\"%d/%m/%Y\")\n                                    ));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Verificar se há férias durante o período de layoff quando necessário\n                if let Some(vacation_rules) = project.vacation_rules()\n                    \u0026\u0026 !self.has_valid_layoff_vacation(vacations1, vacation_rules)\n                {\n                    mensagens.push(format!(\n                        \"⚠️ {} não possui férias durante nenhum período de layoff\",\n                        resource1.name()\n                    ));\n                }\n            }\n        }\n\n        if mensagens.is_empty() {\n            mensagens.push(\"✅ Não foram encontradas sobreposições de férias\".to_string());\n        }\n\n        Ok(mensagens)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::domain::{\n        project_management::{builder::ProjectBuilder, vacation_rules::VacationRules},\n        resource_management::{\n            AnyResource,\n            resource::{PeriodType, Resource},\n            state::Available,\n        },\n    };\n    use chrono::{Duration, Local};\n\n    struct MockProjectRepository {\n        vacation_rules: Option\u003cVacationRules\u003e,\n    }\n\n    struct MockResourceRepository {\n        resources: Vec\u003cAnyResource\u003e,\n    }\n\n    impl ProjectRepository for MockProjectRepository {\n        fn save(\u0026self, _project: crate::domain::project_management::AnyProject) -\u003e Result\u003c(), DomainError\u003e {\n            Ok(())\n        }\n\n        fn load(\u0026self) -\u003e Result\u003ccrate::domain::project_management::AnyProject, DomainError\u003e {\n            let mut builder = ProjectBuilder::new(\"Test Project\".to_string()).code(\"proj-1\".to_string());\n\n            if let Some(rules) = self.vacation_rules.clone() {\n                builder = builder.vacation_rules(rules);\n            }\n\n            Ok(builder.build().start().into())\n        }\n\n        fn get_next_code(\u0026self) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(\"proj-1\".to_string())\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003ccrate::domain::project_management::AnyProject\u003e, DomainError\u003e {\n            let mut builder = ProjectBuilder::new(\"Test Project\".to_string()).code(\"proj-1\".to_string());\n            if let Some(rules) = self.vacation_rules.clone() {\n                builder = builder.vacation_rules(rules);\n            }\n            Ok(vec![builder.build().start().into()])\n        }\n\n        fn find_by_code(\n            \u0026self,\n            code: \u0026str,\n        ) -\u003e Result\u003cOption\u003ccrate::domain::project_management::AnyProject\u003e, DomainError\u003e {\n            if code == \"proj-1\" {\n                let mut builder = ProjectBuilder::new(\"Test Project\".to_string()).code(\"proj-1\".to_string());\n                if let Some(rules) = self.vacation_rules.clone() {\n                    builder = builder.vacation_rules(rules);\n                }\n                Ok(Some(builder.build().start().into()))\n            } else {\n                Ok(None)\n            }\n        }\n    }\n\n    impl ResourceRepository for MockResourceRepository {\n        fn save(\u0026self, resource: AnyResource) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            Ok(resource)\n        }\n\n        fn find_all(\u0026self) -\u003e Result\u003cVec\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(self.resources.clone())\n        }\n        fn find_by_code(\u0026self, _code: \u0026str) -\u003e Result\u003cOption\u003cAnyResource\u003e, DomainError\u003e {\n            Ok(None)\n        }\n\n        fn save_time_off(\n            \u0026self,\n            _resource_name: \u0026str,\n            _hours: u32,\n            _date: \u0026str,\n            _description: Option\u003cString\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!(\"Not needed for these tests\")\n        }\n\n        fn save_vacation(\n            \u0026self,\n            _resource_name: \u0026str,\n            _start_date: \u0026str,\n            _end_date: \u0026str,\n            _is_time_off_compensation: bool,\n            _compensated_hours: Option\u003cu32\u003e,\n        ) -\u003e Result\u003cAnyResource, DomainError\u003e {\n            unimplemented!(\"Not needed for these tests\")\n        }\n\n        fn check_if_layoff_period(\u0026self, _start_date: \u0026DateTime\u003cLocal\u003e, _end_date: \u0026DateTime\u003cLocal\u003e) -\u003e bool {\n            false\n        }\n\n        fn get_next_code(\u0026self, resource_type: \u0026str) -\u003e Result\u003cString, DomainError\u003e {\n            Ok(format!(\"{}-1\", resource_type.to_lowercase()))\n        }\n    }\n\n    #[test]\n    fn test_detect_vacation_overlap() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_no_vacation_overlap() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(5),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(10),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(\n            result\n                .iter()\n                .any(|msg| msg.contains(\"Não foram encontradas sobreposições\"))\n        );\n    }\n\n    #[test]\n    fn test_vacation_overlap_edge_case() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(11),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Não deve haver sobreposição quando há um dia de intervalo\n        assert!(\n            result\n                .iter()\n                .any(|msg| msg.contains(\"Não foram encontradas sobreposições\"))\n        );\n    }\n\n    #[test]\n    fn test_vacation_overlap_contained() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(20),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_vacation_overlap_multiple_periods() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![\n                Period {\n                    start_date: now,\n                    end_date: now + Duration::days(5),\n                    approved: true,\n                    period_type: PeriodType::Vacation,\n                    is_time_off_compensation: false,\n                    compensated_hours: None,\n                    is_layoff: false,\n                },\n                Period {\n                    start_date: now + Duration::days(20),\n                    end_date: now + Duration::days(25),\n                    approved: true,\n                    period_type: PeriodType::Vacation,\n                    is_time_off_compensation: false,\n                    compensated_hours: None,\n                    is_layoff: false,\n                },\n            ]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(3),\n                end_date: now + Duration::days(8),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_vacation_overlap_three_resources() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource3 = Resource::\u003cAvailable\u003e::new(\n            \"dev-3\".to_string(),\n            \"Pedro\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(12),\n                end_date: now + Duration::days(18),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into(), resource3.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição entre resource2 e resource3\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n        assert!(result.iter().any(|msg| msg.contains(\"Maria\") \u0026\u0026 msg.contains(\"Pedro\")));\n    }\n\n    #[test]\n    fn test_vacation_overlap_no_vacations() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            None,\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            None,\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(\n            result\n                .iter()\n                .any(|msg| msg.contains(\"Não foram encontradas sobreposições\"))\n        );\n    }\n\n    #[test]\n    fn test_vacation_overlap_single_resource() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(\n            result\n                .iter()\n                .any(|msg| msg.contains(\"Não foram encontradas sobreposições\"))\n        );\n    }\n\n    #[test]\n    fn test_vacation_overlap_empty_resources() {\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository { resources: vec![] };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        assert!(\n            result\n                .iter()\n                .any(|msg| msg.contains(\"Não foram encontradas sobreposições\"))\n        );\n    }\n\n    #[test]\n    fn test_vacation_overlap_mixed_vacation_types() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::TimeOff,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição independente do tipo de período\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_vacation_overlap_approved_and_unapproved() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now,\n                end_date: now + Duration::days(10),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: false,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { vacation_rules: None };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição independente do status de aprovação\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_success() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-25\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n                LayoffPeriod {\n                    start_date: \"2024-02-01\".to_string(),\n                    end_date: \"2024-02-28\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar que há férias durante período de layoff (sucesso)\n        assert!(result.iter().any(|msg| msg.contains(\"Não foram encontradas sobreposições\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_failure() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(50),\n                end_date: now + Duration::days(60),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n                LayoffPeriod {\n                    start_date: \"2024-02-01\".to_string(),\n                    end_date: \"2024-02-28\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar que não há férias durante período de layoff\n        assert!(result.iter().any(|msg| msg.contains(\"não possui férias durante nenhum período de layoff\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_not_required() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(50),\n                end_date: now + Duration::days(60),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(false),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n                LayoffPeriod {\n                    start_date: \"2024-02-01\".to_string(),\n                    end_date: \"2024-02-28\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Não deve verificar layoff quando não é obrigatório\n        assert!(result.iter().any(|msg| msg.contains(\"Não foram encontradas sobreposições\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_no_layoff_periods() {\n        let now = Local::now();\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: now + Duration::days(5),\n                end_date: now + Duration::days(15),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: None,\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve funcionar mesmo sem períodos de layoff definidos\n        assert!(result.iter().any(|msg| msg.contains(\"Não foram encontradas sobreposições\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_edge_case_overlap() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-25\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-20\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-30\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição entre recursos\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_partial_overlap() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-10\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-20\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-25\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-15\".to_string(),\n                    end_date: \"2024-01-30\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição entre recursos\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_multiple_layoff_periods() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-25\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-20\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-30\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n                LayoffPeriod {\n                    start_date: \"2024-03-01\".to_string(),\n                    end_date: \"2024-03-31\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar sobreposição entre recursos\n        assert!(result.iter().any(|msg| msg.contains(\"Sobreposição detectada\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_no_vacations() {\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n            ]),\n        };\n\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local::now() + Duration::days(60),\n                end_date: Local::now() + Duration::days(75),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: Some(0),\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar que não há férias durante período de layoff\n        assert!(result.iter().any(|msg| msg.contains(\"não possui férias durante nenhum período de layoff\")));\n    }\n\n    #[test]\n    fn test_no_vacation_overlap_success_message() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            None,\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            None,\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: None \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve retornar mensagem de sucesso quando não há sobreposições\n        assert!(result.iter().any(|msg| msg.contains(\"✅ Não foram encontradas sobreposições de férias\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_with_vacations_but_no_layoff_overlap() {\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n            ]),\n        };\n\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local::now() + Duration::days(60),\n                end_date: Local::now() + Duration::days(75),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: Some(0),\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve detectar que não há férias durante período de layoff\n        assert!(result.iter().any(|msg| msg.contains(\"não possui férias durante nenhum período de layoff\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_early_return_true() {\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n            ]),\n        };\n\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-20\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: Some(0),\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Não deve ter mensagem de layoff warning já que férias sobrepõem período de layoff\n        assert!(!result.iter().any(|msg| msg.contains(\"não possui férias durante nenhum período de layoff\")));\n        // Deve retornar mensagem de sucesso\n        assert!(result.iter().any(|msg| msg.contains(\"✅ Não foram encontradas sobreposições de férias\")));\n    }\n\n    #[test]\n    fn test_layoff_vacation_validation_exact_overlap() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-01\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-01-31\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let vacation_rules = VacationRules {\n            max_concurrent_vacations: None,\n            allow_layoff_vacations: Some(true),\n            require_layoff_vacation_period: Some(true),\n            layoff_periods: Some(vec![\n                LayoffPeriod {\n                    start_date: \"2024-01-01\".to_string(),\n                    end_date: \"2024-01-31\".to_string(),\n                },\n            ]),\n        };\n\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: Some(vacation_rules) \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve retornar mensagem de sucesso (não há sobreposições entre recursos)\n        assert!(result.iter().any(|msg| msg.contains(\"✅ Não foram encontradas sobreposições de férias\")));\n    }\n\n    #[test]\n    fn test_no_overlaps_no_layoff_rules() {\n        let resource1 = Resource::\u003cAvailable\u003e::new(\n            \"dev-1\".to_string(),\n            \"João\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-02-01\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-02-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        let resource2 = Resource::\u003cAvailable\u003e::new(\n            \"dev-2\".to_string(),\n            \"Maria\".to_string(),\n            None,\n            \"Dev\".to_string(),\n            Some(vec![Period {\n                start_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-01\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                end_date: Local\n                    .from_local_datetime(\n                        \u0026NaiveDate::parse_from_str(\"2024-03-15\", \"%Y-%m-%d\")\n                            .unwrap()\n                            .and_hms_opt(0, 0, 0)\n                            .unwrap(),\n                    )\n                    .unwrap(),\n                approved: true,\n                period_type: PeriodType::Vacation,\n                is_time_off_compensation: false,\n                compensated_hours: None,\n                is_layoff: false,\n            }]),\n            0,\n        );\n\n        // Sem regras de layoff\n        let mock_project_repo = MockProjectRepository { \n            vacation_rules: None \n        };\n        let mock_resource_repo = MockResourceRepository {\n            resources: vec![resource1.into(), resource2.into()],\n        };\n\n        let use_case = ValidateVacationsUseCase::new(mock_project_repo, mock_resource_repo);\n        let result = use_case.execute().unwrap();\n\n        // Deve retornar mensagem de sucesso (não há sobreposições nem regras de layoff)\n        assert!(result.iter().any(|msg| msg.contains(\"✅ Não foram encontradas sobreposições de férias\")));\n    }\n}\n","traces":[{"line":15,"address":[2214768,2214704],"length":1,"stats":{"Line":12}},{"line":22,"address":[2214848,2214976],"length":1,"stats":{"Line":1}},{"line":23,"address":[2215031,2214903],"length":1,"stats":{"Line":2}},{"line":26,"address":[2215648,2215104],"length":1,"stats":{"Line":8}},{"line":27,"address":[2215700,2215156],"length":1,"stats":{"Line":8}},{"line":31,"address":[2215839,2215295],"length":1,"stats":{"Line":8}},{"line":36,"address":[2215433,2215977],"length":1,"stats":{"Line":8}},{"line":37,"address":[2216021,2215477],"length":1,"stats":{"Line":8}},{"line":38,"address":[2215527,2216071],"length":1,"stats":{"Line":8}},{"line":40,"address":[2215578,2216122],"length":1,"stats":{"Line":8}},{"line":43,"address":[2216880,2217541,2216853,2217547,2216859,2216192],"length":1,"stats":{"Line":7}},{"line":44,"address":[2216952,2216264],"length":1,"stats":{"Line":7}},{"line":45,"address":[2216309,2216347,2217035,2216997],"length":1,"stats":{"Line":18}},{"line":46,"address":[2216362,2217050],"length":1,"stats":{"Line":5}},{"line":49,"address":[2217066,2216393,2217081,2216378],"length":1,"stats":{"Line":11}},{"line":50,"address":[2216459,2217183,2217147,2216495],"length":1,"stats":{"Line":16}},{"line":51,"address":[2216804,2217492,2217436,2216748],"length":1,"stats":{"Line":16}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[2217248,2216560],"length":1,"stats":{"Line":8}},{"line":55,"address":[2217531,2216843],"length":1,"stats":{"Line":5}},{"line":59,"address":[2216476,2217164],"length":1,"stats":{"Line":3}},{"line":61,"address":[2217020,2216332],"length":1,"stats":{"Line":1}},{"line":64,"address":[2223862,2220694,2223886,2217568,2220736,2220718],"length":1,"stats":{"Line":12}},{"line":65,"address":[2217607,2220775],"length":1,"stats":{"Line":2}},{"line":66,"address":[2217800,2217875,2221043,2220980],"length":1,"stats":{"Line":14}},{"line":67,"address":[2221299,2218131],"length":1,"stats":{"Line":13}},{"line":70,"address":[2221446,2221366,2218198,2218278],"length":1,"stats":{"Line":16}},{"line":71,"address":[2218545,2221713,2218811,2221979],"length":1,"stats":{"Line":16}},{"line":73,"address":[2218918,2222086],"length":1,"stats":{"Line":1}},{"line":74,"address":[2222801,2222397,2219229,2219633],"length":1,"stats":{"Line":8}},{"line":75,"address":[2219742,2222910],"length":1,"stats":{"Line":7}},{"line":76,"address":[2219884,2223052],"length":1,"stats":{"Line":1}},{"line":77,"address":[2220024,2223192],"length":1,"stats":{"Line":7}},{"line":78,"address":[2220269,2223437,2220217,2223385],"length":1,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[2220053,2223221],"length":1,"stats":{"Line":2}},{"line":81,"address":[2220104,2223272],"length":1,"stats":{"Line":6}},{"line":82,"address":[2220150,2223318],"length":1,"stats":{"Line":1}},{"line":83,"address":[2220186,2223354],"length":1,"stats":{"Line":2}},{"line":92,"address":[2219263,2222431],"length":1,"stats":{"Line":7}},{"line":93,"address":[2219369,2222537],"length":1,"stats":{"Line":7}},{"line":95,"address":[2222619,2219451],"length":1,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[2219408,2222576],"length":1,"stats":{"Line":3}},{"line":103,"address":[2221739,2218571],"length":1,"stats":{"Line":1}},{"line":104,"address":[2218696,2221864],"length":1,"stats":{"Line":1}},{"line":107,"address":[2221786,2218618],"length":1,"stats":{"Line":1}}],"covered":44,"coverable":47},{"path":["/","home","flavio","projects","tasktaskrevolution","tests","integration","mod.rs"],"content":"// Integration tests module\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>